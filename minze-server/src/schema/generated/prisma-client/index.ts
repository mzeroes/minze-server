// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  city: (where?: CityWhereInput) => Promise<boolean>;
  creditCardInformation: (
    where?: CreditCardInformationWhereInput
  ) => Promise<boolean>;
  debitCardInformation: (
    where?: DebitCardInformationWhereInput
  ) => Promise<boolean>;
  experience: (where?: ExperienceWhereInput) => Promise<boolean>;
  experienceCategory: (
    where?: ExperienceCategoryWhereInput
  ) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  menuItem: (where?: MenuItemWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  neighbourhood: (where?: NeighbourhoodWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  paymentAccount: (where?: PaymentAccountWhereInput) => Promise<boolean>;
  paypalInformation: (where?: PaypalInformationWhereInput) => Promise<boolean>;
  paytmInformation: (where?: PaytmInformationWhereInput) => Promise<boolean>;
  picture: (where?: PictureWhereInput) => Promise<boolean>;
  policies: (where?: PoliciesWhereInput) => Promise<boolean>;
  pricing: (where?: PricingWhereInput) => Promise<boolean>;
  restaurant: (where?: RestaurantWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  city: (where: CityWhereUniqueInput) => CityNullablePromise;
  cities: (args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<City>;
  citiesConnection: (args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CityConnectionPromise;
  creditCardInformation: (
    where: CreditCardInformationWhereUniqueInput
  ) => CreditCardInformationNullablePromise;
  creditCardInformations: (args?: {
    where?: CreditCardInformationWhereInput;
    orderBy?: CreditCardInformationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CreditCardInformation>;
  creditCardInformationsConnection: (args?: {
    where?: CreditCardInformationWhereInput;
    orderBy?: CreditCardInformationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CreditCardInformationConnectionPromise;
  debitCardInformation: (
    where: DebitCardInformationWhereUniqueInput
  ) => DebitCardInformationNullablePromise;
  debitCardInformations: (args?: {
    where?: DebitCardInformationWhereInput;
    orderBy?: DebitCardInformationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DebitCardInformation>;
  debitCardInformationsConnection: (args?: {
    where?: DebitCardInformationWhereInput;
    orderBy?: DebitCardInformationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DebitCardInformationConnectionPromise;
  experience: (where: ExperienceWhereUniqueInput) => ExperienceNullablePromise;
  experiences: (args?: {
    where?: ExperienceWhereInput;
    orderBy?: ExperienceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Experience>;
  experiencesConnection: (args?: {
    where?: ExperienceWhereInput;
    orderBy?: ExperienceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExperienceConnectionPromise;
  experienceCategory: (
    where: ExperienceCategoryWhereUniqueInput
  ) => ExperienceCategoryNullablePromise;
  experienceCategories: (args?: {
    where?: ExperienceCategoryWhereInput;
    orderBy?: ExperienceCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExperienceCategory>;
  experienceCategoriesConnection: (args?: {
    where?: ExperienceCategoryWhereInput;
    orderBy?: ExperienceCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExperienceCategoryConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationNullablePromise;
  locations: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Location>;
  locationsConnection: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LocationConnectionPromise;
  menuItem: (where: MenuItemWhereUniqueInput) => MenuItemNullablePromise;
  menuItems: (args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MenuItem>;
  menuItemsConnection: (args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MenuItemConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessageNullablePromise;
  messages: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Message>;
  messagesConnection: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MessageConnectionPromise;
  neighbourhood: (
    where: NeighbourhoodWhereUniqueInput
  ) => NeighbourhoodNullablePromise;
  neighbourhoods: (args?: {
    where?: NeighbourhoodWhereInput;
    orderBy?: NeighbourhoodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Neighbourhood>;
  neighbourhoodsConnection: (args?: {
    where?: NeighbourhoodWhereInput;
    orderBy?: NeighbourhoodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NeighbourhoodConnectionPromise;
  notification: (
    where: NotificationWhereUniqueInput
  ) => NotificationNullablePromise;
  notifications: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Notification>;
  notificationsConnection: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NotificationConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentNullablePromise;
  payments: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Payment>;
  paymentsConnection: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentConnectionPromise;
  paymentAccount: (
    where: PaymentAccountWhereUniqueInput
  ) => PaymentAccountNullablePromise;
  paymentAccounts: (args?: {
    where?: PaymentAccountWhereInput;
    orderBy?: PaymentAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PaymentAccount>;
  paymentAccountsConnection: (args?: {
    where?: PaymentAccountWhereInput;
    orderBy?: PaymentAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentAccountConnectionPromise;
  paypalInformation: (
    where: PaypalInformationWhereUniqueInput
  ) => PaypalInformationNullablePromise;
  paypalInformations: (args?: {
    where?: PaypalInformationWhereInput;
    orderBy?: PaypalInformationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PaypalInformation>;
  paypalInformationsConnection: (args?: {
    where?: PaypalInformationWhereInput;
    orderBy?: PaypalInformationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaypalInformationConnectionPromise;
  paytmInformation: (
    where: PaytmInformationWhereUniqueInput
  ) => PaytmInformationNullablePromise;
  paytmInformations: (args?: {
    where?: PaytmInformationWhereInput;
    orderBy?: PaytmInformationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PaytmInformation>;
  paytmInformationsConnection: (args?: {
    where?: PaytmInformationWhereInput;
    orderBy?: PaytmInformationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaytmInformationConnectionPromise;
  picture: (where: PictureWhereUniqueInput) => PictureNullablePromise;
  pictures: (args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Picture>;
  picturesConnection: (args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PictureConnectionPromise;
  policies: (where: PoliciesWhereUniqueInput) => PoliciesNullablePromise;
  policieses: (args?: {
    where?: PoliciesWhereInput;
    orderBy?: PoliciesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Policies>;
  policiesesConnection: (args?: {
    where?: PoliciesWhereInput;
    orderBy?: PoliciesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PoliciesConnectionPromise;
  pricing: (where: PricingWhereUniqueInput) => PricingNullablePromise;
  pricings: (args?: {
    where?: PricingWhereInput;
    orderBy?: PricingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Pricing>;
  pricingsConnection: (args?: {
    where?: PricingWhereInput;
    orderBy?: PricingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PricingConnectionPromise;
  restaurant: (where: RestaurantWhereUniqueInput) => RestaurantNullablePromise;
  restaurants: (args?: {
    where?: RestaurantWhereInput;
    orderBy?: RestaurantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Restaurant>;
  restaurantsConnection: (args?: {
    where?: RestaurantWhereInput;
    orderBy?: RestaurantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RestaurantConnectionPromise;
  review: (where: ReviewWhereUniqueInput) => ReviewNullablePromise;
  reviews: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Review>;
  reviewsConnection: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReviewConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCity: (data: CityCreateInput) => CityPromise;
  updateCity: (args: {
    data: CityUpdateInput;
    where: CityWhereUniqueInput;
  }) => CityPromise;
  updateManyCities: (args: {
    data: CityUpdateManyMutationInput;
    where?: CityWhereInput;
  }) => BatchPayloadPromise;
  upsertCity: (args: {
    where: CityWhereUniqueInput;
    create: CityCreateInput;
    update: CityUpdateInput;
  }) => CityPromise;
  deleteCity: (where: CityWhereUniqueInput) => CityPromise;
  deleteManyCities: (where?: CityWhereInput) => BatchPayloadPromise;
  createCreditCardInformation: (
    data: CreditCardInformationCreateInput
  ) => CreditCardInformationPromise;
  updateCreditCardInformation: (args: {
    data: CreditCardInformationUpdateInput;
    where: CreditCardInformationWhereUniqueInput;
  }) => CreditCardInformationPromise;
  updateManyCreditCardInformations: (args: {
    data: CreditCardInformationUpdateManyMutationInput;
    where?: CreditCardInformationWhereInput;
  }) => BatchPayloadPromise;
  upsertCreditCardInformation: (args: {
    where: CreditCardInformationWhereUniqueInput;
    create: CreditCardInformationCreateInput;
    update: CreditCardInformationUpdateInput;
  }) => CreditCardInformationPromise;
  deleteCreditCardInformation: (
    where: CreditCardInformationWhereUniqueInput
  ) => CreditCardInformationPromise;
  deleteManyCreditCardInformations: (
    where?: CreditCardInformationWhereInput
  ) => BatchPayloadPromise;
  createDebitCardInformation: (
    data: DebitCardInformationCreateInput
  ) => DebitCardInformationPromise;
  updateDebitCardInformation: (args: {
    data: DebitCardInformationUpdateInput;
    where: DebitCardInformationWhereUniqueInput;
  }) => DebitCardInformationPromise;
  updateManyDebitCardInformations: (args: {
    data: DebitCardInformationUpdateManyMutationInput;
    where?: DebitCardInformationWhereInput;
  }) => BatchPayloadPromise;
  upsertDebitCardInformation: (args: {
    where: DebitCardInformationWhereUniqueInput;
    create: DebitCardInformationCreateInput;
    update: DebitCardInformationUpdateInput;
  }) => DebitCardInformationPromise;
  deleteDebitCardInformation: (
    where: DebitCardInformationWhereUniqueInput
  ) => DebitCardInformationPromise;
  deleteManyDebitCardInformations: (
    where?: DebitCardInformationWhereInput
  ) => BatchPayloadPromise;
  createExperience: (data: ExperienceCreateInput) => ExperiencePromise;
  updateExperience: (args: {
    data: ExperienceUpdateInput;
    where: ExperienceWhereUniqueInput;
  }) => ExperiencePromise;
  updateManyExperiences: (args: {
    data: ExperienceUpdateManyMutationInput;
    where?: ExperienceWhereInput;
  }) => BatchPayloadPromise;
  upsertExperience: (args: {
    where: ExperienceWhereUniqueInput;
    create: ExperienceCreateInput;
    update: ExperienceUpdateInput;
  }) => ExperiencePromise;
  deleteExperience: (where: ExperienceWhereUniqueInput) => ExperiencePromise;
  deleteManyExperiences: (where?: ExperienceWhereInput) => BatchPayloadPromise;
  createExperienceCategory: (
    data: ExperienceCategoryCreateInput
  ) => ExperienceCategoryPromise;
  updateExperienceCategory: (args: {
    data: ExperienceCategoryUpdateInput;
    where: ExperienceCategoryWhereUniqueInput;
  }) => ExperienceCategoryPromise;
  updateManyExperienceCategories: (args: {
    data: ExperienceCategoryUpdateManyMutationInput;
    where?: ExperienceCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertExperienceCategory: (args: {
    where: ExperienceCategoryWhereUniqueInput;
    create: ExperienceCategoryCreateInput;
    update: ExperienceCategoryUpdateInput;
  }) => ExperienceCategoryPromise;
  deleteExperienceCategory: (
    where: ExperienceCategoryWhereUniqueInput
  ) => ExperienceCategoryPromise;
  deleteManyExperienceCategories: (
    where?: ExperienceCategoryWhereInput
  ) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (args: {
    data: LocationUpdateInput;
    where: LocationWhereUniqueInput;
  }) => LocationPromise;
  updateManyLocations: (args: {
    data: LocationUpdateManyMutationInput;
    where?: LocationWhereInput;
  }) => BatchPayloadPromise;
  upsertLocation: (args: {
    where: LocationWhereUniqueInput;
    create: LocationCreateInput;
    update: LocationUpdateInput;
  }) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createMenuItem: (data: MenuItemCreateInput) => MenuItemPromise;
  updateMenuItem: (args: {
    data: MenuItemUpdateInput;
    where: MenuItemWhereUniqueInput;
  }) => MenuItemPromise;
  updateManyMenuItems: (args: {
    data: MenuItemUpdateManyMutationInput;
    where?: MenuItemWhereInput;
  }) => BatchPayloadPromise;
  upsertMenuItem: (args: {
    where: MenuItemWhereUniqueInput;
    create: MenuItemCreateInput;
    update: MenuItemUpdateInput;
  }) => MenuItemPromise;
  deleteMenuItem: (where: MenuItemWhereUniqueInput) => MenuItemPromise;
  deleteManyMenuItems: (where?: MenuItemWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (args: {
    data: MessageUpdateInput;
    where: MessageWhereUniqueInput;
  }) => MessagePromise;
  updateManyMessages: (args: {
    data: MessageUpdateManyMutationInput;
    where?: MessageWhereInput;
  }) => BatchPayloadPromise;
  upsertMessage: (args: {
    where: MessageWhereUniqueInput;
    create: MessageCreateInput;
    update: MessageUpdateInput;
  }) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createNeighbourhood: (data: NeighbourhoodCreateInput) => NeighbourhoodPromise;
  updateNeighbourhood: (args: {
    data: NeighbourhoodUpdateInput;
    where: NeighbourhoodWhereUniqueInput;
  }) => NeighbourhoodPromise;
  updateManyNeighbourhoods: (args: {
    data: NeighbourhoodUpdateManyMutationInput;
    where?: NeighbourhoodWhereInput;
  }) => BatchPayloadPromise;
  upsertNeighbourhood: (args: {
    where: NeighbourhoodWhereUniqueInput;
    create: NeighbourhoodCreateInput;
    update: NeighbourhoodUpdateInput;
  }) => NeighbourhoodPromise;
  deleteNeighbourhood: (
    where: NeighbourhoodWhereUniqueInput
  ) => NeighbourhoodPromise;
  deleteManyNeighbourhoods: (
    where?: NeighbourhoodWhereInput
  ) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (args: {
    data: NotificationUpdateInput;
    where: NotificationWhereUniqueInput;
  }) => NotificationPromise;
  updateManyNotifications: (args: {
    data: NotificationUpdateManyMutationInput;
    where?: NotificationWhereInput;
  }) => BatchPayloadPromise;
  upsertNotification: (args: {
    where: NotificationWhereUniqueInput;
    create: NotificationCreateInput;
    update: NotificationUpdateInput;
  }) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (args: {
    data: PaymentUpdateInput;
    where: PaymentWhereUniqueInput;
  }) => PaymentPromise;
  updateManyPayments: (args: {
    data: PaymentUpdateManyMutationInput;
    where?: PaymentWhereInput;
  }) => BatchPayloadPromise;
  upsertPayment: (args: {
    where: PaymentWhereUniqueInput;
    create: PaymentCreateInput;
    update: PaymentUpdateInput;
  }) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createPaymentAccount: (
    data: PaymentAccountCreateInput
  ) => PaymentAccountPromise;
  updatePaymentAccount: (args: {
    data: PaymentAccountUpdateInput;
    where: PaymentAccountWhereUniqueInput;
  }) => PaymentAccountPromise;
  updateManyPaymentAccounts: (args: {
    data: PaymentAccountUpdateManyMutationInput;
    where?: PaymentAccountWhereInput;
  }) => BatchPayloadPromise;
  upsertPaymentAccount: (args: {
    where: PaymentAccountWhereUniqueInput;
    create: PaymentAccountCreateInput;
    update: PaymentAccountUpdateInput;
  }) => PaymentAccountPromise;
  deletePaymentAccount: (
    where: PaymentAccountWhereUniqueInput
  ) => PaymentAccountPromise;
  deleteManyPaymentAccounts: (
    where?: PaymentAccountWhereInput
  ) => BatchPayloadPromise;
  createPaypalInformation: (
    data: PaypalInformationCreateInput
  ) => PaypalInformationPromise;
  updatePaypalInformation: (args: {
    data: PaypalInformationUpdateInput;
    where: PaypalInformationWhereUniqueInput;
  }) => PaypalInformationPromise;
  updateManyPaypalInformations: (args: {
    data: PaypalInformationUpdateManyMutationInput;
    where?: PaypalInformationWhereInput;
  }) => BatchPayloadPromise;
  upsertPaypalInformation: (args: {
    where: PaypalInformationWhereUniqueInput;
    create: PaypalInformationCreateInput;
    update: PaypalInformationUpdateInput;
  }) => PaypalInformationPromise;
  deletePaypalInformation: (
    where: PaypalInformationWhereUniqueInput
  ) => PaypalInformationPromise;
  deleteManyPaypalInformations: (
    where?: PaypalInformationWhereInput
  ) => BatchPayloadPromise;
  createPaytmInformation: (
    data: PaytmInformationCreateInput
  ) => PaytmInformationPromise;
  updatePaytmInformation: (args: {
    data: PaytmInformationUpdateInput;
    where: PaytmInformationWhereUniqueInput;
  }) => PaytmInformationPromise;
  updateManyPaytmInformations: (args: {
    data: PaytmInformationUpdateManyMutationInput;
    where?: PaytmInformationWhereInput;
  }) => BatchPayloadPromise;
  upsertPaytmInformation: (args: {
    where: PaytmInformationWhereUniqueInput;
    create: PaytmInformationCreateInput;
    update: PaytmInformationUpdateInput;
  }) => PaytmInformationPromise;
  deletePaytmInformation: (
    where: PaytmInformationWhereUniqueInput
  ) => PaytmInformationPromise;
  deleteManyPaytmInformations: (
    where?: PaytmInformationWhereInput
  ) => BatchPayloadPromise;
  createPicture: (data: PictureCreateInput) => PicturePromise;
  updatePicture: (args: {
    data: PictureUpdateInput;
    where: PictureWhereUniqueInput;
  }) => PicturePromise;
  updateManyPictures: (args: {
    data: PictureUpdateManyMutationInput;
    where?: PictureWhereInput;
  }) => BatchPayloadPromise;
  upsertPicture: (args: {
    where: PictureWhereUniqueInput;
    create: PictureCreateInput;
    update: PictureUpdateInput;
  }) => PicturePromise;
  deletePicture: (where: PictureWhereUniqueInput) => PicturePromise;
  deleteManyPictures: (where?: PictureWhereInput) => BatchPayloadPromise;
  createPolicies: (data: PoliciesCreateInput) => PoliciesPromise;
  updatePolicies: (args: {
    data: PoliciesUpdateInput;
    where: PoliciesWhereUniqueInput;
  }) => PoliciesPromise;
  updateManyPolicieses: (args: {
    data: PoliciesUpdateManyMutationInput;
    where?: PoliciesWhereInput;
  }) => BatchPayloadPromise;
  upsertPolicies: (args: {
    where: PoliciesWhereUniqueInput;
    create: PoliciesCreateInput;
    update: PoliciesUpdateInput;
  }) => PoliciesPromise;
  deletePolicies: (where: PoliciesWhereUniqueInput) => PoliciesPromise;
  deleteManyPolicieses: (where?: PoliciesWhereInput) => BatchPayloadPromise;
  createPricing: (data: PricingCreateInput) => PricingPromise;
  updatePricing: (args: {
    data: PricingUpdateInput;
    where: PricingWhereUniqueInput;
  }) => PricingPromise;
  updateManyPricings: (args: {
    data: PricingUpdateManyMutationInput;
    where?: PricingWhereInput;
  }) => BatchPayloadPromise;
  upsertPricing: (args: {
    where: PricingWhereUniqueInput;
    create: PricingCreateInput;
    update: PricingUpdateInput;
  }) => PricingPromise;
  deletePricing: (where: PricingWhereUniqueInput) => PricingPromise;
  deleteManyPricings: (where?: PricingWhereInput) => BatchPayloadPromise;
  createRestaurant: (data: RestaurantCreateInput) => RestaurantPromise;
  updateRestaurant: (args: {
    data: RestaurantUpdateInput;
    where: RestaurantWhereUniqueInput;
  }) => RestaurantPromise;
  updateManyRestaurants: (args: {
    data: RestaurantUpdateManyMutationInput;
    where?: RestaurantWhereInput;
  }) => BatchPayloadPromise;
  upsertRestaurant: (args: {
    where: RestaurantWhereUniqueInput;
    create: RestaurantCreateInput;
    update: RestaurantUpdateInput;
  }) => RestaurantPromise;
  deleteRestaurant: (where: RestaurantWhereUniqueInput) => RestaurantPromise;
  deleteManyRestaurants: (where?: RestaurantWhereInput) => BatchPayloadPromise;
  createReview: (data: ReviewCreateInput) => ReviewPromise;
  updateReview: (args: {
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
  }) => ReviewPromise;
  updateManyReviews: (args: {
    data: ReviewUpdateManyMutationInput;
    where?: ReviewWhereInput;
  }) => BatchPayloadPromise;
  upsertReview: (args: {
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
  }) => ReviewPromise;
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  city: (
    where?: CitySubscriptionWhereInput
  ) => CitySubscriptionPayloadSubscription;
  creditCardInformation: (
    where?: CreditCardInformationSubscriptionWhereInput
  ) => CreditCardInformationSubscriptionPayloadSubscription;
  debitCardInformation: (
    where?: DebitCardInformationSubscriptionWhereInput
  ) => DebitCardInformationSubscriptionPayloadSubscription;
  experience: (
    where?: ExperienceSubscriptionWhereInput
  ) => ExperienceSubscriptionPayloadSubscription;
  experienceCategory: (
    where?: ExperienceCategorySubscriptionWhereInput
  ) => ExperienceCategorySubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  menuItem: (
    where?: MenuItemSubscriptionWhereInput
  ) => MenuItemSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  neighbourhood: (
    where?: NeighbourhoodSubscriptionWhereInput
  ) => NeighbourhoodSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  paymentAccount: (
    where?: PaymentAccountSubscriptionWhereInput
  ) => PaymentAccountSubscriptionPayloadSubscription;
  paypalInformation: (
    where?: PaypalInformationSubscriptionWhereInput
  ) => PaypalInformationSubscriptionPayloadSubscription;
  paytmInformation: (
    where?: PaytmInformationSubscriptionWhereInput
  ) => PaytmInformationSubscriptionPayloadSubscription;
  picture: (
    where?: PictureSubscriptionWhereInput
  ) => PictureSubscriptionPayloadSubscription;
  policies: (
    where?: PoliciesSubscriptionWhereInput
  ) => PoliciesSubscriptionPayloadSubscription;
  pricing: (
    where?: PricingSubscriptionWhereInput
  ) => PricingSubscriptionPayloadSubscription;
  restaurant: (
    where?: RestaurantSubscriptionWhereInput
  ) => RestaurantSubscriptionPayloadSubscription;
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PaymentAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC";

export type DebitCardInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "cardNumber_ASC"
  | "cardNumber_DESC"
  | "expiresOnMonth_ASC"
  | "expiresOnMonth_DESC"
  | "expiresOnYear_ASC"
  | "expiresOnYear_DESC"
  | "securityCode_ASC"
  | "securityCode_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "postalCode_ASC"
  | "postalCode_DESC"
  | "country_ASC"
  | "country_DESC";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "responseRate_ASC"
  | "responseRate_DESC"
  | "responseTime_ASC"
  | "responseTime_DESC"
  | "accountType_ASC"
  | "accountType_DESC"
  | "uid_ASC"
  | "uid_DESC";

export type CityOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type PoliciesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "openingTime_ASC"
  | "openingTime_DESC"
  | "closingTime_ASC"
  | "closingTime_DESC";

export type PictureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "altText_ASC"
  | "altText_DESC"
  | "url_ASC"
  | "url_DESC";

export type PaypalInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC";

export type MenuItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC";

export type ExperienceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "pricePerPerson_ASC"
  | "pricePerPerson_DESC"
  | "popularity_ASC"
  | "popularity_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "serviceFee_ASC"
  | "serviceFee_DESC"
  | "restaurantPrice_ASC"
  | "restaurantPrice_DESC"
  | "totalPrice_ASC"
  | "totalPrice_DESC";

export type NeighbourhoodOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "featured_ASC"
  | "featured_DESC"
  | "popularity_ASC"
  | "popularity_DESC";

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "text_ASC"
  | "text_DESC"
  | "stars_ASC"
  | "stars_DESC"
  | "accuracy_ASC"
  | "accuracy_DESC"
  | "location_ASC"
  | "location_DESC"
  | "checkIn_ASC"
  | "checkIn_DESC"
  | "value_ASC"
  | "value_DESC"
  | "cleanliness_ASC"
  | "cleanliness_DESC"
  | "communication_ASC"
  | "communication_DESC";

export type LocationOrderByInput =
  | "title_ASC"
  | "title_DESC"
  | "id_ASC"
  | "id_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "address_ASC"
  | "address_DESC"
  | "directions_ASC"
  | "directions_DESC";

export type RestaurantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "description_ASC"
  | "description_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "maxGuests_ASC"
  | "maxGuests_DESC"
  | "numRatings_ASC"
  | "numRatings_DESC"
  | "avgRating_ASC"
  | "avgRating_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "avgPricePerPerson_ASC"
  | "avgPricePerPerson_DESC"
  | "isCurated_ASC"
  | "isCurated_DESC";

export type PricingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "monthlyDiscount_ASC"
  | "monthlyDiscount_DESC"
  | "weeklyDiscount_ASC"
  | "weeklyDiscount_DESC"
  | "price_ASC"
  | "price_DESC"
  | "smartPricing_ASC"
  | "smartPricing_DESC"
  | "basePrice_ASC"
  | "basePrice_DESC"
  | "averageWeekly_ASC"
  | "averageWeekly_DESC"
  | "averageMonthly_ASC"
  | "averageMonthly_DESC"
  | "weekendPricing_ASC"
  | "weekendPricing_DESC";

export type CreditCardInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "cardNumber_ASC"
  | "cardNumber_DESC"
  | "expiresOnMonth_ASC"
  | "expiresOnMonth_DESC"
  | "expiresOnYear_ASC"
  | "expiresOnYear_DESC"
  | "securityCode_ASC"
  | "securityCode_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "postalCode_ASC"
  | "postalCode_DESC"
  | "country_ASC"
  | "country_DESC";

export type PAYMENT_PROVIDER =
  | "PAYPAL"
  | "PAYTM"
  | "CREDIT_CARD"
  | "DEBIT_CARD";

export type NOTIFICATION_TYPE =
  | "OFFER"
  | "INSTANT_BOOK"
  | "RESPONSIVENESS"
  | "NEW_AMENITIES"
  | "HOUSE_RULES";

export type UserType = "ADMIN" | "SELLER" | "CONSUMER";

export type PaytmInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "phone_ASC"
  | "phone_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deliveredAt_ASC"
  | "deliveredAt_DESC"
  | "readAt_ASC"
  | "readAt_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "link_ASC"
  | "link_DESC"
  | "readDate_ASC"
  | "readDate_DESC";

export type ExperienceCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "mainColor_ASC"
  | "mainColor_DESC"
  | "name_ASC"
  | "name_DESC";

export interface ExperienceUpdateInput {
  category?: Maybe<ExperienceCategoryUpdateOneInput>;
  title?: Maybe<String>;
  host?: Maybe<UserUpdateOneRequiredWithoutExperiencesInput>;
  location?: Maybe<LocationUpdateOneRequiredInput>;
  pricePerPerson?: Maybe<Int>;
  reviews?: Maybe<ReviewUpdateManyWithoutExperienceInput>;
  preview?: Maybe<PictureUpdateOneRequiredInput>;
  popularity?: Maybe<Int>;
}

export type CityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LocationCreateInput {
  title?: Maybe<String>;
  id?: Maybe<ID_Input>;
  lat: Float;
  lng: Float;
  neighbourHood?: Maybe<NeighbourhoodCreateOneWithoutLocationsInput>;
  address: String;
  directions: String;
}

export interface MessageUpdateManyDataInput {
  deliveredAt?: Maybe<DateTimeInput>;
  readAt?: Maybe<DateTimeInput>;
}

export interface NeighbourhoodCreateOneWithoutLocationsInput {
  create?: Maybe<NeighbourhoodCreateWithoutLocationsInput>;
  connect?: Maybe<NeighbourhoodWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutOrdersInput {
  create?: Maybe<UserCreateWithoutOrdersInput>;
  update?: Maybe<UserUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<UserUpsertWithoutOrdersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface NeighbourhoodCreateWithoutLocationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  slug: String;
  homePreview?: Maybe<PictureCreateOneInput>;
  city: CityCreateOneWithoutNeighbourhoodsInput;
  featured: Boolean;
  popularity: Int;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface CityCreateOneWithoutNeighbourhoodsInput {
  create?: Maybe<CityCreateWithoutNeighbourhoodsInput>;
  connect?: Maybe<CityWhereUniqueInput>;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReviewWhereInput>;
  AND?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  OR?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  NOT?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
}

export interface CityCreateWithoutNeighbourhoodsInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface PricingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PricingWhereInput>;
  AND?: Maybe<PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput>;
  OR?: Maybe<PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput>;
  NOT?: Maybe<PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput>;
}

export interface PaymentAccountCreateManyWithoutUserInput {
  create?: Maybe<
    | PaymentAccountCreateWithoutUserInput[]
    | PaymentAccountCreateWithoutUserInput
  >;
  connect?: Maybe<
    PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput
  >;
}

export type ExperienceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PaymentAccountCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<PAYMENT_PROVIDER>;
  payments?: Maybe<PaymentCreateManyWithoutPaymentMethodInput>;
  paypal?: Maybe<PaypalInformationCreateOneInput>;
  paytm?: Maybe<PaytmInformationCreateOneInput>;
  creditcard?: Maybe<CreditCardInformationCreateOneInput>;
  debitcard?: Maybe<DebitCardInformationCreateOneInput>;
}

export interface PaytmInformationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaytmInformationWhereInput>;
  AND?: Maybe<
    | PaytmInformationSubscriptionWhereInput[]
    | PaytmInformationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PaytmInformationSubscriptionWhereInput[]
    | PaytmInformationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PaytmInformationSubscriptionWhereInput[]
    | PaytmInformationSubscriptionWhereInput
  >;
}

export interface PaymentCreateManyWithoutPaymentMethodInput {
  create?: Maybe<
    | PaymentCreateWithoutPaymentMethodInput[]
    | PaymentCreateWithoutPaymentMethodInput
  >;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
}

export interface RestaurantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  maxGuests_not?: Maybe<Int>;
  maxGuests_in?: Maybe<Int[] | Int>;
  maxGuests_not_in?: Maybe<Int[] | Int>;
  maxGuests_lt?: Maybe<Int>;
  maxGuests_lte?: Maybe<Int>;
  maxGuests_gt?: Maybe<Int>;
  maxGuests_gte?: Maybe<Int>;
  numRatings?: Maybe<Int>;
  numRatings_not?: Maybe<Int>;
  numRatings_in?: Maybe<Int[] | Int>;
  numRatings_not_in?: Maybe<Int[] | Int>;
  numRatings_lt?: Maybe<Int>;
  numRatings_lte?: Maybe<Int>;
  numRatings_gt?: Maybe<Int>;
  numRatings_gte?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  avgRating_not?: Maybe<Float>;
  avgRating_in?: Maybe<Float[] | Float>;
  avgRating_not_in?: Maybe<Float[] | Float>;
  avgRating_lt?: Maybe<Float>;
  avgRating_lte?: Maybe<Float>;
  avgRating_gt?: Maybe<Float>;
  avgRating_gte?: Maybe<Float>;
  reviews_every?: Maybe<ReviewWhereInput>;
  reviews_some?: Maybe<ReviewWhereInput>;
  reviews_none?: Maybe<ReviewWhereInput>;
  location?: Maybe<LocationWhereInput>;
  policies?: Maybe<PoliciesWhereInput>;
  menu_every?: Maybe<MenuItemWhereInput>;
  menu_some?: Maybe<MenuItemWhereInput>;
  menu_none?: Maybe<MenuItemWhereInput>;
  orders_every?: Maybe<OrderWhereInput>;
  orders_some?: Maybe<OrderWhereInput>;
  orders_none?: Maybe<OrderWhereInput>;
  pictures_every?: Maybe<PictureWhereInput>;
  pictures_some?: Maybe<PictureWhereInput>;
  pictures_none?: Maybe<PictureWhereInput>;
  popularity?: Maybe<Int>;
  popularity_not?: Maybe<Int>;
  popularity_in?: Maybe<Int[] | Int>;
  popularity_not_in?: Maybe<Int[] | Int>;
  popularity_lt?: Maybe<Int>;
  popularity_lte?: Maybe<Int>;
  popularity_gt?: Maybe<Int>;
  popularity_gte?: Maybe<Int>;
  avgPricePerPerson?: Maybe<Int>;
  avgPricePerPerson_not?: Maybe<Int>;
  avgPricePerPerson_in?: Maybe<Int[] | Int>;
  avgPricePerPerson_not_in?: Maybe<Int[] | Int>;
  avgPricePerPerson_lt?: Maybe<Int>;
  avgPricePerPerson_lte?: Maybe<Int>;
  avgPricePerPerson_gt?: Maybe<Int>;
  avgPricePerPerson_gte?: Maybe<Int>;
  isCurated?: Maybe<Boolean>;
  isCurated_not?: Maybe<Boolean>;
  AND?: Maybe<RestaurantWhereInput[] | RestaurantWhereInput>;
  OR?: Maybe<RestaurantWhereInput[] | RestaurantWhereInput>;
  NOT?: Maybe<RestaurantWhereInput[] | RestaurantWhereInput>;
}

export interface PaymentCreateWithoutPaymentMethodInput {
  id?: Maybe<ID_Input>;
  serviceFee: Float;
  restaurantPrice: Float;
  totalPrice: Float;
  order: OrderCreateOneWithoutPaymentInput;
}

export interface OrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  bookee?: Maybe<UserWhereInput>;
  restaurant?: Maybe<RestaurantWhereInput>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  payment?: Maybe<PaymentWhereInput>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export interface OrderCreateOneWithoutPaymentInput {
  create?: Maybe<OrderCreateWithoutPaymentInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface PaymentAccountWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<PAYMENT_PROVIDER>;
  type_not?: Maybe<PAYMENT_PROVIDER>;
  type_in?: Maybe<PAYMENT_PROVIDER[] | PAYMENT_PROVIDER>;
  type_not_in?: Maybe<PAYMENT_PROVIDER[] | PAYMENT_PROVIDER>;
  user?: Maybe<UserWhereInput>;
  payments_every?: Maybe<PaymentWhereInput>;
  payments_some?: Maybe<PaymentWhereInput>;
  payments_none?: Maybe<PaymentWhereInput>;
  paypal?: Maybe<PaypalInformationWhereInput>;
  paytm?: Maybe<PaytmInformationWhereInput>;
  creditcard?: Maybe<CreditCardInformationWhereInput>;
  debitcard?: Maybe<DebitCardInformationWhereInput>;
  AND?: Maybe<PaymentAccountWhereInput[] | PaymentAccountWhereInput>;
  OR?: Maybe<PaymentAccountWhereInput[] | PaymentAccountWhereInput>;
  NOT?: Maybe<PaymentAccountWhereInput[] | PaymentAccountWhereInput>;
}

export interface OrderCreateWithoutPaymentInput {
  id?: Maybe<ID_Input>;
  bookee: UserCreateOneWithoutOrdersInput;
  restaurant: RestaurantCreateOneWithoutOrdersInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
}

export interface PaymentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  serviceFee?: Maybe<Float>;
  serviceFee_not?: Maybe<Float>;
  serviceFee_in?: Maybe<Float[] | Float>;
  serviceFee_not_in?: Maybe<Float[] | Float>;
  serviceFee_lt?: Maybe<Float>;
  serviceFee_lte?: Maybe<Float>;
  serviceFee_gt?: Maybe<Float>;
  serviceFee_gte?: Maybe<Float>;
  restaurantPrice?: Maybe<Float>;
  restaurantPrice_not?: Maybe<Float>;
  restaurantPrice_in?: Maybe<Float[] | Float>;
  restaurantPrice_not_in?: Maybe<Float[] | Float>;
  restaurantPrice_lt?: Maybe<Float>;
  restaurantPrice_lte?: Maybe<Float>;
  restaurantPrice_gt?: Maybe<Float>;
  restaurantPrice_gte?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
  totalPrice_not?: Maybe<Float>;
  totalPrice_in?: Maybe<Float[] | Float>;
  totalPrice_not_in?: Maybe<Float[] | Float>;
  totalPrice_lt?: Maybe<Float>;
  totalPrice_lte?: Maybe<Float>;
  totalPrice_gt?: Maybe<Float>;
  totalPrice_gte?: Maybe<Float>;
  order?: Maybe<OrderWhereInput>;
  paymentMethod?: Maybe<PaymentAccountWhereInput>;
  AND?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  OR?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  NOT?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
}

export interface RestaurantCreateOneWithoutOrdersInput {
  create?: Maybe<RestaurantCreateWithoutOrdersInput>;
  connect?: Maybe<RestaurantWhereUniqueInput>;
}

export interface PaytmInformationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  AND?: Maybe<PaytmInformationWhereInput[] | PaytmInformationWhereInput>;
  OR?: Maybe<PaytmInformationWhereInput[] | PaytmInformationWhereInput>;
  NOT?: Maybe<PaytmInformationWhereInput[] | PaytmInformationWhereInput>;
}

export interface RestaurantCreateWithoutOrdersInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numRatings: Int;
  avgRating?: Maybe<Float>;
  reviews?: Maybe<ReviewCreateManyInput>;
  location?: Maybe<LocationCreateOneInput>;
  policies?: Maybe<PoliciesCreateOneInput>;
  menu?: Maybe<MenuItemCreateManyInput>;
  pictures?: Maybe<PictureCreateManyInput>;
  popularity: Int;
  avgPricePerPerson: Int;
  isCurated?: Maybe<Boolean>;
}

export interface NotificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<NOTIFICATION_TYPE>;
  type_not?: Maybe<NOTIFICATION_TYPE>;
  type_in?: Maybe<NOTIFICATION_TYPE[] | NOTIFICATION_TYPE>;
  type_not_in?: Maybe<NOTIFICATION_TYPE[] | NOTIFICATION_TYPE>;
  user?: Maybe<UserWhereInput>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  readDate?: Maybe<DateTimeInput>;
  readDate_not?: Maybe<DateTimeInput>;
  readDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readDate_lt?: Maybe<DateTimeInput>;
  readDate_lte?: Maybe<DateTimeInput>;
  readDate_gt?: Maybe<DateTimeInput>;
  readDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
  OR?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
  NOT?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
}

export interface LocationCreateOneInput {
  create?: Maybe<LocationCreateInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface ExperienceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  category?: Maybe<ExperienceCategoryWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  host?: Maybe<UserWhereInput>;
  location?: Maybe<LocationWhereInput>;
  pricePerPerson?: Maybe<Int>;
  pricePerPerson_not?: Maybe<Int>;
  pricePerPerson_in?: Maybe<Int[] | Int>;
  pricePerPerson_not_in?: Maybe<Int[] | Int>;
  pricePerPerson_lt?: Maybe<Int>;
  pricePerPerson_lte?: Maybe<Int>;
  pricePerPerson_gt?: Maybe<Int>;
  pricePerPerson_gte?: Maybe<Int>;
  reviews_every?: Maybe<ReviewWhereInput>;
  reviews_some?: Maybe<ReviewWhereInput>;
  reviews_none?: Maybe<ReviewWhereInput>;
  preview?: Maybe<PictureWhereInput>;
  popularity?: Maybe<Int>;
  popularity_not?: Maybe<Int>;
  popularity_in?: Maybe<Int[] | Int>;
  popularity_not_in?: Maybe<Int[] | Int>;
  popularity_lt?: Maybe<Int>;
  popularity_lte?: Maybe<Int>;
  popularity_gt?: Maybe<Int>;
  popularity_gte?: Maybe<Int>;
  AND?: Maybe<ExperienceWhereInput[] | ExperienceWhereInput>;
  OR?: Maybe<ExperienceWhereInput[] | ExperienceWhereInput>;
  NOT?: Maybe<ExperienceWhereInput[] | ExperienceWhereInput>;
}

export interface PoliciesCreateOneInput {
  create?: Maybe<PoliciesCreateInput>;
  connect?: Maybe<PoliciesWhereUniqueInput>;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaymentWhereInput>;
  AND?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  OR?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  NOT?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
}

export interface PoliciesCreateInput {
  id?: Maybe<ID_Input>;
  openingTime: Float;
  closingTime: Float;
}

export interface MenuItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  pricing?: Maybe<PricingWhereInput>;
  pictures_every?: Maybe<PictureWhereInput>;
  pictures_some?: Maybe<PictureWhereInput>;
  pictures_none?: Maybe<PictureWhereInput>;
  reviews_every?: Maybe<ReviewWhereInput>;
  reviews_some?: Maybe<ReviewWhereInput>;
  reviews_none?: Maybe<ReviewWhereInput>;
  AND?: Maybe<MenuItemWhereInput[] | MenuItemWhereInput>;
  OR?: Maybe<MenuItemWhereInput[] | MenuItemWhereInput>;
  NOT?: Maybe<MenuItemWhereInput[] | MenuItemWhereInput>;
}

export interface MenuItemCreateManyInput {
  create?: Maybe<MenuItemCreateInput[] | MenuItemCreateInput>;
  connect?: Maybe<MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput>;
}

export type CreditCardInformationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MenuItemCreateInput {
  id?: Maybe<ID_Input>;
  shortDescription: String;
  title: String;
  description: String;
  pricing: PricingCreateOneInput;
  pictures?: Maybe<PictureCreateManyInput>;
  reviews?: Maybe<ReviewCreateManyInput>;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NotificationWhereInput>;
  AND?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
}

export interface PricingCreateOneInput {
  create?: Maybe<PricingCreateInput>;
  connect?: Maybe<PricingWhereUniqueInput>;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MessageWhereInput>;
  AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  OR?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  NOT?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
}

export interface PricingCreateInput {
  id?: Maybe<ID_Input>;
  monthlyDiscount?: Maybe<Int>;
  weeklyDiscount?: Maybe<Int>;
  price: Int;
  smartPricing?: Maybe<Boolean>;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  weekendPricing?: Maybe<Int>;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LocationWhereInput>;
  AND?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
  OR?: Maybe<LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput>;
  NOT?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
}

export interface PictureCreateManyInput {
  create?: Maybe<PictureCreateInput[] | PictureCreateInput>;
  connect?: Maybe<PictureWhereUniqueInput[] | PictureWhereUniqueInput>;
}

export interface ExperienceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExperienceWhereInput>;
  AND?: Maybe<
    ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput
  >;
  OR?: Maybe<
    ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput
  >;
}

export interface PaypalInformationCreateOneInput {
  create?: Maybe<PaypalInformationCreateInput>;
  connect?: Maybe<PaypalInformationWhereUniqueInput>;
}

export interface CreditCardInformationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CreditCardInformationWhereInput>;
  AND?: Maybe<
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput
  >;
}

export interface PaypalInformationCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
}

export interface UserUpdateManyMutationInput {
  displayName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  accountType?: Maybe<UserType>;
  uid?: Maybe<String>;
}

export interface PaytmInformationCreateOneInput {
  create?: Maybe<PaytmInformationCreateInput>;
  connect?: Maybe<PaytmInformationWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  displayName: String;
  phoneNumber: String;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantCreateManyInput>;
  location?: Maybe<LocationCreateManyInput>;
  orders?: Maybe<OrderCreateManyWithoutBookeeInput>;
  paymentAccount?: Maybe<PaymentAccountCreateManyWithoutUserInput>;
  sentMessages?: Maybe<MessageCreateManyWithoutFromInput>;
  receivedMessages?: Maybe<MessageCreateManyWithoutToInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureCreateOneInput>;
  experiences?: Maybe<ExperienceCreateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid: String;
}

export interface PaytmInformationCreateInput {
  id?: Maybe<ID_Input>;
  phone: String;
}

export interface ReviewUpdateInput {
  text?: Maybe<String>;
  stars?: Maybe<Int>;
  accuracy?: Maybe<Int>;
  location?: Maybe<Int>;
  checkIn?: Maybe<Int>;
  value?: Maybe<Int>;
  cleanliness?: Maybe<Int>;
  communication?: Maybe<Int>;
  order?: Maybe<OrderUpdateOneRequiredInput>;
  experience?: Maybe<ExperienceUpdateOneWithoutReviewsInput>;
}

export interface CreditCardInformationCreateOneInput {
  create?: Maybe<CreditCardInformationCreateInput>;
  connect?: Maybe<CreditCardInformationWhereUniqueInput>;
}

export interface RestaurantUpdateInput {
  name?: Maybe<String>;
  shortDescription?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  numRatings?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  reviews?: Maybe<ReviewUpdateManyInput>;
  location?: Maybe<LocationUpdateOneInput>;
  policies?: Maybe<PoliciesUpdateOneInput>;
  menu?: Maybe<MenuItemUpdateManyInput>;
  orders?: Maybe<OrderUpdateManyWithoutRestaurantInput>;
  pictures?: Maybe<PictureUpdateManyInput>;
  popularity?: Maybe<Int>;
  avgPricePerPerson?: Maybe<Int>;
  isCurated?: Maybe<Boolean>;
}

export interface DebitCardInformationCreateOneInput {
  create?: Maybe<DebitCardInformationCreateInput>;
  connect?: Maybe<DebitCardInformationWhereUniqueInput>;
}

export interface PricingUpdateInput {
  monthlyDiscount?: Maybe<Int>;
  weeklyDiscount?: Maybe<Int>;
  price?: Maybe<Int>;
  smartPricing?: Maybe<Boolean>;
  basePrice?: Maybe<Int>;
  averageWeekly?: Maybe<Int>;
  averageMonthly?: Maybe<Int>;
  weekendPricing?: Maybe<Int>;
}

export interface MessageCreateManyWithoutFromInput {
  create?: Maybe<
    MessageCreateWithoutFromInput[] | MessageCreateWithoutFromInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface PoliciesUpdateInput {
  openingTime?: Maybe<Float>;
  closingTime?: Maybe<Float>;
}

export interface MessageCreateWithoutFromInput {
  id?: Maybe<ID_Input>;
  to: UserCreateOneWithoutReceivedMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface PictureUpdateInput {
  altText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface UserCreateOneWithoutReceivedMessagesInput {
  create?: Maybe<UserCreateWithoutReceivedMessagesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  neighbourhoods_every?: Maybe<NeighbourhoodWhereInput>;
  neighbourhoods_some?: Maybe<NeighbourhoodWhereInput>;
  neighbourhoods_none?: Maybe<NeighbourhoodWhereInput>;
  AND?: Maybe<CityWhereInput[] | CityWhereInput>;
  OR?: Maybe<CityWhereInput[] | CityWhereInput>;
  NOT?: Maybe<CityWhereInput[] | CityWhereInput>;
}

export interface UserCreateWithoutReceivedMessagesInput {
  id?: Maybe<ID_Input>;
  displayName: String;
  phoneNumber: String;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantCreateManyInput>;
  location?: Maybe<LocationCreateManyInput>;
  orders?: Maybe<OrderCreateManyWithoutBookeeInput>;
  paymentAccount?: Maybe<PaymentAccountCreateManyWithoutUserInput>;
  sentMessages?: Maybe<MessageCreateManyWithoutFromInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureCreateOneInput>;
  experiences?: Maybe<ExperienceCreateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid: String;
}

export interface PaytmInformationUpdateInput {
  phone?: Maybe<String>;
}

export interface OrderCreateManyWithoutBookeeInput {
  create?: Maybe<
    OrderCreateWithoutBookeeInput[] | OrderCreateWithoutBookeeInput
  >;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrderCreateWithoutBookeeInput {
  id?: Maybe<ID_Input>;
  restaurant: RestaurantCreateOneWithoutOrdersInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment: PaymentCreateOneWithoutOrderInput;
}

export interface PaymentAccountUpdateManyMutationInput {
  type?: Maybe<PAYMENT_PROVIDER>;
}

export interface PaymentCreateOneWithoutOrderInput {
  create?: Maybe<PaymentCreateWithoutOrderInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export type MenuItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PaymentCreateWithoutOrderInput {
  id?: Maybe<ID_Input>;
  serviceFee: Float;
  restaurantPrice: Float;
  totalPrice: Float;
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput;
}

export interface PaymentUpdateManyMutationInput {
  serviceFee?: Maybe<Float>;
  restaurantPrice?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
}

export interface PaymentAccountCreateOneWithoutPaymentsInput {
  create?: Maybe<PaymentAccountCreateWithoutPaymentsInput>;
  connect?: Maybe<PaymentAccountWhereUniqueInput>;
}

export type MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PaymentAccountCreateWithoutPaymentsInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<PAYMENT_PROVIDER>;
  user: UserCreateOneWithoutPaymentAccountInput;
  paypal?: Maybe<PaypalInformationCreateOneInput>;
  paytm?: Maybe<PaytmInformationCreateOneInput>;
  creditcard?: Maybe<CreditCardInformationCreateOneInput>;
  debitcard?: Maybe<DebitCardInformationCreateOneInput>;
}

export interface OrderUpdateManyMutationInput {
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
}

export interface UserCreateOneWithoutPaymentAccountInput {
  create?: Maybe<UserCreateWithoutPaymentAccountInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type NeighbourhoodWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreateWithoutPaymentAccountInput {
  id?: Maybe<ID_Input>;
  displayName: String;
  phoneNumber: String;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantCreateManyInput>;
  location?: Maybe<LocationCreateManyInput>;
  orders?: Maybe<OrderCreateManyWithoutBookeeInput>;
  sentMessages?: Maybe<MessageCreateManyWithoutFromInput>;
  receivedMessages?: Maybe<MessageCreateManyWithoutToInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureCreateOneInput>;
  experiences?: Maybe<ExperienceCreateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid: String;
}

export interface UserUpsertWithoutNotificationsInput {
  update: UserUpdateWithoutNotificationsDataInput;
  create: UserCreateWithoutNotificationsInput;
}

export interface MessageCreateManyWithoutToInput {
  create?: Maybe<MessageCreateWithoutToInput[] | MessageCreateWithoutToInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MessageCreateWithoutToInput {
  id?: Maybe<ID_Input>;
  from: UserCreateOneWithoutSentMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface NotificationUpdateInput {
  type?: Maybe<NOTIFICATION_TYPE>;
  user?: Maybe<UserUpdateOneRequiredWithoutNotificationsInput>;
  link?: Maybe<String>;
  readDate?: Maybe<DateTimeInput>;
}

export interface UserCreateOneWithoutSentMessagesInput {
  create?: Maybe<UserCreateWithoutSentMessagesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreateWithoutSentMessagesInput {
  id?: Maybe<ID_Input>;
  displayName: String;
  phoneNumber: String;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantCreateManyInput>;
  location?: Maybe<LocationCreateManyInput>;
  orders?: Maybe<OrderCreateManyWithoutBookeeInput>;
  paymentAccount?: Maybe<PaymentAccountCreateManyWithoutUserInput>;
  receivedMessages?: Maybe<MessageCreateManyWithoutToInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureCreateOneInput>;
  experiences?: Maybe<ExperienceCreateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid: String;
}

export interface NotificationCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<NOTIFICATION_TYPE>;
  user: UserCreateOneWithoutNotificationsInput;
  link: String;
  readDate: DateTimeInput;
}

export interface NotificationCreateManyWithoutUserInput {
  create?: Maybe<
    NotificationCreateWithoutUserInput[] | NotificationCreateWithoutUserInput
  >;
  connect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NotificationCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<NOTIFICATION_TYPE>;
  link: String;
  readDate: DateTimeInput;
}

export interface NeighbourhoodCreateInput {
  id?: Maybe<ID_Input>;
  locations?: Maybe<LocationCreateManyWithoutNeighbourHoodInput>;
  name: String;
  slug: String;
  homePreview?: Maybe<PictureCreateOneInput>;
  city: CityCreateOneWithoutNeighbourhoodsInput;
  featured: Boolean;
  popularity: Int;
}

export interface ExperienceCreateManyWithoutHostInput {
  create?: Maybe<
    ExperienceCreateWithoutHostInput[] | ExperienceCreateWithoutHostInput
  >;
  connect?: Maybe<ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput>;
}

export type PaymentAccountWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExperienceCreateWithoutHostInput {
  id?: Maybe<ID_Input>;
  category?: Maybe<ExperienceCategoryCreateOneInput>;
  title: String;
  location: LocationCreateOneInput;
  pricePerPerson: Int;
  reviews?: Maybe<ReviewCreateManyWithoutExperienceInput>;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface MessageCreateInput {
  id?: Maybe<ID_Input>;
  from: UserCreateOneWithoutSentMessagesInput;
  to: UserCreateOneWithoutReceivedMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface ReviewCreateManyWithoutExperienceInput {
  create?: Maybe<
    ReviewCreateWithoutExperienceInput[] | ReviewCreateWithoutExperienceInput
  >;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
}

export type PaypalInformationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ReviewCreateWithoutExperienceInput {
  id?: Maybe<ID_Input>;
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  order: OrderCreateOneInput;
}

export interface MenuItemUpdateInput {
  shortDescription?: Maybe<String>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  pricing?: Maybe<PricingUpdateOneRequiredInput>;
  pictures?: Maybe<PictureUpdateManyInput>;
  reviews?: Maybe<ReviewUpdateManyInput>;
}

export interface ExperienceCreateOneWithoutReviewsInput {
  create?: Maybe<ExperienceCreateWithoutReviewsInput>;
  connect?: Maybe<ExperienceWhereUniqueInput>;
}

export interface LocationUpdateInput {
  title?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  neighbourHood?: Maybe<NeighbourhoodUpdateOneWithoutLocationsInput>;
  address?: Maybe<String>;
  directions?: Maybe<String>;
}

export interface ExperienceCreateWithoutReviewsInput {
  id?: Maybe<ID_Input>;
  category?: Maybe<ExperienceCategoryCreateOneInput>;
  title: String;
  host: UserCreateOneWithoutExperiencesInput;
  location: LocationCreateOneInput;
  pricePerPerson: Int;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface ExperienceCategoryUpdateManyMutationInput {
  mainColor?: Maybe<String>;
  name?: Maybe<String>;
}

export interface OrderCreateManyWithoutRestaurantInput {
  create?: Maybe<
    OrderCreateWithoutRestaurantInput[] | OrderCreateWithoutRestaurantInput
  >;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export interface ExperienceUpdateManyMutationInput {
  title?: Maybe<String>;
  pricePerPerson?: Maybe<Int>;
  popularity?: Maybe<Int>;
}

export interface OrderCreateWithoutRestaurantInput {
  id?: Maybe<ID_Input>;
  bookee: UserCreateOneWithoutOrdersInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment: PaymentCreateOneWithoutOrderInput;
}

export type PictureWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PaymentAccountUpsertWithoutPaymentsInput {
  update: PaymentAccountUpdateWithoutPaymentsDataInput;
  create: PaymentAccountCreateWithoutPaymentsInput;
}

export interface RestaurantUpdateManyWithWhereNestedInput {
  where: RestaurantScalarWhereInput;
  data: RestaurantUpdateManyDataInput;
}

export interface ExperienceCategoryUpdateOneInput {
  create?: Maybe<ExperienceCategoryCreateInput>;
  update?: Maybe<ExperienceCategoryUpdateDataInput>;
  upsert?: Maybe<ExperienceCategoryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ExperienceCategoryWhereUniqueInput>;
}

export type PoliciesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExperienceCategoryUpdateDataInput {
  mainColor?: Maybe<String>;
  name?: Maybe<String>;
}

export interface RestaurantUpsertWithWhereUniqueNestedInput {
  where: RestaurantWhereUniqueInput;
  update: RestaurantUpdateDataInput;
  create: RestaurantCreateInput;
}

export interface ExperienceCategoryUpsertNestedInput {
  update: ExperienceCategoryUpdateDataInput;
  create: ExperienceCategoryCreateInput;
}

export interface OrderUpdateWithoutRestaurantDataInput {
  bookee?: Maybe<UserUpdateOneRequiredWithoutOrdersInput>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  payment?: Maybe<PaymentUpdateOneRequiredWithoutOrderInput>;
}

export interface UserUpdateOneRequiredWithoutExperiencesInput {
  create?: Maybe<UserCreateWithoutExperiencesInput>;
  update?: Maybe<UserUpdateWithoutExperiencesDataInput>;
  upsert?: Maybe<UserUpsertWithoutExperiencesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface NeighbourhoodWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  locations_every?: Maybe<LocationWhereInput>;
  locations_some?: Maybe<LocationWhereInput>;
  locations_none?: Maybe<LocationWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  homePreview?: Maybe<PictureWhereInput>;
  city?: Maybe<CityWhereInput>;
  featured?: Maybe<Boolean>;
  featured_not?: Maybe<Boolean>;
  popularity?: Maybe<Int>;
  popularity_not?: Maybe<Int>;
  popularity_in?: Maybe<Int[] | Int>;
  popularity_not_in?: Maybe<Int[] | Int>;
  popularity_lt?: Maybe<Int>;
  popularity_lte?: Maybe<Int>;
  popularity_gt?: Maybe<Int>;
  popularity_gte?: Maybe<Int>;
  AND?: Maybe<NeighbourhoodWhereInput[] | NeighbourhoodWhereInput>;
  OR?: Maybe<NeighbourhoodWhereInput[] | NeighbourhoodWhereInput>;
  NOT?: Maybe<NeighbourhoodWhereInput[] | NeighbourhoodWhereInput>;
}

export interface UserUpdateWithoutExperiencesDataInput {
  displayName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantUpdateManyInput>;
  location?: Maybe<LocationUpdateManyInput>;
  orders?: Maybe<OrderUpdateManyWithoutBookeeInput>;
  paymentAccount?: Maybe<PaymentAccountUpdateManyWithoutUserInput>;
  sentMessages?: Maybe<MessageUpdateManyWithoutFromInput>;
  receivedMessages?: Maybe<MessageUpdateManyWithoutToInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureUpdateOneInput>;
  accountType?: Maybe<UserType>;
  uid?: Maybe<String>;
}

export interface OrderUpdateManyWithoutRestaurantInput {
  create?: Maybe<
    OrderCreateWithoutRestaurantInput[] | OrderCreateWithoutRestaurantInput
  >;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueWithoutRestaurantInput[]
    | OrderUpdateWithWhereUniqueWithoutRestaurantInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueWithoutRestaurantInput[]
    | OrderUpsertWithWhereUniqueWithoutRestaurantInput
  >;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface RestaurantUpdateManyInput {
  create?: Maybe<RestaurantCreateInput[] | RestaurantCreateInput>;
  update?: Maybe<
    | RestaurantUpdateWithWhereUniqueNestedInput[]
    | RestaurantUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | RestaurantUpsertWithWhereUniqueNestedInput[]
    | RestaurantUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<RestaurantWhereUniqueInput[] | RestaurantWhereUniqueInput>;
  connect?: Maybe<RestaurantWhereUniqueInput[] | RestaurantWhereUniqueInput>;
  set?: Maybe<RestaurantWhereUniqueInput[] | RestaurantWhereUniqueInput>;
  disconnect?: Maybe<RestaurantWhereUniqueInput[] | RestaurantWhereUniqueInput>;
  deleteMany?: Maybe<RestaurantScalarWhereInput[] | RestaurantScalarWhereInput>;
  updateMany?: Maybe<
    | RestaurantUpdateManyWithWhereNestedInput[]
    | RestaurantUpdateManyWithWhereNestedInput
  >;
}

export type RestaurantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RestaurantUpdateWithWhereUniqueNestedInput {
  where: RestaurantWhereUniqueInput;
  data: RestaurantUpdateDataInput;
}

export interface ExperienceUpdateWithoutReviewsDataInput {
  category?: Maybe<ExperienceCategoryUpdateOneInput>;
  title?: Maybe<String>;
  host?: Maybe<UserUpdateOneRequiredWithoutExperiencesInput>;
  location?: Maybe<LocationUpdateOneRequiredInput>;
  pricePerPerson?: Maybe<Int>;
  preview?: Maybe<PictureUpdateOneRequiredInput>;
  popularity?: Maybe<Int>;
}

export interface RestaurantUpdateDataInput {
  name?: Maybe<String>;
  shortDescription?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  numRatings?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  reviews?: Maybe<ReviewUpdateManyInput>;
  location?: Maybe<LocationUpdateOneInput>;
  policies?: Maybe<PoliciesUpdateOneInput>;
  menu?: Maybe<MenuItemUpdateManyInput>;
  orders?: Maybe<OrderUpdateManyWithoutRestaurantInput>;
  pictures?: Maybe<PictureUpdateManyInput>;
  popularity?: Maybe<Int>;
  avgPricePerPerson?: Maybe<Int>;
  isCurated?: Maybe<Boolean>;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ReviewUpdateManyInput {
  create?: Maybe<ReviewCreateInput[] | ReviewCreateInput>;
  update?: Maybe<
    | ReviewUpdateWithWhereUniqueNestedInput[]
    | ReviewUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ReviewUpsertWithWhereUniqueNestedInput[]
    | ReviewUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  set?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  disconnect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  deleteMany?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  updateMany?: Maybe<
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput;
  create: UserCreateWithoutOrdersInput;
}

export interface ReviewUpdateWithWhereUniqueNestedInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  uid?: Maybe<String>;
}>;

export interface ReviewUpdateDataInput {
  text?: Maybe<String>;
  stars?: Maybe<Int>;
  accuracy?: Maybe<Int>;
  location?: Maybe<Int>;
  checkIn?: Maybe<Int>;
  value?: Maybe<Int>;
  cleanliness?: Maybe<Int>;
  communication?: Maybe<Int>;
  order?: Maybe<OrderUpdateOneRequiredInput>;
  experience?: Maybe<ExperienceUpdateOneWithoutReviewsInput>;
}

export interface OrderUpdateManyDataInput {
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
}

export interface OrderUpdateOneRequiredInput {
  create?: Maybe<OrderCreateInput>;
  update?: Maybe<OrderUpdateDataInput>;
  upsert?: Maybe<OrderUpsertNestedInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface OrderScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  OR?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  NOT?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
}

export interface OrderUpdateDataInput {
  bookee?: Maybe<UserUpdateOneRequiredWithoutOrdersInput>;
  restaurant?: Maybe<RestaurantUpdateOneRequiredWithoutOrdersInput>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  payment?: Maybe<PaymentUpdateOneRequiredWithoutOrderInput>;
}

export interface CityCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  neighbourhoods?: Maybe<NeighbourhoodCreateManyWithoutCityInput>;
}

export interface UserUpsertWithoutPaymentAccountInput {
  update: UserUpdateWithoutPaymentAccountDataInput;
  create: UserCreateWithoutPaymentAccountInput;
}

export interface NeighbourhoodCreateWithoutCityInput {
  id?: Maybe<ID_Input>;
  locations?: Maybe<LocationCreateManyWithoutNeighbourHoodInput>;
  name: String;
  slug: String;
  homePreview?: Maybe<PictureCreateOneInput>;
  featured: Boolean;
  popularity: Int;
}

export interface UserUpdateWithoutOrdersDataInput {
  displayName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantUpdateManyInput>;
  location?: Maybe<LocationUpdateManyInput>;
  paymentAccount?: Maybe<PaymentAccountUpdateManyWithoutUserInput>;
  sentMessages?: Maybe<MessageUpdateManyWithoutFromInput>;
  receivedMessages?: Maybe<MessageUpdateManyWithoutToInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureUpdateOneInput>;
  experiences?: Maybe<ExperienceUpdateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid?: Maybe<String>;
}

export interface LocationCreateWithoutNeighbourHoodInput {
  title?: Maybe<String>;
  id?: Maybe<ID_Input>;
  lat: Float;
  lng: Float;
  address: String;
  directions: String;
}

export interface LocationUpdateManyInput {
  create?: Maybe<LocationCreateInput[] | LocationCreateInput>;
  update?: Maybe<
    | LocationUpdateWithWhereUniqueNestedInput[]
    | LocationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | LocationUpsertWithWhereUniqueNestedInput[]
    | LocationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<LocationWhereUniqueInput[] | LocationWhereUniqueInput>;
  connect?: Maybe<LocationWhereUniqueInput[] | LocationWhereUniqueInput>;
  set?: Maybe<LocationWhereUniqueInput[] | LocationWhereUniqueInput>;
  disconnect?: Maybe<LocationWhereUniqueInput[] | LocationWhereUniqueInput>;
  deleteMany?: Maybe<LocationScalarWhereInput[] | LocationScalarWhereInput>;
  updateMany?: Maybe<
    | LocationUpdateManyWithWhereNestedInput[]
    | LocationUpdateManyWithWhereNestedInput
  >;
}

export interface PictureCreateInput {
  id?: Maybe<ID_Input>;
  altText?: Maybe<String>;
  url: String;
}

export interface LocationUpdateWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput;
  data: LocationUpdateDataInput;
}

export interface NeighbourhoodUpdateManyWithoutCityInput {
  create?: Maybe<
    NeighbourhoodCreateWithoutCityInput[] | NeighbourhoodCreateWithoutCityInput
  >;
  delete?: Maybe<
    NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput
  >;
  connect?: Maybe<
    NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput
  >;
  set?: Maybe<NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput>;
  disconnect?: Maybe<
    NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput
  >;
  update?: Maybe<
    | NeighbourhoodUpdateWithWhereUniqueWithoutCityInput[]
    | NeighbourhoodUpdateWithWhereUniqueWithoutCityInput
  >;
  upsert?: Maybe<
    | NeighbourhoodUpsertWithWhereUniqueWithoutCityInput[]
    | NeighbourhoodUpsertWithWhereUniqueWithoutCityInput
  >;
  deleteMany?: Maybe<
    NeighbourhoodScalarWhereInput[] | NeighbourhoodScalarWhereInput
  >;
  updateMany?: Maybe<
    | NeighbourhoodUpdateManyWithWhereNestedInput[]
    | NeighbourhoodUpdateManyWithWhereNestedInput
  >;
}

export interface LocationUpdateDataInput {
  title?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  neighbourHood?: Maybe<NeighbourhoodUpdateOneWithoutLocationsInput>;
  address?: Maybe<String>;
  directions?: Maybe<String>;
}

export interface NeighbourhoodUpdateWithoutCityDataInput {
  locations?: Maybe<LocationUpdateManyWithoutNeighbourHoodInput>;
  name?: Maybe<String>;
  slug?: Maybe<String>;
  homePreview?: Maybe<PictureUpdateOneInput>;
  featured?: Maybe<Boolean>;
  popularity?: Maybe<Int>;
}

export interface NeighbourhoodUpdateOneWithoutLocationsInput {
  create?: Maybe<NeighbourhoodCreateWithoutLocationsInput>;
  update?: Maybe<NeighbourhoodUpdateWithoutLocationsDataInput>;
  upsert?: Maybe<NeighbourhoodUpsertWithoutLocationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<NeighbourhoodWhereUniqueInput>;
}

export interface LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput {
  where: LocationWhereUniqueInput;
  data: LocationUpdateWithoutNeighbourHoodDataInput;
}

export interface NeighbourhoodUpdateWithoutLocationsDataInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  homePreview?: Maybe<PictureUpdateOneInput>;
  city?: Maybe<CityUpdateOneRequiredWithoutNeighbourhoodsInput>;
  featured?: Maybe<Boolean>;
  popularity?: Maybe<Int>;
}

export interface LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput {
  where: LocationWhereUniqueInput;
  update: LocationUpdateWithoutNeighbourHoodDataInput;
  create: LocationCreateWithoutNeighbourHoodInput;
}

export interface CityUpdateOneRequiredWithoutNeighbourhoodsInput {
  create?: Maybe<CityCreateWithoutNeighbourhoodsInput>;
  update?: Maybe<CityUpdateWithoutNeighbourhoodsDataInput>;
  upsert?: Maybe<CityUpsertWithoutNeighbourhoodsInput>;
  connect?: Maybe<CityWhereUniqueInput>;
}

export interface LocationUpdateManyWithWhereNestedInput {
  where: LocationScalarWhereInput;
  data: LocationUpdateManyDataInput;
}

export interface CityUpdateWithoutNeighbourhoodsDataInput {
  name?: Maybe<String>;
}

export interface PictureUpdateOneInput {
  create?: Maybe<PictureCreateInput>;
  update?: Maybe<PictureUpdateDataInput>;
  upsert?: Maybe<PictureUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PictureWhereUniqueInput>;
}

export interface CityUpsertWithoutNeighbourhoodsInput {
  update: CityUpdateWithoutNeighbourhoodsDataInput;
  create: CityCreateWithoutNeighbourhoodsInput;
}

export interface PictureUpsertNestedInput {
  update: PictureUpdateDataInput;
  create: PictureCreateInput;
}

export interface NeighbourhoodUpsertWithoutLocationsInput {
  update: NeighbourhoodUpdateWithoutLocationsDataInput;
  create: NeighbourhoodCreateWithoutLocationsInput;
}

export interface NeighbourhoodScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  featured?: Maybe<Boolean>;
  featured_not?: Maybe<Boolean>;
  popularity?: Maybe<Int>;
  popularity_not?: Maybe<Int>;
  popularity_in?: Maybe<Int[] | Int>;
  popularity_not_in?: Maybe<Int[] | Int>;
  popularity_lt?: Maybe<Int>;
  popularity_lte?: Maybe<Int>;
  popularity_gt?: Maybe<Int>;
  popularity_gte?: Maybe<Int>;
  AND?: Maybe<NeighbourhoodScalarWhereInput[] | NeighbourhoodScalarWhereInput>;
  OR?: Maybe<NeighbourhoodScalarWhereInput[] | NeighbourhoodScalarWhereInput>;
  NOT?: Maybe<NeighbourhoodScalarWhereInput[] | NeighbourhoodScalarWhereInput>;
}

export interface LocationUpsertWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput;
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface NeighbourhoodUpdateManyDataInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  featured?: Maybe<Boolean>;
  popularity?: Maybe<Int>;
}

export interface PaymentAccountUpdateManyWithoutUserInput {
  create?: Maybe<
    | PaymentAccountCreateWithoutUserInput[]
    | PaymentAccountCreateWithoutUserInput
  >;
  delete?: Maybe<
    PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput
  >;
  connect?: Maybe<
    PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput
  >;
  set?: Maybe<
    PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput
  >;
  disconnect?: Maybe<
    PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput
  >;
  update?: Maybe<
    | PaymentAccountUpdateWithWhereUniqueWithoutUserInput[]
    | PaymentAccountUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | PaymentAccountUpsertWithWhereUniqueWithoutUserInput[]
    | PaymentAccountUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    PaymentAccountScalarWhereInput[] | PaymentAccountScalarWhereInput
  >;
  updateMany?: Maybe<
    | PaymentAccountUpdateManyWithWhereNestedInput[]
    | PaymentAccountUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpsertWithWhereUniqueWithoutBookeeInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutBookeeDataInput;
  create: OrderCreateWithoutBookeeInput;
}

export interface PaymentAccountUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentAccountWhereUniqueInput;
  data: PaymentAccountUpdateWithoutUserDataInput;
}

export interface CreditCardInformationCreateInput {
  id?: Maybe<ID_Input>;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface PaymentAccountUpdateWithoutUserDataInput {
  type?: Maybe<PAYMENT_PROVIDER>;
  payments?: Maybe<PaymentUpdateManyWithoutPaymentMethodInput>;
  paypal?: Maybe<PaypalInformationUpdateOneInput>;
  paytm?: Maybe<PaytmInformationUpdateOneInput>;
  creditcard?: Maybe<CreditCardInformationUpdateOneInput>;
  debitcard?: Maybe<DebitCardInformationUpdateOneInput>;
}

export interface CreditCardInformationUpdateManyMutationInput {
  cardNumber?: Maybe<String>;
  expiresOnMonth?: Maybe<Int>;
  expiresOnYear?: Maybe<Int>;
  securityCode?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  postalCode?: Maybe<String>;
  country?: Maybe<String>;
}

export interface PaymentUpdateManyWithoutPaymentMethodInput {
  create?: Maybe<
    | PaymentCreateWithoutPaymentMethodInput[]
    | PaymentCreateWithoutPaymentMethodInput
  >;
  delete?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  set?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  disconnect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  update?: Maybe<
    | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput
  >;
  upsert?: Maybe<
    | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput
  >;
  deleteMany?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  updateMany?: Maybe<
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput
  >;
}

export interface DebitCardInformationUpdateInput {
  cardNumber?: Maybe<String>;
  expiresOnMonth?: Maybe<Int>;
  expiresOnYear?: Maybe<Int>;
  securityCode?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  postalCode?: Maybe<String>;
  country?: Maybe<String>;
}

export interface PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutPaymentMethodDataInput;
}

export interface ExperienceCreateInput {
  id?: Maybe<ID_Input>;
  category?: Maybe<ExperienceCategoryCreateOneInput>;
  title: String;
  host: UserCreateOneWithoutExperiencesInput;
  location: LocationCreateOneInput;
  pricePerPerson: Int;
  reviews?: Maybe<ReviewCreateManyWithoutExperienceInput>;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface PaymentUpdateWithoutPaymentMethodDataInput {
  serviceFee?: Maybe<Float>;
  restaurantPrice?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
  order?: Maybe<OrderUpdateOneRequiredWithoutPaymentInput>;
}

export interface ExperienceCategoryCreateInput {
  id?: Maybe<ID_Input>;
  mainColor?: Maybe<String>;
  name: String;
}

export interface OrderUpdateOneRequiredWithoutPaymentInput {
  create?: Maybe<OrderCreateWithoutPaymentInput>;
  update?: Maybe<OrderUpdateWithoutPaymentDataInput>;
  upsert?: Maybe<OrderUpsertWithoutPaymentInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface UserCreateWithoutExperiencesInput {
  id?: Maybe<ID_Input>;
  displayName: String;
  phoneNumber: String;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantCreateManyInput>;
  location?: Maybe<LocationCreateManyInput>;
  orders?: Maybe<OrderCreateManyWithoutBookeeInput>;
  paymentAccount?: Maybe<PaymentAccountCreateManyWithoutUserInput>;
  sentMessages?: Maybe<MessageCreateManyWithoutFromInput>;
  receivedMessages?: Maybe<MessageCreateManyWithoutToInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureCreateOneInput>;
  accountType?: Maybe<UserType>;
  uid: String;
}

export interface OrderUpdateWithoutPaymentDataInput {
  bookee?: Maybe<UserUpdateOneRequiredWithoutOrdersInput>;
  restaurant?: Maybe<RestaurantUpdateOneRequiredWithoutOrdersInput>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
}

export interface RestaurantCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numRatings: Int;
  avgRating?: Maybe<Float>;
  reviews?: Maybe<ReviewCreateManyInput>;
  location?: Maybe<LocationCreateOneInput>;
  policies?: Maybe<PoliciesCreateOneInput>;
  menu?: Maybe<MenuItemCreateManyInput>;
  orders?: Maybe<OrderCreateManyWithoutRestaurantInput>;
  pictures?: Maybe<PictureCreateManyInput>;
  popularity: Int;
  avgPricePerPerson: Int;
  isCurated?: Maybe<Boolean>;
}

export interface RestaurantUpdateOneRequiredWithoutOrdersInput {
  create?: Maybe<RestaurantCreateWithoutOrdersInput>;
  update?: Maybe<RestaurantUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<RestaurantUpsertWithoutOrdersInput>;
  connect?: Maybe<RestaurantWhereUniqueInput>;
}

export interface ReviewCreateInput {
  id?: Maybe<ID_Input>;
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  order: OrderCreateOneInput;
  experience?: Maybe<ExperienceCreateOneWithoutReviewsInput>;
}

export interface RestaurantUpdateWithoutOrdersDataInput {
  name?: Maybe<String>;
  shortDescription?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  numRatings?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  reviews?: Maybe<ReviewUpdateManyInput>;
  location?: Maybe<LocationUpdateOneInput>;
  policies?: Maybe<PoliciesUpdateOneInput>;
  menu?: Maybe<MenuItemUpdateManyInput>;
  pictures?: Maybe<PictureUpdateManyInput>;
  popularity?: Maybe<Int>;
  avgPricePerPerson?: Maybe<Int>;
  isCurated?: Maybe<Boolean>;
}

export interface OrderCreateInput {
  id?: Maybe<ID_Input>;
  bookee: UserCreateOneWithoutOrdersInput;
  restaurant: RestaurantCreateOneWithoutOrdersInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment: PaymentCreateOneWithoutOrderInput;
}

export interface LocationUpdateOneInput {
  create?: Maybe<LocationCreateInput>;
  update?: Maybe<LocationUpdateDataInput>;
  upsert?: Maybe<LocationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface UserCreateWithoutOrdersInput {
  id?: Maybe<ID_Input>;
  displayName: String;
  phoneNumber: String;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantCreateManyInput>;
  location?: Maybe<LocationCreateManyInput>;
  paymentAccount?: Maybe<PaymentAccountCreateManyWithoutUserInput>;
  sentMessages?: Maybe<MessageCreateManyWithoutFromInput>;
  receivedMessages?: Maybe<MessageCreateManyWithoutToInput>;
  notifications?: Maybe<NotificationCreateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureCreateOneInput>;
  experiences?: Maybe<ExperienceCreateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid: String;
}

export interface LocationUpsertNestedInput {
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export type DebitCardInformationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PoliciesUpdateOneInput {
  create?: Maybe<PoliciesCreateInput>;
  update?: Maybe<PoliciesUpdateDataInput>;
  upsert?: Maybe<PoliciesUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PoliciesWhereUniqueInput>;
}

export interface RestaurantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RestaurantWhereInput>;
  AND?: Maybe<
    RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput
  >;
  OR?: Maybe<
    RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput
  >;
}

export interface PoliciesUpdateDataInput {
  openingTime?: Maybe<Float>;
  closingTime?: Maybe<Float>;
}

export interface PictureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PictureWhereInput>;
  AND?: Maybe<PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput>;
  OR?: Maybe<PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput>;
  NOT?: Maybe<PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput>;
}

export interface PoliciesUpsertNestedInput {
  update: PoliciesUpdateDataInput;
  create: PoliciesCreateInput;
}

export interface ReviewWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  stars?: Maybe<Int>;
  stars_not?: Maybe<Int>;
  stars_in?: Maybe<Int[] | Int>;
  stars_not_in?: Maybe<Int[] | Int>;
  stars_lt?: Maybe<Int>;
  stars_lte?: Maybe<Int>;
  stars_gt?: Maybe<Int>;
  stars_gte?: Maybe<Int>;
  accuracy?: Maybe<Int>;
  accuracy_not?: Maybe<Int>;
  accuracy_in?: Maybe<Int[] | Int>;
  accuracy_not_in?: Maybe<Int[] | Int>;
  accuracy_lt?: Maybe<Int>;
  accuracy_lte?: Maybe<Int>;
  accuracy_gt?: Maybe<Int>;
  accuracy_gte?: Maybe<Int>;
  location?: Maybe<Int>;
  location_not?: Maybe<Int>;
  location_in?: Maybe<Int[] | Int>;
  location_not_in?: Maybe<Int[] | Int>;
  location_lt?: Maybe<Int>;
  location_lte?: Maybe<Int>;
  location_gt?: Maybe<Int>;
  location_gte?: Maybe<Int>;
  checkIn?: Maybe<Int>;
  checkIn_not?: Maybe<Int>;
  checkIn_in?: Maybe<Int[] | Int>;
  checkIn_not_in?: Maybe<Int[] | Int>;
  checkIn_lt?: Maybe<Int>;
  checkIn_lte?: Maybe<Int>;
  checkIn_gt?: Maybe<Int>;
  checkIn_gte?: Maybe<Int>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  cleanliness?: Maybe<Int>;
  cleanliness_not?: Maybe<Int>;
  cleanliness_in?: Maybe<Int[] | Int>;
  cleanliness_not_in?: Maybe<Int[] | Int>;
  cleanliness_lt?: Maybe<Int>;
  cleanliness_lte?: Maybe<Int>;
  cleanliness_gt?: Maybe<Int>;
  cleanliness_gte?: Maybe<Int>;
  communication?: Maybe<Int>;
  communication_not?: Maybe<Int>;
  communication_in?: Maybe<Int[] | Int>;
  communication_not_in?: Maybe<Int[] | Int>;
  communication_lt?: Maybe<Int>;
  communication_lte?: Maybe<Int>;
  communication_gt?: Maybe<Int>;
  communication_gte?: Maybe<Int>;
  order?: Maybe<OrderWhereInput>;
  experience?: Maybe<ExperienceWhereInput>;
  AND?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  OR?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  NOT?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
}

export interface MenuItemUpdateManyInput {
  create?: Maybe<MenuItemCreateInput[] | MenuItemCreateInput>;
  update?: Maybe<
    | MenuItemUpdateWithWhereUniqueNestedInput[]
    | MenuItemUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | MenuItemUpsertWithWhereUniqueNestedInput[]
    | MenuItemUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput>;
  connect?: Maybe<MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput>;
  set?: Maybe<MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput>;
  disconnect?: Maybe<MenuItemWhereUniqueInput[] | MenuItemWhereUniqueInput>;
  deleteMany?: Maybe<MenuItemScalarWhereInput[] | MenuItemScalarWhereInput>;
  updateMany?: Maybe<
    | MenuItemUpdateManyWithWhereNestedInput[]
    | MenuItemUpdateManyWithWhereNestedInput
  >;
}

export interface CreditCardInformationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  cardNumber?: Maybe<String>;
  cardNumber_not?: Maybe<String>;
  cardNumber_in?: Maybe<String[] | String>;
  cardNumber_not_in?: Maybe<String[] | String>;
  cardNumber_lt?: Maybe<String>;
  cardNumber_lte?: Maybe<String>;
  cardNumber_gt?: Maybe<String>;
  cardNumber_gte?: Maybe<String>;
  cardNumber_contains?: Maybe<String>;
  cardNumber_not_contains?: Maybe<String>;
  cardNumber_starts_with?: Maybe<String>;
  cardNumber_not_starts_with?: Maybe<String>;
  cardNumber_ends_with?: Maybe<String>;
  cardNumber_not_ends_with?: Maybe<String>;
  expiresOnMonth?: Maybe<Int>;
  expiresOnMonth_not?: Maybe<Int>;
  expiresOnMonth_in?: Maybe<Int[] | Int>;
  expiresOnMonth_not_in?: Maybe<Int[] | Int>;
  expiresOnMonth_lt?: Maybe<Int>;
  expiresOnMonth_lte?: Maybe<Int>;
  expiresOnMonth_gt?: Maybe<Int>;
  expiresOnMonth_gte?: Maybe<Int>;
  expiresOnYear?: Maybe<Int>;
  expiresOnYear_not?: Maybe<Int>;
  expiresOnYear_in?: Maybe<Int[] | Int>;
  expiresOnYear_not_in?: Maybe<Int[] | Int>;
  expiresOnYear_lt?: Maybe<Int>;
  expiresOnYear_lte?: Maybe<Int>;
  expiresOnYear_gt?: Maybe<Int>;
  expiresOnYear_gte?: Maybe<Int>;
  securityCode?: Maybe<String>;
  securityCode_not?: Maybe<String>;
  securityCode_in?: Maybe<String[] | String>;
  securityCode_not_in?: Maybe<String[] | String>;
  securityCode_lt?: Maybe<String>;
  securityCode_lte?: Maybe<String>;
  securityCode_gt?: Maybe<String>;
  securityCode_gte?: Maybe<String>;
  securityCode_contains?: Maybe<String>;
  securityCode_not_contains?: Maybe<String>;
  securityCode_starts_with?: Maybe<String>;
  securityCode_not_starts_with?: Maybe<String>;
  securityCode_ends_with?: Maybe<String>;
  securityCode_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  postalCode?: Maybe<String>;
  postalCode_not?: Maybe<String>;
  postalCode_in?: Maybe<String[] | String>;
  postalCode_not_in?: Maybe<String[] | String>;
  postalCode_lt?: Maybe<String>;
  postalCode_lte?: Maybe<String>;
  postalCode_gt?: Maybe<String>;
  postalCode_gte?: Maybe<String>;
  postalCode_contains?: Maybe<String>;
  postalCode_not_contains?: Maybe<String>;
  postalCode_starts_with?: Maybe<String>;
  postalCode_not_starts_with?: Maybe<String>;
  postalCode_ends_with?: Maybe<String>;
  postalCode_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    CreditCardInformationWhereInput[] | CreditCardInformationWhereInput
  >;
  OR?: Maybe<
    CreditCardInformationWhereInput[] | CreditCardInformationWhereInput
  >;
  NOT?: Maybe<
    CreditCardInformationWhereInput[] | CreditCardInformationWhereInput
  >;
}

export interface MenuItemUpdateWithWhereUniqueNestedInput {
  where: MenuItemWhereUniqueInput;
  data: MenuItemUpdateDataInput;
}

export interface MessageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  from?: Maybe<UserWhereInput>;
  to?: Maybe<UserWhereInput>;
  deliveredAt?: Maybe<DateTimeInput>;
  deliveredAt_not?: Maybe<DateTimeInput>;
  deliveredAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deliveredAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deliveredAt_lt?: Maybe<DateTimeInput>;
  deliveredAt_lte?: Maybe<DateTimeInput>;
  deliveredAt_gt?: Maybe<DateTimeInput>;
  deliveredAt_gte?: Maybe<DateTimeInput>;
  readAt?: Maybe<DateTimeInput>;
  readAt_not?: Maybe<DateTimeInput>;
  readAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readAt_lt?: Maybe<DateTimeInput>;
  readAt_lte?: Maybe<DateTimeInput>;
  readAt_gt?: Maybe<DateTimeInput>;
  readAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  OR?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  NOT?: Maybe<MessageWhereInput[] | MessageWhereInput>;
}

export interface MenuItemUpdateDataInput {
  shortDescription?: Maybe<String>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  pricing?: Maybe<PricingUpdateOneRequiredInput>;
  pictures?: Maybe<PictureUpdateManyInput>;
  reviews?: Maybe<ReviewUpdateManyInput>;
}

export interface ExperienceCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  mainColor?: Maybe<String>;
  mainColor_not?: Maybe<String>;
  mainColor_in?: Maybe<String[] | String>;
  mainColor_not_in?: Maybe<String[] | String>;
  mainColor_lt?: Maybe<String>;
  mainColor_lte?: Maybe<String>;
  mainColor_gt?: Maybe<String>;
  mainColor_gte?: Maybe<String>;
  mainColor_contains?: Maybe<String>;
  mainColor_not_contains?: Maybe<String>;
  mainColor_starts_with?: Maybe<String>;
  mainColor_not_starts_with?: Maybe<String>;
  mainColor_ends_with?: Maybe<String>;
  mainColor_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput>;
  OR?: Maybe<ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput>;
  NOT?: Maybe<ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput>;
}

export interface PricingUpdateOneRequiredInput {
  create?: Maybe<PricingCreateInput>;
  update?: Maybe<PricingUpdateDataInput>;
  upsert?: Maybe<PricingUpsertNestedInput>;
  connect?: Maybe<PricingWhereUniqueInput>;
}

export interface PricingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  monthlyDiscount?: Maybe<Int>;
  monthlyDiscount_not?: Maybe<Int>;
  monthlyDiscount_in?: Maybe<Int[] | Int>;
  monthlyDiscount_not_in?: Maybe<Int[] | Int>;
  monthlyDiscount_lt?: Maybe<Int>;
  monthlyDiscount_lte?: Maybe<Int>;
  monthlyDiscount_gt?: Maybe<Int>;
  monthlyDiscount_gte?: Maybe<Int>;
  weeklyDiscount?: Maybe<Int>;
  weeklyDiscount_not?: Maybe<Int>;
  weeklyDiscount_in?: Maybe<Int[] | Int>;
  weeklyDiscount_not_in?: Maybe<Int[] | Int>;
  weeklyDiscount_lt?: Maybe<Int>;
  weeklyDiscount_lte?: Maybe<Int>;
  weeklyDiscount_gt?: Maybe<Int>;
  weeklyDiscount_gte?: Maybe<Int>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  smartPricing?: Maybe<Boolean>;
  smartPricing_not?: Maybe<Boolean>;
  basePrice?: Maybe<Int>;
  basePrice_not?: Maybe<Int>;
  basePrice_in?: Maybe<Int[] | Int>;
  basePrice_not_in?: Maybe<Int[] | Int>;
  basePrice_lt?: Maybe<Int>;
  basePrice_lte?: Maybe<Int>;
  basePrice_gt?: Maybe<Int>;
  basePrice_gte?: Maybe<Int>;
  averageWeekly?: Maybe<Int>;
  averageWeekly_not?: Maybe<Int>;
  averageWeekly_in?: Maybe<Int[] | Int>;
  averageWeekly_not_in?: Maybe<Int[] | Int>;
  averageWeekly_lt?: Maybe<Int>;
  averageWeekly_lte?: Maybe<Int>;
  averageWeekly_gt?: Maybe<Int>;
  averageWeekly_gte?: Maybe<Int>;
  averageMonthly?: Maybe<Int>;
  averageMonthly_not?: Maybe<Int>;
  averageMonthly_in?: Maybe<Int[] | Int>;
  averageMonthly_not_in?: Maybe<Int[] | Int>;
  averageMonthly_lt?: Maybe<Int>;
  averageMonthly_lte?: Maybe<Int>;
  averageMonthly_gt?: Maybe<Int>;
  averageMonthly_gte?: Maybe<Int>;
  weekendPricing?: Maybe<Int>;
  weekendPricing_not?: Maybe<Int>;
  weekendPricing_in?: Maybe<Int[] | Int>;
  weekendPricing_not_in?: Maybe<Int[] | Int>;
  weekendPricing_lt?: Maybe<Int>;
  weekendPricing_lte?: Maybe<Int>;
  weekendPricing_gt?: Maybe<Int>;
  weekendPricing_gte?: Maybe<Int>;
  AND?: Maybe<PricingWhereInput[] | PricingWhereInput>;
  OR?: Maybe<PricingWhereInput[] | PricingWhereInput>;
  NOT?: Maybe<PricingWhereInput[] | PricingWhereInput>;
}

export interface PricingUpdateDataInput {
  monthlyDiscount?: Maybe<Int>;
  weeklyDiscount?: Maybe<Int>;
  price?: Maybe<Int>;
  smartPricing?: Maybe<Boolean>;
  basePrice?: Maybe<Int>;
  averageWeekly?: Maybe<Int>;
  averageMonthly?: Maybe<Int>;
  weekendPricing?: Maybe<Int>;
}

export interface NeighbourhoodSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NeighbourhoodWhereInput>;
  AND?: Maybe<
    NeighbourhoodSubscriptionWhereInput[] | NeighbourhoodSubscriptionWhereInput
  >;
  OR?: Maybe<
    NeighbourhoodSubscriptionWhereInput[] | NeighbourhoodSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NeighbourhoodSubscriptionWhereInput[] | NeighbourhoodSubscriptionWhereInput
  >;
}

export interface PricingUpsertNestedInput {
  update: PricingUpdateDataInput;
  create: PricingCreateInput;
}

export interface ExperienceCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExperienceCategoryWhereInput>;
  AND?: Maybe<
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput
  >;
}

export interface PictureUpdateManyInput {
  create?: Maybe<PictureCreateInput[] | PictureCreateInput>;
  update?: Maybe<
    | PictureUpdateWithWhereUniqueNestedInput[]
    | PictureUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PictureUpsertWithWhereUniqueNestedInput[]
    | PictureUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<PictureWhereUniqueInput[] | PictureWhereUniqueInput>;
  connect?: Maybe<PictureWhereUniqueInput[] | PictureWhereUniqueInput>;
  set?: Maybe<PictureWhereUniqueInput[] | PictureWhereUniqueInput>;
  disconnect?: Maybe<PictureWhereUniqueInput[] | PictureWhereUniqueInput>;
  deleteMany?: Maybe<PictureScalarWhereInput[] | PictureScalarWhereInput>;
  updateMany?: Maybe<
    | PictureUpdateManyWithWhereNestedInput[]
    | PictureUpdateManyWithWhereNestedInput
  >;
}

export interface CitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CityWhereInput>;
  AND?: Maybe<CitySubscriptionWhereInput[] | CitySubscriptionWhereInput>;
  OR?: Maybe<CitySubscriptionWhereInput[] | CitySubscriptionWhereInput>;
  NOT?: Maybe<CitySubscriptionWhereInput[] | CitySubscriptionWhereInput>;
}

export interface PictureUpdateWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput;
  data: PictureUpdateDataInput;
}

export interface ReviewUpdateManyMutationInput {
  text?: Maybe<String>;
  stars?: Maybe<Int>;
  accuracy?: Maybe<Int>;
  location?: Maybe<Int>;
  checkIn?: Maybe<Int>;
  value?: Maybe<Int>;
  cleanliness?: Maybe<Int>;
  communication?: Maybe<Int>;
}

export interface PictureUpsertWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput;
  update: PictureUpdateDataInput;
  create: PictureCreateInput;
}

export interface PricingUpdateManyMutationInput {
  monthlyDiscount?: Maybe<Int>;
  weeklyDiscount?: Maybe<Int>;
  price?: Maybe<Int>;
  smartPricing?: Maybe<Boolean>;
  basePrice?: Maybe<Int>;
  averageWeekly?: Maybe<Int>;
  averageMonthly?: Maybe<Int>;
  weekendPricing?: Maybe<Int>;
}

export interface PictureScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  altText?: Maybe<String>;
  altText_not?: Maybe<String>;
  altText_in?: Maybe<String[] | String>;
  altText_not_in?: Maybe<String[] | String>;
  altText_lt?: Maybe<String>;
  altText_lte?: Maybe<String>;
  altText_gt?: Maybe<String>;
  altText_gte?: Maybe<String>;
  altText_contains?: Maybe<String>;
  altText_not_contains?: Maybe<String>;
  altText_starts_with?: Maybe<String>;
  altText_not_starts_with?: Maybe<String>;
  altText_ends_with?: Maybe<String>;
  altText_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<PictureScalarWhereInput[] | PictureScalarWhereInput>;
  OR?: Maybe<PictureScalarWhereInput[] | PictureScalarWhereInput>;
  NOT?: Maybe<PictureScalarWhereInput[] | PictureScalarWhereInput>;
}

export interface PictureUpdateManyMutationInput {
  altText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface PictureUpdateManyWithWhereNestedInput {
  where: PictureScalarWhereInput;
  data: PictureUpdateManyDataInput;
}

export interface PaytmInformationUpdateManyMutationInput {
  phone?: Maybe<String>;
}

export interface PictureUpdateManyDataInput {
  altText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface PaypalInformationUpdateInput {
  email?: Maybe<String>;
}

export interface MenuItemUpsertWithWhereUniqueNestedInput {
  where: MenuItemWhereUniqueInput;
  update: MenuItemUpdateDataInput;
  create: MenuItemCreateInput;
}

export interface PaymentAccountCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<PAYMENT_PROVIDER>;
  user: UserCreateOneWithoutPaymentAccountInput;
  payments?: Maybe<PaymentCreateManyWithoutPaymentMethodInput>;
  paypal?: Maybe<PaypalInformationCreateOneInput>;
  paytm?: Maybe<PaytmInformationCreateOneInput>;
  creditcard?: Maybe<CreditCardInformationCreateOneInput>;
  debitcard?: Maybe<DebitCardInformationCreateOneInput>;
}

export interface MenuItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<MenuItemScalarWhereInput[] | MenuItemScalarWhereInput>;
  OR?: Maybe<MenuItemScalarWhereInput[] | MenuItemScalarWhereInput>;
  NOT?: Maybe<MenuItemScalarWhereInput[] | MenuItemScalarWhereInput>;
}

export interface PaymentCreateInput {
  id?: Maybe<ID_Input>;
  serviceFee: Float;
  restaurantPrice: Float;
  totalPrice: Float;
  order: OrderCreateOneWithoutPaymentInput;
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput;
}

export interface MenuItemUpdateManyWithWhereNestedInput {
  where: MenuItemScalarWhereInput;
  data: MenuItemUpdateManyDataInput;
}

export interface NotificationUpdateManyMutationInput {
  type?: Maybe<NOTIFICATION_TYPE>;
  link?: Maybe<String>;
  readDate?: Maybe<DateTimeInput>;
}

export interface MenuItemUpdateManyDataInput {
  shortDescription?: Maybe<String>;
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutNotificationsInput {
  create?: Maybe<UserCreateWithoutNotificationsInput>;
  update?: Maybe<UserUpdateWithoutNotificationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutNotificationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface RestaurantUpsertWithoutOrdersInput {
  update: RestaurantUpdateWithoutOrdersDataInput;
  create: RestaurantCreateWithoutOrdersInput;
}

export interface UserCreateOneWithoutNotificationsInput {
  create?: Maybe<UserCreateWithoutNotificationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface OrderUpsertWithoutPaymentInput {
  update: OrderUpdateWithoutPaymentDataInput;
  create: OrderCreateWithoutPaymentInput;
}

export interface NeighbourhoodUpdateInput {
  locations?: Maybe<LocationUpdateManyWithoutNeighbourHoodInput>;
  name?: Maybe<String>;
  slug?: Maybe<String>;
  homePreview?: Maybe<PictureUpdateOneInput>;
  city?: Maybe<CityUpdateOneRequiredWithoutNeighbourhoodsInput>;
  featured?: Maybe<Boolean>;
  popularity?: Maybe<Int>;
}

export interface PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutPaymentMethodDataInput;
  create: PaymentCreateWithoutPaymentMethodInput;
}

export interface MessageUpdateInput {
  from?: Maybe<UserUpdateOneRequiredWithoutSentMessagesInput>;
  to?: Maybe<UserUpdateOneRequiredWithoutReceivedMessagesInput>;
  deliveredAt?: Maybe<DateTimeInput>;
  readAt?: Maybe<DateTimeInput>;
}

export interface PaymentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  serviceFee?: Maybe<Float>;
  serviceFee_not?: Maybe<Float>;
  serviceFee_in?: Maybe<Float[] | Float>;
  serviceFee_not_in?: Maybe<Float[] | Float>;
  serviceFee_lt?: Maybe<Float>;
  serviceFee_lte?: Maybe<Float>;
  serviceFee_gt?: Maybe<Float>;
  serviceFee_gte?: Maybe<Float>;
  restaurantPrice?: Maybe<Float>;
  restaurantPrice_not?: Maybe<Float>;
  restaurantPrice_in?: Maybe<Float[] | Float>;
  restaurantPrice_not_in?: Maybe<Float[] | Float>;
  restaurantPrice_lt?: Maybe<Float>;
  restaurantPrice_lte?: Maybe<Float>;
  restaurantPrice_gt?: Maybe<Float>;
  restaurantPrice_gte?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
  totalPrice_not?: Maybe<Float>;
  totalPrice_in?: Maybe<Float[] | Float>;
  totalPrice_not_in?: Maybe<Float[] | Float>;
  totalPrice_lt?: Maybe<Float>;
  totalPrice_lte?: Maybe<Float>;
  totalPrice_gt?: Maybe<Float>;
  totalPrice_gte?: Maybe<Float>;
  AND?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  OR?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  NOT?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
}

export interface PictureWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  altText?: Maybe<String>;
  altText_not?: Maybe<String>;
  altText_in?: Maybe<String[] | String>;
  altText_not_in?: Maybe<String[] | String>;
  altText_lt?: Maybe<String>;
  altText_lte?: Maybe<String>;
  altText_gt?: Maybe<String>;
  altText_gte?: Maybe<String>;
  altText_contains?: Maybe<String>;
  altText_not_contains?: Maybe<String>;
  altText_starts_with?: Maybe<String>;
  altText_not_starts_with?: Maybe<String>;
  altText_ends_with?: Maybe<String>;
  altText_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<PictureWhereInput[] | PictureWhereInput>;
  OR?: Maybe<PictureWhereInput[] | PictureWhereInput>;
  NOT?: Maybe<PictureWhereInput[] | PictureWhereInput>;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export type PaytmInformationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PaymentUpdateManyDataInput {
  serviceFee?: Maybe<Float>;
  restaurantPrice?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
}

export interface UserUpsertWithoutExperiencesInput {
  update: UserUpdateWithoutExperiencesDataInput;
  create: UserCreateWithoutExperiencesInput;
}

export interface PaypalInformationUpdateOneInput {
  create?: Maybe<PaypalInformationCreateInput>;
  update?: Maybe<PaypalInformationUpdateDataInput>;
  upsert?: Maybe<PaypalInformationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PaypalInformationWhereUniqueInput>;
}

export interface RestaurantScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  maxGuests_not?: Maybe<Int>;
  maxGuests_in?: Maybe<Int[] | Int>;
  maxGuests_not_in?: Maybe<Int[] | Int>;
  maxGuests_lt?: Maybe<Int>;
  maxGuests_lte?: Maybe<Int>;
  maxGuests_gt?: Maybe<Int>;
  maxGuests_gte?: Maybe<Int>;
  numRatings?: Maybe<Int>;
  numRatings_not?: Maybe<Int>;
  numRatings_in?: Maybe<Int[] | Int>;
  numRatings_not_in?: Maybe<Int[] | Int>;
  numRatings_lt?: Maybe<Int>;
  numRatings_lte?: Maybe<Int>;
  numRatings_gt?: Maybe<Int>;
  numRatings_gte?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  avgRating_not?: Maybe<Float>;
  avgRating_in?: Maybe<Float[] | Float>;
  avgRating_not_in?: Maybe<Float[] | Float>;
  avgRating_lt?: Maybe<Float>;
  avgRating_lte?: Maybe<Float>;
  avgRating_gt?: Maybe<Float>;
  avgRating_gte?: Maybe<Float>;
  popularity?: Maybe<Int>;
  popularity_not?: Maybe<Int>;
  popularity_in?: Maybe<Int[] | Int>;
  popularity_not_in?: Maybe<Int[] | Int>;
  popularity_lt?: Maybe<Int>;
  popularity_lte?: Maybe<Int>;
  popularity_gt?: Maybe<Int>;
  popularity_gte?: Maybe<Int>;
  avgPricePerPerson?: Maybe<Int>;
  avgPricePerPerson_not?: Maybe<Int>;
  avgPricePerPerson_in?: Maybe<Int[] | Int>;
  avgPricePerPerson_not_in?: Maybe<Int[] | Int>;
  avgPricePerPerson_lt?: Maybe<Int>;
  avgPricePerPerson_lte?: Maybe<Int>;
  avgPricePerPerson_gt?: Maybe<Int>;
  avgPricePerPerson_gte?: Maybe<Int>;
  isCurated?: Maybe<Boolean>;
  isCurated_not?: Maybe<Boolean>;
  AND?: Maybe<RestaurantScalarWhereInput[] | RestaurantScalarWhereInput>;
  OR?: Maybe<RestaurantScalarWhereInput[] | RestaurantScalarWhereInput>;
  NOT?: Maybe<RestaurantScalarWhereInput[] | RestaurantScalarWhereInput>;
}

export interface PaypalInformationUpdateDataInput {
  email?: Maybe<String>;
}

export interface OrderUpsertWithWhereUniqueWithoutRestaurantInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutRestaurantDataInput;
  create: OrderCreateWithoutRestaurantInput;
}

export interface PaypalInformationUpsertNestedInput {
  update: PaypalInformationUpdateDataInput;
  create: PaypalInformationCreateInput;
}

export interface OrderUpdateWithWhereUniqueWithoutRestaurantInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutRestaurantDataInput;
}

export interface PaytmInformationUpdateOneInput {
  create?: Maybe<PaytmInformationCreateInput>;
  update?: Maybe<PaytmInformationUpdateDataInput>;
  upsert?: Maybe<PaytmInformationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PaytmInformationWhereUniqueInput>;
}

export interface ExperienceUpsertWithoutReviewsInput {
  update: ExperienceUpdateWithoutReviewsDataInput;
  create: ExperienceCreateWithoutReviewsInput;
}

export interface PaytmInformationUpdateDataInput {
  phone?: Maybe<String>;
}

export interface OrderUpsertNestedInput {
  update: OrderUpdateDataInput;
  create: OrderCreateInput;
}

export interface PaytmInformationUpsertNestedInput {
  update: PaytmInformationUpdateDataInput;
  create: PaytmInformationCreateInput;
}

export interface UserUpsertWithoutReceivedMessagesInput {
  update: UserUpdateWithoutReceivedMessagesDataInput;
  create: UserCreateWithoutReceivedMessagesInput;
}

export interface CreditCardInformationUpdateOneInput {
  create?: Maybe<CreditCardInformationCreateInput>;
  update?: Maybe<CreditCardInformationUpdateDataInput>;
  upsert?: Maybe<CreditCardInformationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CreditCardInformationWhereUniqueInput>;
}

export interface LocationCreateManyWithoutNeighbourHoodInput {
  create?: Maybe<
    | LocationCreateWithoutNeighbourHoodInput[]
    | LocationCreateWithoutNeighbourHoodInput
  >;
  connect?: Maybe<LocationWhereUniqueInput[] | LocationWhereUniqueInput>;
}

export interface CreditCardInformationUpdateDataInput {
  cardNumber?: Maybe<String>;
  expiresOnMonth?: Maybe<Int>;
  expiresOnYear?: Maybe<Int>;
  securityCode?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  postalCode?: Maybe<String>;
  country?: Maybe<String>;
}

export interface CityUpdateInput {
  name?: Maybe<String>;
  neighbourhoods?: Maybe<NeighbourhoodUpdateManyWithoutCityInput>;
}

export interface CreditCardInformationUpsertNestedInput {
  update: CreditCardInformationUpdateDataInput;
  create: CreditCardInformationCreateInput;
}

export interface LocationUpdateManyWithoutNeighbourHoodInput {
  create?: Maybe<
    | LocationCreateWithoutNeighbourHoodInput[]
    | LocationCreateWithoutNeighbourHoodInput
  >;
  delete?: Maybe<LocationWhereUniqueInput[] | LocationWhereUniqueInput>;
  connect?: Maybe<LocationWhereUniqueInput[] | LocationWhereUniqueInput>;
  set?: Maybe<LocationWhereUniqueInput[] | LocationWhereUniqueInput>;
  disconnect?: Maybe<LocationWhereUniqueInput[] | LocationWhereUniqueInput>;
  update?: Maybe<
    | LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput[]
    | LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput
  >;
  upsert?: Maybe<
    | LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput[]
    | LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput
  >;
  deleteMany?: Maybe<LocationScalarWhereInput[] | LocationScalarWhereInput>;
  updateMany?: Maybe<
    | LocationUpdateManyWithWhereNestedInput[]
    | LocationUpdateManyWithWhereNestedInput
  >;
}

export interface DebitCardInformationUpdateOneInput {
  create?: Maybe<DebitCardInformationCreateInput>;
  update?: Maybe<DebitCardInformationUpdateDataInput>;
  upsert?: Maybe<DebitCardInformationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DebitCardInformationWhereUniqueInput>;
}

export interface LocationScalarWhereInput {
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  directions?: Maybe<String>;
  directions_not?: Maybe<String>;
  directions_in?: Maybe<String[] | String>;
  directions_not_in?: Maybe<String[] | String>;
  directions_lt?: Maybe<String>;
  directions_lte?: Maybe<String>;
  directions_gt?: Maybe<String>;
  directions_gte?: Maybe<String>;
  directions_contains?: Maybe<String>;
  directions_not_contains?: Maybe<String>;
  directions_starts_with?: Maybe<String>;
  directions_not_starts_with?: Maybe<String>;
  directions_ends_with?: Maybe<String>;
  directions_not_ends_with?: Maybe<String>;
  AND?: Maybe<LocationScalarWhereInput[] | LocationScalarWhereInput>;
  OR?: Maybe<LocationScalarWhereInput[] | LocationScalarWhereInput>;
  NOT?: Maybe<LocationScalarWhereInput[] | LocationScalarWhereInput>;
}

export interface DebitCardInformationUpdateDataInput {
  cardNumber?: Maybe<String>;
  expiresOnMonth?: Maybe<Int>;
  expiresOnYear?: Maybe<Int>;
  securityCode?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  postalCode?: Maybe<String>;
  country?: Maybe<String>;
}

export interface PictureUpdateDataInput {
  altText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface DebitCardInformationUpsertNestedInput {
  update: DebitCardInformationUpdateDataInput;
  create: DebitCardInformationCreateInput;
}

export interface NeighbourhoodUpdateManyWithWhereNestedInput {
  where: NeighbourhoodScalarWhereInput;
  data: NeighbourhoodUpdateManyDataInput;
}

export interface PaymentAccountUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentAccountWhereUniqueInput;
  update: PaymentAccountUpdateWithoutUserDataInput;
  create: PaymentAccountCreateWithoutUserInput;
}

export interface PaymentUpsertWithoutOrderInput {
  update: PaymentUpdateWithoutOrderDataInput;
  create: PaymentCreateWithoutOrderInput;
}

export interface PaymentAccountScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<PAYMENT_PROVIDER>;
  type_not?: Maybe<PAYMENT_PROVIDER>;
  type_in?: Maybe<PAYMENT_PROVIDER[] | PAYMENT_PROVIDER>;
  type_not_in?: Maybe<PAYMENT_PROVIDER[] | PAYMENT_PROVIDER>;
  AND?: Maybe<
    PaymentAccountScalarWhereInput[] | PaymentAccountScalarWhereInput
  >;
  OR?: Maybe<PaymentAccountScalarWhereInput[] | PaymentAccountScalarWhereInput>;
  NOT?: Maybe<
    PaymentAccountScalarWhereInput[] | PaymentAccountScalarWhereInput
  >;
}

export interface DebitCardInformationCreateInput {
  id?: Maybe<ID_Input>;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface PaymentAccountUpdateManyWithWhereNestedInput {
  where: PaymentAccountScalarWhereInput;
  data: PaymentAccountUpdateManyDataInput;
}

export interface ExperienceCategoryCreateOneInput {
  create?: Maybe<ExperienceCategoryCreateInput>;
  connect?: Maybe<ExperienceCategoryWhereUniqueInput>;
}

export interface PaymentAccountUpdateManyDataInput {
  type?: Maybe<PAYMENT_PROVIDER>;
}

export interface RestaurantCreateManyInput {
  create?: Maybe<RestaurantCreateInput[] | RestaurantCreateInput>;
  connect?: Maybe<RestaurantWhereUniqueInput[] | RestaurantWhereUniqueInput>;
}

export interface MessageUpdateManyWithoutFromInput {
  create?: Maybe<
    MessageCreateWithoutFromInput[] | MessageCreateWithoutFromInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutFromInput[]
    | MessageUpdateWithWhereUniqueWithoutFromInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutFromInput[]
    | MessageUpsertWithWhereUniqueWithoutFromInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface OrderCreateOneInput {
  create?: Maybe<OrderCreateInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface MessageUpdateWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutFromDataInput;
}

export interface LocationCreateManyInput {
  create?: Maybe<LocationCreateInput[] | LocationCreateInput>;
  connect?: Maybe<LocationWhereUniqueInput[] | LocationWhereUniqueInput>;
}

export interface MessageUpdateWithoutFromDataInput {
  to?: Maybe<UserUpdateOneRequiredWithoutReceivedMessagesInput>;
  deliveredAt?: Maybe<DateTimeInput>;
  readAt?: Maybe<DateTimeInput>;
}

export interface PoliciesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PoliciesWhereInput>;
  AND?: Maybe<
    PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput
  >;
  OR?: Maybe<PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput>;
  NOT?: Maybe<
    PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput
  >;
}

export interface UserUpdateOneRequiredWithoutReceivedMessagesInput {
  create?: Maybe<UserCreateWithoutReceivedMessagesInput>;
  update?: Maybe<UserUpdateWithoutReceivedMessagesDataInput>;
  upsert?: Maybe<UserUpsertWithoutReceivedMessagesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  displayName?: Maybe<String>;
  displayName_not?: Maybe<String>;
  displayName_in?: Maybe<String[] | String>;
  displayName_not_in?: Maybe<String[] | String>;
  displayName_lt?: Maybe<String>;
  displayName_lte?: Maybe<String>;
  displayName_gt?: Maybe<String>;
  displayName_gte?: Maybe<String>;
  displayName_contains?: Maybe<String>;
  displayName_not_contains?: Maybe<String>;
  displayName_starts_with?: Maybe<String>;
  displayName_not_starts_with?: Maybe<String>;
  displayName_ends_with?: Maybe<String>;
  displayName_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  responseRate?: Maybe<Float>;
  responseRate_not?: Maybe<Float>;
  responseRate_in?: Maybe<Float[] | Float>;
  responseRate_not_in?: Maybe<Float[] | Float>;
  responseRate_lt?: Maybe<Float>;
  responseRate_lte?: Maybe<Float>;
  responseRate_gt?: Maybe<Float>;
  responseRate_gte?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  responseTime_not?: Maybe<Int>;
  responseTime_in?: Maybe<Int[] | Int>;
  responseTime_not_in?: Maybe<Int[] | Int>;
  responseTime_lt?: Maybe<Int>;
  responseTime_lte?: Maybe<Int>;
  responseTime_gt?: Maybe<Int>;
  responseTime_gte?: Maybe<Int>;
  ownedRestaurant_every?: Maybe<RestaurantWhereInput>;
  ownedRestaurant_some?: Maybe<RestaurantWhereInput>;
  ownedRestaurant_none?: Maybe<RestaurantWhereInput>;
  location_every?: Maybe<LocationWhereInput>;
  location_some?: Maybe<LocationWhereInput>;
  location_none?: Maybe<LocationWhereInput>;
  orders_every?: Maybe<OrderWhereInput>;
  orders_some?: Maybe<OrderWhereInput>;
  orders_none?: Maybe<OrderWhereInput>;
  paymentAccount_every?: Maybe<PaymentAccountWhereInput>;
  paymentAccount_some?: Maybe<PaymentAccountWhereInput>;
  paymentAccount_none?: Maybe<PaymentAccountWhereInput>;
  sentMessages_every?: Maybe<MessageWhereInput>;
  sentMessages_some?: Maybe<MessageWhereInput>;
  sentMessages_none?: Maybe<MessageWhereInput>;
  receivedMessages_every?: Maybe<MessageWhereInput>;
  receivedMessages_some?: Maybe<MessageWhereInput>;
  receivedMessages_none?: Maybe<MessageWhereInput>;
  notifications_every?: Maybe<NotificationWhereInput>;
  notifications_some?: Maybe<NotificationWhereInput>;
  notifications_none?: Maybe<NotificationWhereInput>;
  profilePicture?: Maybe<PictureWhereInput>;
  experiences_every?: Maybe<ExperienceWhereInput>;
  experiences_some?: Maybe<ExperienceWhereInput>;
  experiences_none?: Maybe<ExperienceWhereInput>;
  accountType?: Maybe<UserType>;
  accountType_not?: Maybe<UserType>;
  accountType_in?: Maybe<UserType[] | UserType>;
  accountType_not_in?: Maybe<UserType[] | UserType>;
  uid?: Maybe<String>;
  uid_not?: Maybe<String>;
  uid_in?: Maybe<String[] | String>;
  uid_not_in?: Maybe<String[] | String>;
  uid_lt?: Maybe<String>;
  uid_lte?: Maybe<String>;
  uid_gt?: Maybe<String>;
  uid_gte?: Maybe<String>;
  uid_contains?: Maybe<String>;
  uid_not_contains?: Maybe<String>;
  uid_starts_with?: Maybe<String>;
  uid_not_starts_with?: Maybe<String>;
  uid_ends_with?: Maybe<String>;
  uid_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface UserUpdateWithoutReceivedMessagesDataInput {
  displayName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantUpdateManyInput>;
  location?: Maybe<LocationUpdateManyInput>;
  orders?: Maybe<OrderUpdateManyWithoutBookeeInput>;
  paymentAccount?: Maybe<PaymentAccountUpdateManyWithoutUserInput>;
  sentMessages?: Maybe<MessageUpdateManyWithoutFromInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureUpdateOneInput>;
  experiences?: Maybe<ExperienceUpdateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid?: Maybe<String>;
}

export interface PaymentAccountSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaymentAccountWhereInput>;
  AND?: Maybe<
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput
  >;
}

export interface OrderUpdateManyWithoutBookeeInput {
  create?: Maybe<
    OrderCreateWithoutBookeeInput[] | OrderCreateWithoutBookeeInput
  >;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueWithoutBookeeInput[]
    | OrderUpdateWithWhereUniqueWithoutBookeeInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueWithoutBookeeInput[]
    | OrderUpsertWithWhereUniqueWithoutBookeeInput
  >;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface OrderUpdateWithWhereUniqueWithoutBookeeInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutBookeeDataInput;
}

export interface DebitCardInformationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DebitCardInformationWhereInput>;
  AND?: Maybe<
    | DebitCardInformationSubscriptionWhereInput[]
    | DebitCardInformationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | DebitCardInformationSubscriptionWhereInput[]
    | DebitCardInformationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | DebitCardInformationSubscriptionWhereInput[]
    | DebitCardInformationSubscriptionWhereInput
  >;
}

export interface OrderUpdateWithoutBookeeDataInput {
  restaurant?: Maybe<RestaurantUpdateOneRequiredWithoutOrdersInput>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  payment?: Maybe<PaymentUpdateOneRequiredWithoutOrderInput>;
}

export interface RestaurantUpdateManyMutationInput {
  name?: Maybe<String>;
  shortDescription?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  numRatings?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  popularity?: Maybe<Int>;
  avgPricePerPerson?: Maybe<Int>;
  isCurated?: Maybe<Boolean>;
}

export interface PaymentUpdateOneRequiredWithoutOrderInput {
  create?: Maybe<PaymentCreateWithoutOrderInput>;
  update?: Maybe<PaymentUpdateWithoutOrderDataInput>;
  upsert?: Maybe<PaymentUpsertWithoutOrderInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export type ExperienceCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PaymentUpdateWithoutOrderDataInput {
  serviceFee?: Maybe<Float>;
  restaurantPrice?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
  paymentMethod?: Maybe<PaymentAccountUpdateOneRequiredWithoutPaymentsInput>;
}

export interface PaymentAccountUpdateInput {
  type?: Maybe<PAYMENT_PROVIDER>;
  user?: Maybe<UserUpdateOneRequiredWithoutPaymentAccountInput>;
  payments?: Maybe<PaymentUpdateManyWithoutPaymentMethodInput>;
  paypal?: Maybe<PaypalInformationUpdateOneInput>;
  paytm?: Maybe<PaytmInformationUpdateOneInput>;
  creditcard?: Maybe<CreditCardInformationUpdateOneInput>;
  debitcard?: Maybe<DebitCardInformationUpdateOneInput>;
}

export interface PaymentAccountUpdateOneRequiredWithoutPaymentsInput {
  create?: Maybe<PaymentAccountCreateWithoutPaymentsInput>;
  update?: Maybe<PaymentAccountUpdateWithoutPaymentsDataInput>;
  upsert?: Maybe<PaymentAccountUpsertWithoutPaymentsInput>;
  connect?: Maybe<PaymentAccountWhereUniqueInput>;
}

export interface OrderUpdateInput {
  bookee?: Maybe<UserUpdateOneRequiredWithoutOrdersInput>;
  restaurant?: Maybe<RestaurantUpdateOneRequiredWithoutOrdersInput>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  payment?: Maybe<PaymentUpdateOneRequiredWithoutOrderInput>;
}

export interface PaymentAccountUpdateWithoutPaymentsDataInput {
  type?: Maybe<PAYMENT_PROVIDER>;
  user?: Maybe<UserUpdateOneRequiredWithoutPaymentAccountInput>;
  paypal?: Maybe<PaypalInformationUpdateOneInput>;
  paytm?: Maybe<PaytmInformationUpdateOneInput>;
  creditcard?: Maybe<CreditCardInformationUpdateOneInput>;
  debitcard?: Maybe<DebitCardInformationUpdateOneInput>;
}

export interface UserCreateWithoutNotificationsInput {
  id?: Maybe<ID_Input>;
  displayName: String;
  phoneNumber: String;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantCreateManyInput>;
  location?: Maybe<LocationCreateManyInput>;
  orders?: Maybe<OrderCreateManyWithoutBookeeInput>;
  paymentAccount?: Maybe<PaymentAccountCreateManyWithoutUserInput>;
  sentMessages?: Maybe<MessageCreateManyWithoutFromInput>;
  receivedMessages?: Maybe<MessageCreateManyWithoutToInput>;
  profilePicture?: Maybe<PictureCreateOneInput>;
  experiences?: Maybe<ExperienceCreateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid: String;
}

export interface UserUpdateOneRequiredWithoutPaymentAccountInput {
  create?: Maybe<UserCreateWithoutPaymentAccountInput>;
  update?: Maybe<UserUpdateWithoutPaymentAccountDataInput>;
  upsert?: Maybe<UserUpsertWithoutPaymentAccountInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface MessageUpdateManyMutationInput {
  deliveredAt?: Maybe<DateTimeInput>;
  readAt?: Maybe<DateTimeInput>;
}

export interface UserUpdateWithoutPaymentAccountDataInput {
  displayName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantUpdateManyInput>;
  location?: Maybe<LocationUpdateManyInput>;
  orders?: Maybe<OrderUpdateManyWithoutBookeeInput>;
  sentMessages?: Maybe<MessageUpdateManyWithoutFromInput>;
  receivedMessages?: Maybe<MessageUpdateManyWithoutToInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureUpdateOneInput>;
  experiences?: Maybe<ExperienceUpdateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid?: Maybe<String>;
}

export interface LocationUpdateManyMutationInput {
  title?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  address?: Maybe<String>;
  directions?: Maybe<String>;
}

export interface MessageUpdateManyWithoutToInput {
  create?: Maybe<MessageCreateWithoutToInput[] | MessageCreateWithoutToInput>;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutToInput[]
    | MessageUpdateWithWhereUniqueWithoutToInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutToInput[]
    | MessageUpsertWithWhereUniqueWithoutToInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface RestaurantUpdateManyDataInput {
  name?: Maybe<String>;
  shortDescription?: Maybe<String>;
  description?: Maybe<String>;
  slug?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  numRatings?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  popularity?: Maybe<Int>;
  avgPricePerPerson?: Maybe<Int>;
  isCurated?: Maybe<Boolean>;
}

export interface MessageUpdateWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutToDataInput;
}

export type PricingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MessageUpdateWithoutToDataInput {
  from?: Maybe<UserUpdateOneRequiredWithoutSentMessagesInput>;
  deliveredAt?: Maybe<DateTimeInput>;
  readAt?: Maybe<DateTimeInput>;
}

export interface ExperienceUpdateOneWithoutReviewsInput {
  create?: Maybe<ExperienceCreateWithoutReviewsInput>;
  update?: Maybe<ExperienceUpdateWithoutReviewsDataInput>;
  upsert?: Maybe<ExperienceUpsertWithoutReviewsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ExperienceWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutSentMessagesInput {
  create?: Maybe<UserCreateWithoutSentMessagesInput>;
  update?: Maybe<UserUpdateWithoutSentMessagesDataInput>;
  upsert?: Maybe<UserUpsertWithoutSentMessagesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface UserUpdateWithoutSentMessagesDataInput {
  displayName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantUpdateManyInput>;
  location?: Maybe<LocationUpdateManyInput>;
  orders?: Maybe<OrderUpdateManyWithoutBookeeInput>;
  paymentAccount?: Maybe<PaymentAccountUpdateManyWithoutUserInput>;
  receivedMessages?: Maybe<MessageUpdateManyWithoutToInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureUpdateOneInput>;
  experiences?: Maybe<ExperienceUpdateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid?: Maybe<String>;
}

export interface PictureCreateOneInput {
  create?: Maybe<PictureCreateInput>;
  connect?: Maybe<PictureWhereUniqueInput>;
}

export interface NotificationUpdateManyWithoutUserInput {
  create?: Maybe<
    NotificationCreateWithoutUserInput[] | NotificationCreateWithoutUserInput
  >;
  delete?: Maybe<NotificationWhereUniqueInput[] | NotificationWhereUniqueInput>;
  connect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
  set?: Maybe<NotificationWhereUniqueInput[] | NotificationWhereUniqueInput>;
  disconnect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
  update?: Maybe<
    | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    | NotificationUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    | NotificationUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    NotificationScalarWhereInput[] | NotificationScalarWhereInput
  >;
  updateMany?: Maybe<
    | NotificationUpdateManyWithWhereNestedInput[]
    | NotificationUpdateManyWithWhereNestedInput
  >;
}

export interface LocationUpdateWithoutNeighbourHoodDataInput {
  title?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  address?: Maybe<String>;
  directions?: Maybe<String>;
}

export interface NotificationUpdateWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateWithoutUserDataInput;
}

export interface NeighbourhoodUpsertWithWhereUniqueWithoutCityInput {
  where: NeighbourhoodWhereUniqueInput;
  update: NeighbourhoodUpdateWithoutCityDataInput;
  create: NeighbourhoodCreateWithoutCityInput;
}

export interface NotificationUpdateWithoutUserDataInput {
  type?: Maybe<NOTIFICATION_TYPE>;
  link?: Maybe<String>;
  readDate?: Maybe<DateTimeInput>;
}

export interface CreditCardInformationUpdateInput {
  cardNumber?: Maybe<String>;
  expiresOnMonth?: Maybe<Int>;
  expiresOnYear?: Maybe<Int>;
  securityCode?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  postalCode?: Maybe<String>;
  country?: Maybe<String>;
}

export interface NotificationUpsertWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateWithoutUserDataInput;
  create: NotificationCreateWithoutUserInput;
}

export interface UserCreateOneWithoutExperiencesInput {
  create?: Maybe<UserCreateWithoutExperiencesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface NotificationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<NOTIFICATION_TYPE>;
  type_not?: Maybe<NOTIFICATION_TYPE>;
  type_in?: Maybe<NOTIFICATION_TYPE[] | NOTIFICATION_TYPE>;
  type_not_in?: Maybe<NOTIFICATION_TYPE[] | NOTIFICATION_TYPE>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  readDate?: Maybe<DateTimeInput>;
  readDate_not?: Maybe<DateTimeInput>;
  readDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readDate_lt?: Maybe<DateTimeInput>;
  readDate_lte?: Maybe<DateTimeInput>;
  readDate_gt?: Maybe<DateTimeInput>;
  readDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
  OR?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
  NOT?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
}

export interface UserCreateOneWithoutOrdersInput {
  create?: Maybe<UserCreateWithoutOrdersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput;
  data: NotificationUpdateManyDataInput;
}

export interface PaypalInformationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaypalInformationWhereInput>;
  AND?: Maybe<
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput
  >;
}

export interface NotificationUpdateManyDataInput {
  type?: Maybe<NOTIFICATION_TYPE>;
  link?: Maybe<String>;
  readDate?: Maybe<DateTimeInput>;
}

export interface PoliciesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  openingTime?: Maybe<Float>;
  openingTime_not?: Maybe<Float>;
  openingTime_in?: Maybe<Float[] | Float>;
  openingTime_not_in?: Maybe<Float[] | Float>;
  openingTime_lt?: Maybe<Float>;
  openingTime_lte?: Maybe<Float>;
  openingTime_gt?: Maybe<Float>;
  openingTime_gte?: Maybe<Float>;
  closingTime?: Maybe<Float>;
  closingTime_not?: Maybe<Float>;
  closingTime_in?: Maybe<Float[] | Float>;
  closingTime_not_in?: Maybe<Float[] | Float>;
  closingTime_lt?: Maybe<Float>;
  closingTime_lte?: Maybe<Float>;
  closingTime_gt?: Maybe<Float>;
  closingTime_gte?: Maybe<Float>;
  AND?: Maybe<PoliciesWhereInput[] | PoliciesWhereInput>;
  OR?: Maybe<PoliciesWhereInput[] | PoliciesWhereInput>;
  NOT?: Maybe<PoliciesWhereInput[] | PoliciesWhereInput>;
}

export interface ExperienceUpdateManyWithoutHostInput {
  create?: Maybe<
    ExperienceCreateWithoutHostInput[] | ExperienceCreateWithoutHostInput
  >;
  delete?: Maybe<ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput>;
  connect?: Maybe<ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput>;
  set?: Maybe<ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput>;
  disconnect?: Maybe<ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput>;
  update?: Maybe<
    | ExperienceUpdateWithWhereUniqueWithoutHostInput[]
    | ExperienceUpdateWithWhereUniqueWithoutHostInput
  >;
  upsert?: Maybe<
    | ExperienceUpsertWithWhereUniqueWithoutHostInput[]
    | ExperienceUpsertWithWhereUniqueWithoutHostInput
  >;
  deleteMany?: Maybe<ExperienceScalarWhereInput[] | ExperienceScalarWhereInput>;
  updateMany?: Maybe<
    | ExperienceUpdateManyWithWhereNestedInput[]
    | ExperienceUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateInput {
  displayName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantUpdateManyInput>;
  location?: Maybe<LocationUpdateManyInput>;
  orders?: Maybe<OrderUpdateManyWithoutBookeeInput>;
  paymentAccount?: Maybe<PaymentAccountUpdateManyWithoutUserInput>;
  sentMessages?: Maybe<MessageUpdateManyWithoutFromInput>;
  receivedMessages?: Maybe<MessageUpdateManyWithoutToInput>;
  notifications?: Maybe<NotificationUpdateManyWithoutUserInput>;
  profilePicture?: Maybe<PictureUpdateOneInput>;
  experiences?: Maybe<ExperienceUpdateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid?: Maybe<String>;
}

export interface ExperienceUpdateWithWhereUniqueWithoutHostInput {
  where: ExperienceWhereUniqueInput;
  data: ExperienceUpdateWithoutHostDataInput;
}

export interface PaypalInformationUpdateManyMutationInput {
  email?: Maybe<String>;
}

export interface ExperienceUpdateWithoutHostDataInput {
  category?: Maybe<ExperienceCategoryUpdateOneInput>;
  title?: Maybe<String>;
  location?: Maybe<LocationUpdateOneRequiredInput>;
  pricePerPerson?: Maybe<Int>;
  reviews?: Maybe<ReviewUpdateManyWithoutExperienceInput>;
  preview?: Maybe<PictureUpdateOneRequiredInput>;
  popularity?: Maybe<Int>;
}

export interface UserUpdateWithoutNotificationsDataInput {
  displayName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  responseRate?: Maybe<Float>;
  responseTime?: Maybe<Int>;
  ownedRestaurant?: Maybe<RestaurantUpdateManyInput>;
  location?: Maybe<LocationUpdateManyInput>;
  orders?: Maybe<OrderUpdateManyWithoutBookeeInput>;
  paymentAccount?: Maybe<PaymentAccountUpdateManyWithoutUserInput>;
  sentMessages?: Maybe<MessageUpdateManyWithoutFromInput>;
  receivedMessages?: Maybe<MessageUpdateManyWithoutToInput>;
  profilePicture?: Maybe<PictureUpdateOneInput>;
  experiences?: Maybe<ExperienceUpdateManyWithoutHostInput>;
  accountType?: Maybe<UserType>;
  uid?: Maybe<String>;
}

export interface LocationUpdateOneRequiredInput {
  create?: Maybe<LocationCreateInput>;
  update?: Maybe<LocationUpdateDataInput>;
  upsert?: Maybe<LocationUpsertNestedInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface MenuItemUpdateManyMutationInput {
  shortDescription?: Maybe<String>;
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ReviewUpdateManyWithoutExperienceInput {
  create?: Maybe<
    ReviewCreateWithoutExperienceInput[] | ReviewCreateWithoutExperienceInput
  >;
  delete?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  set?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  disconnect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  update?: Maybe<
    | ReviewUpdateWithWhereUniqueWithoutExperienceInput[]
    | ReviewUpdateWithWhereUniqueWithoutExperienceInput
  >;
  upsert?: Maybe<
    | ReviewUpsertWithWhereUniqueWithoutExperienceInput[]
    | ReviewUpsertWithWhereUniqueWithoutExperienceInput
  >;
  deleteMany?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  updateMany?: Maybe<
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput
  >;
}

export interface LocationWhereInput {
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  neighbourHood?: Maybe<NeighbourhoodWhereInput>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  directions?: Maybe<String>;
  directions_not?: Maybe<String>;
  directions_in?: Maybe<String[] | String>;
  directions_not_in?: Maybe<String[] | String>;
  directions_lt?: Maybe<String>;
  directions_lte?: Maybe<String>;
  directions_gt?: Maybe<String>;
  directions_gte?: Maybe<String>;
  directions_contains?: Maybe<String>;
  directions_not_contains?: Maybe<String>;
  directions_starts_with?: Maybe<String>;
  directions_not_starts_with?: Maybe<String>;
  directions_ends_with?: Maybe<String>;
  directions_not_ends_with?: Maybe<String>;
  AND?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  OR?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  NOT?: Maybe<LocationWhereInput[] | LocationWhereInput>;
}

export interface ReviewUpdateWithWhereUniqueWithoutExperienceInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutExperienceDataInput;
}

export interface MessageUpsertWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutFromDataInput;
  create: MessageCreateWithoutFromInput;
}

export interface ReviewUpdateWithoutExperienceDataInput {
  text?: Maybe<String>;
  stars?: Maybe<Int>;
  accuracy?: Maybe<Int>;
  location?: Maybe<Int>;
  checkIn?: Maybe<Int>;
  value?: Maybe<Int>;
  cleanliness?: Maybe<Int>;
  communication?: Maybe<Int>;
  order?: Maybe<OrderUpdateOneRequiredInput>;
}

export interface NeighbourhoodUpdateWithWhereUniqueWithoutCityInput {
  where: NeighbourhoodWhereUniqueInput;
  data: NeighbourhoodUpdateWithoutCityDataInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutExperienceInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutExperienceDataInput;
  create: ReviewCreateWithoutExperienceInput;
}

export interface CityUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ReviewScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  stars?: Maybe<Int>;
  stars_not?: Maybe<Int>;
  stars_in?: Maybe<Int[] | Int>;
  stars_not_in?: Maybe<Int[] | Int>;
  stars_lt?: Maybe<Int>;
  stars_lte?: Maybe<Int>;
  stars_gt?: Maybe<Int>;
  stars_gte?: Maybe<Int>;
  accuracy?: Maybe<Int>;
  accuracy_not?: Maybe<Int>;
  accuracy_in?: Maybe<Int[] | Int>;
  accuracy_not_in?: Maybe<Int[] | Int>;
  accuracy_lt?: Maybe<Int>;
  accuracy_lte?: Maybe<Int>;
  accuracy_gt?: Maybe<Int>;
  accuracy_gte?: Maybe<Int>;
  location?: Maybe<Int>;
  location_not?: Maybe<Int>;
  location_in?: Maybe<Int[] | Int>;
  location_not_in?: Maybe<Int[] | Int>;
  location_lt?: Maybe<Int>;
  location_lte?: Maybe<Int>;
  location_gt?: Maybe<Int>;
  location_gte?: Maybe<Int>;
  checkIn?: Maybe<Int>;
  checkIn_not?: Maybe<Int>;
  checkIn_in?: Maybe<Int[] | Int>;
  checkIn_not_in?: Maybe<Int[] | Int>;
  checkIn_lt?: Maybe<Int>;
  checkIn_lte?: Maybe<Int>;
  checkIn_gt?: Maybe<Int>;
  checkIn_gte?: Maybe<Int>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  cleanliness?: Maybe<Int>;
  cleanliness_not?: Maybe<Int>;
  cleanliness_in?: Maybe<Int[] | Int>;
  cleanliness_not_in?: Maybe<Int[] | Int>;
  cleanliness_lt?: Maybe<Int>;
  cleanliness_lte?: Maybe<Int>;
  cleanliness_gt?: Maybe<Int>;
  cleanliness_gte?: Maybe<Int>;
  communication?: Maybe<Int>;
  communication_not?: Maybe<Int>;
  communication_in?: Maybe<Int[] | Int>;
  communication_not_in?: Maybe<Int[] | Int>;
  communication_lt?: Maybe<Int>;
  communication_lte?: Maybe<Int>;
  communication_gt?: Maybe<Int>;
  communication_gte?: Maybe<Int>;
  AND?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  OR?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  NOT?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
}

export interface ReviewCreateManyInput {
  create?: Maybe<ReviewCreateInput[] | ReviewCreateInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
}

export interface ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput;
  data: ReviewUpdateManyDataInput;
}

export interface PaypalInformationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  AND?: Maybe<PaypalInformationWhereInput[] | PaypalInformationWhereInput>;
  OR?: Maybe<PaypalInformationWhereInput[] | PaypalInformationWhereInput>;
  NOT?: Maybe<PaypalInformationWhereInput[] | PaypalInformationWhereInput>;
}

export interface ReviewUpdateManyDataInput {
  text?: Maybe<String>;
  stars?: Maybe<Int>;
  accuracy?: Maybe<Int>;
  location?: Maybe<Int>;
  checkIn?: Maybe<Int>;
  value?: Maybe<Int>;
  cleanliness?: Maybe<Int>;
  communication?: Maybe<Int>;
}

export interface PoliciesUpdateManyMutationInput {
  openingTime?: Maybe<Float>;
  closingTime?: Maybe<Float>;
}

export interface PictureUpdateOneRequiredInput {
  create?: Maybe<PictureCreateInput>;
  update?: Maybe<PictureUpdateDataInput>;
  upsert?: Maybe<PictureUpsertNestedInput>;
  connect?: Maybe<PictureWhereUniqueInput>;
}

export interface NeighbourhoodUpdateManyMutationInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  featured?: Maybe<Boolean>;
  popularity?: Maybe<Int>;
}

export interface ExperienceUpsertWithWhereUniqueWithoutHostInput {
  where: ExperienceWhereUniqueInput;
  update: ExperienceUpdateWithoutHostDataInput;
  create: ExperienceCreateWithoutHostInput;
}

export interface ReviewUpsertWithWhereUniqueNestedInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateDataInput;
  create: ReviewCreateInput;
}

export interface ExperienceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  pricePerPerson?: Maybe<Int>;
  pricePerPerson_not?: Maybe<Int>;
  pricePerPerson_in?: Maybe<Int[] | Int>;
  pricePerPerson_not_in?: Maybe<Int[] | Int>;
  pricePerPerson_lt?: Maybe<Int>;
  pricePerPerson_lte?: Maybe<Int>;
  pricePerPerson_gt?: Maybe<Int>;
  pricePerPerson_gte?: Maybe<Int>;
  popularity?: Maybe<Int>;
  popularity_not?: Maybe<Int>;
  popularity_in?: Maybe<Int[] | Int>;
  popularity_not_in?: Maybe<Int[] | Int>;
  popularity_lt?: Maybe<Int>;
  popularity_lte?: Maybe<Int>;
  popularity_gt?: Maybe<Int>;
  popularity_gte?: Maybe<Int>;
  AND?: Maybe<ExperienceScalarWhereInput[] | ExperienceScalarWhereInput>;
  OR?: Maybe<ExperienceScalarWhereInput[] | ExperienceScalarWhereInput>;
  NOT?: Maybe<ExperienceScalarWhereInput[] | ExperienceScalarWhereInput>;
}

export interface LocationUpdateManyDataInput {
  title?: Maybe<String>;
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  address?: Maybe<String>;
  directions?: Maybe<String>;
}

export interface ExperienceUpdateManyWithWhereNestedInput {
  where: ExperienceScalarWhereInput;
  data: ExperienceUpdateManyDataInput;
}

export interface DebitCardInformationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  cardNumber?: Maybe<String>;
  cardNumber_not?: Maybe<String>;
  cardNumber_in?: Maybe<String[] | String>;
  cardNumber_not_in?: Maybe<String[] | String>;
  cardNumber_lt?: Maybe<String>;
  cardNumber_lte?: Maybe<String>;
  cardNumber_gt?: Maybe<String>;
  cardNumber_gte?: Maybe<String>;
  cardNumber_contains?: Maybe<String>;
  cardNumber_not_contains?: Maybe<String>;
  cardNumber_starts_with?: Maybe<String>;
  cardNumber_not_starts_with?: Maybe<String>;
  cardNumber_ends_with?: Maybe<String>;
  cardNumber_not_ends_with?: Maybe<String>;
  expiresOnMonth?: Maybe<Int>;
  expiresOnMonth_not?: Maybe<Int>;
  expiresOnMonth_in?: Maybe<Int[] | Int>;
  expiresOnMonth_not_in?: Maybe<Int[] | Int>;
  expiresOnMonth_lt?: Maybe<Int>;
  expiresOnMonth_lte?: Maybe<Int>;
  expiresOnMonth_gt?: Maybe<Int>;
  expiresOnMonth_gte?: Maybe<Int>;
  expiresOnYear?: Maybe<Int>;
  expiresOnYear_not?: Maybe<Int>;
  expiresOnYear_in?: Maybe<Int[] | Int>;
  expiresOnYear_not_in?: Maybe<Int[] | Int>;
  expiresOnYear_lt?: Maybe<Int>;
  expiresOnYear_lte?: Maybe<Int>;
  expiresOnYear_gt?: Maybe<Int>;
  expiresOnYear_gte?: Maybe<Int>;
  securityCode?: Maybe<String>;
  securityCode_not?: Maybe<String>;
  securityCode_in?: Maybe<String[] | String>;
  securityCode_not_in?: Maybe<String[] | String>;
  securityCode_lt?: Maybe<String>;
  securityCode_lte?: Maybe<String>;
  securityCode_gt?: Maybe<String>;
  securityCode_gte?: Maybe<String>;
  securityCode_contains?: Maybe<String>;
  securityCode_not_contains?: Maybe<String>;
  securityCode_starts_with?: Maybe<String>;
  securityCode_not_starts_with?: Maybe<String>;
  securityCode_ends_with?: Maybe<String>;
  securityCode_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  postalCode?: Maybe<String>;
  postalCode_not?: Maybe<String>;
  postalCode_in?: Maybe<String[] | String>;
  postalCode_not_in?: Maybe<String[] | String>;
  postalCode_lt?: Maybe<String>;
  postalCode_lte?: Maybe<String>;
  postalCode_gt?: Maybe<String>;
  postalCode_gte?: Maybe<String>;
  postalCode_contains?: Maybe<String>;
  postalCode_not_contains?: Maybe<String>;
  postalCode_starts_with?: Maybe<String>;
  postalCode_not_starts_with?: Maybe<String>;
  postalCode_ends_with?: Maybe<String>;
  postalCode_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    DebitCardInformationWhereInput[] | DebitCardInformationWhereInput
  >;
  OR?: Maybe<DebitCardInformationWhereInput[] | DebitCardInformationWhereInput>;
  NOT?: Maybe<
    DebitCardInformationWhereInput[] | DebitCardInformationWhereInput
  >;
}

export interface ExperienceUpdateManyDataInput {
  title?: Maybe<String>;
  pricePerPerson?: Maybe<Int>;
  popularity?: Maybe<Int>;
}

export interface PaymentUpdateInput {
  serviceFee?: Maybe<Float>;
  restaurantPrice?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
  order?: Maybe<OrderUpdateOneRequiredWithoutPaymentInput>;
  paymentMethod?: Maybe<PaymentAccountUpdateOneRequiredWithoutPaymentsInput>;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface MessageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deliveredAt?: Maybe<DateTimeInput>;
  deliveredAt_not?: Maybe<DateTimeInput>;
  deliveredAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deliveredAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deliveredAt_lt?: Maybe<DateTimeInput>;
  deliveredAt_lte?: Maybe<DateTimeInput>;
  deliveredAt_gt?: Maybe<DateTimeInput>;
  deliveredAt_gte?: Maybe<DateTimeInput>;
  readAt?: Maybe<DateTimeInput>;
  readAt_not?: Maybe<DateTimeInput>;
  readAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  readAt_lt?: Maybe<DateTimeInput>;
  readAt_lte?: Maybe<DateTimeInput>;
  readAt_gt?: Maybe<DateTimeInput>;
  readAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  OR?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  NOT?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
}

export interface MessageUpsertWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutToDataInput;
  create: MessageCreateWithoutToInput;
}

export interface UserUpsertWithoutSentMessagesInput {
  update: UserUpdateWithoutSentMessagesDataInput;
  create: UserCreateWithoutSentMessagesInput;
}

export interface ExperienceCategoryUpdateInput {
  mainColor?: Maybe<String>;
  name?: Maybe<String>;
}

export interface MenuItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MenuItemWhereInput>;
  AND?: Maybe<
    MenuItemSubscriptionWhereInput[] | MenuItemSubscriptionWhereInput
  >;
  OR?: Maybe<MenuItemSubscriptionWhereInput[] | MenuItemSubscriptionWhereInput>;
  NOT?: Maybe<
    MenuItemSubscriptionWhereInput[] | MenuItemSubscriptionWhereInput
  >;
}

export interface DebitCardInformationUpdateManyMutationInput {
  cardNumber?: Maybe<String>;
  expiresOnMonth?: Maybe<Int>;
  expiresOnYear?: Maybe<Int>;
  securityCode?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  postalCode?: Maybe<String>;
  country?: Maybe<String>;
}

export interface NeighbourhoodCreateManyWithoutCityInput {
  create?: Maybe<
    NeighbourhoodCreateWithoutCityInput[] | NeighbourhoodCreateWithoutCityInput
  >;
  connect?: Maybe<
    NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  displayName: String;
  phoneNumber: String;
  responseRate?: Float;
  responseTime?: Int;
  accountType?: UserType;
  uid: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  displayName: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  responseRate: () => Promise<Float>;
  responseTime: () => Promise<Int>;
  accountType: () => Promise<UserType>;
  uid: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  displayName: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  responseRate: () => Promise<AsyncIterator<Float>>;
  responseTime: () => Promise<AsyncIterator<Int>>;
  accountType: () => Promise<AsyncIterator<UserType>>;
  uid: () => Promise<AsyncIterator<String>>;
}

export interface CityConnection {
  pageInfo: PageInfo;
  edges: CityEdge[];
}

export interface CityConnectionPromise
  extends Promise<CityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CityEdge>>() => T;
  aggregate: <T = AggregateCityPromise>() => T;
}

export interface CityConnectionSubscription
  extends Promise<AsyncIterator<CityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCitySubscription>() => T;
}

export interface CreditCardInformationEdge {
  node: CreditCardInformation;
  cursor: String;
}

export interface CreditCardInformationEdgePromise
  extends Promise<CreditCardInformationEdge>,
    Fragmentable {
  node: <T = CreditCardInformationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CreditCardInformationEdgeSubscription
  extends Promise<AsyncIterator<CreditCardInformationEdge>>,
    Fragmentable {
  node: <T = CreditCardInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Pricing {
  id: ID_Output;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  price: Int;
  smartPricing: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  weekendPricing?: Int;
}

export interface PricingPromise extends Promise<Pricing>, Fragmentable {
  id: () => Promise<ID_Output>;
  monthlyDiscount: () => Promise<Int>;
  weeklyDiscount: () => Promise<Int>;
  price: () => Promise<Int>;
  smartPricing: () => Promise<Boolean>;
  basePrice: () => Promise<Int>;
  averageWeekly: () => Promise<Int>;
  averageMonthly: () => Promise<Int>;
  weekendPricing: () => Promise<Int>;
}

export interface PricingSubscription
  extends Promise<AsyncIterator<Pricing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  monthlyDiscount: () => Promise<AsyncIterator<Int>>;
  weeklyDiscount: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Int>>;
  smartPricing: () => Promise<AsyncIterator<Boolean>>;
  basePrice: () => Promise<AsyncIterator<Int>>;
  averageWeekly: () => Promise<AsyncIterator<Int>>;
  averageMonthly: () => Promise<AsyncIterator<Int>>;
  weekendPricing: () => Promise<AsyncIterator<Int>>;
}

export interface PricingNullablePromise
  extends Promise<Pricing | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  monthlyDiscount: () => Promise<Int>;
  weeklyDiscount: () => Promise<Int>;
  price: () => Promise<Int>;
  smartPricing: () => Promise<Boolean>;
  basePrice: () => Promise<Int>;
  averageWeekly: () => Promise<Int>;
  averageMonthly: () => Promise<Int>;
  weekendPricing: () => Promise<Int>;
}

export interface AggregateCreditCardInformation {
  count: Int;
}

export interface AggregateCreditCardInformationPromise
  extends Promise<AggregateCreditCardInformation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCreditCardInformationSubscription
  extends Promise<AsyncIterator<AggregateCreditCardInformation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MenuItem {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  shortDescription: String;
  title: String;
  description: String;
}

export interface MenuItemPromise extends Promise<MenuItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  shortDescription: () => Promise<String>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  pricing: <T = PricingPromise>() => T;
  pictures: <T = FragmentableArray<Picture>>(args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MenuItemSubscription
  extends Promise<AsyncIterator<MenuItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  pricing: <T = PricingSubscription>() => T;
  pictures: <T = Promise<AsyncIterator<PictureSubscription>>>(args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MenuItemNullablePromise
  extends Promise<MenuItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  shortDescription: () => Promise<String>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  pricing: <T = PricingPromise>() => T;
  pictures: <T = FragmentableArray<Picture>>(args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface City {
  id: ID_Output;
  name: String;
}

export interface CityPromise extends Promise<City>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  neighbourhoods: <T = FragmentableArray<Neighbourhood>>(args?: {
    where?: NeighbourhoodWhereInput;
    orderBy?: NeighbourhoodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CitySubscription
  extends Promise<AsyncIterator<City>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  neighbourhoods: <
    T = Promise<AsyncIterator<NeighbourhoodSubscription>>
  >(args?: {
    where?: NeighbourhoodWhereInput;
    orderBy?: NeighbourhoodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CityNullablePromise
  extends Promise<City | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  neighbourhoods: <T = FragmentableArray<Neighbourhood>>(args?: {
    where?: NeighbourhoodWhereInput;
    orderBy?: NeighbourhoodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateReview {
  count: Int;
}

export interface AggregateReviewPromise
  extends Promise<AggregateReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CitySubscriptionPayload {
  mutation: MutationType;
  node: City;
  updatedFields: String[];
  previousValues: CityPreviousValues;
}

export interface CitySubscriptionPayloadPromise
  extends Promise<CitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CityPreviousValuesPromise>() => T;
}

export interface CitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CityPreviousValuesSubscription>() => T;
}

export interface ReviewConnection {
  pageInfo: PageInfo;
  edges: ReviewEdge[];
}

export interface ReviewConnectionPromise
  extends Promise<ReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewEdge>>() => T;
  aggregate: <T = AggregateReviewPromise>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface CityPreviousValues {
  id: ID_Output;
  name: String;
}

export interface CityPreviousValuesPromise
  extends Promise<CityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CityPreviousValuesSubscription
  extends Promise<AsyncIterator<CityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RestaurantEdge {
  node: Restaurant;
  cursor: String;
}

export interface RestaurantEdgePromise
  extends Promise<RestaurantEdge>,
    Fragmentable {
  node: <T = RestaurantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RestaurantEdgeSubscription
  extends Promise<AsyncIterator<RestaurantEdge>>,
    Fragmentable {
  node: <T = RestaurantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Policies {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  openingTime: Float;
  closingTime: Float;
}

export interface PoliciesPromise extends Promise<Policies>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  openingTime: () => Promise<Float>;
  closingTime: () => Promise<Float>;
}

export interface PoliciesSubscription
  extends Promise<AsyncIterator<Policies>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  openingTime: () => Promise<AsyncIterator<Float>>;
  closingTime: () => Promise<AsyncIterator<Float>>;
}

export interface PoliciesNullablePromise
  extends Promise<Policies | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  openingTime: () => Promise<Float>;
  closingTime: () => Promise<Float>;
}

export interface AggregatePricing {
  count: Int;
}

export interface AggregatePricingPromise
  extends Promise<AggregatePricing>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePricingSubscription
  extends Promise<AsyncIterator<AggregatePricing>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CreditCardInformationSubscriptionPayload {
  mutation: MutationType;
  node: CreditCardInformation;
  updatedFields: String[];
  previousValues: CreditCardInformationPreviousValues;
}

export interface CreditCardInformationSubscriptionPayloadPromise
  extends Promise<CreditCardInformationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CreditCardInformationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CreditCardInformationPreviousValuesPromise>() => T;
}

export interface CreditCardInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CreditCardInformationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CreditCardInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CreditCardInformationPreviousValuesSubscription>() => T;
}

export interface PricingConnection {
  pageInfo: PageInfo;
  edges: PricingEdge[];
}

export interface PricingConnectionPromise
  extends Promise<PricingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PricingEdge>>() => T;
  aggregate: <T = AggregatePricingPromise>() => T;
}

export interface PricingConnectionSubscription
  extends Promise<AsyncIterator<PricingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PricingEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePricingSubscription>() => T;
}

export interface CreditCardInformationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface CreditCardInformationPreviousValuesPromise
  extends Promise<CreditCardInformationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
}

export interface CreditCardInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<CreditCardInformationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cardNumber: () => Promise<AsyncIterator<String>>;
  expiresOnMonth: () => Promise<AsyncIterator<Int>>;
  expiresOnYear: () => Promise<AsyncIterator<Int>>;
  securityCode: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
}

export interface PoliciesEdge {
  node: Policies;
  cursor: String;
}

export interface PoliciesEdgePromise
  extends Promise<PoliciesEdge>,
    Fragmentable {
  node: <T = PoliciesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PoliciesEdgeSubscription
  extends Promise<AsyncIterator<PoliciesEdge>>,
    Fragmentable {
  node: <T = PoliciesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaytmInformation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  phone: String;
}

export interface PaytmInformationPromise
  extends Promise<PaytmInformation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  phone: () => Promise<String>;
}

export interface PaytmInformationSubscription
  extends Promise<AsyncIterator<PaytmInformation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface PaytmInformationNullablePromise
  extends Promise<PaytmInformation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  phone: () => Promise<String>;
}

export interface AggregatePicture {
  count: Int;
}

export interface AggregatePicturePromise
  extends Promise<AggregatePicture>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePictureSubscription
  extends Promise<AsyncIterator<AggregatePicture>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DebitCardInformationSubscriptionPayload {
  mutation: MutationType;
  node: DebitCardInformation;
  updatedFields: String[];
  previousValues: DebitCardInformationPreviousValues;
}

export interface DebitCardInformationSubscriptionPayloadPromise
  extends Promise<DebitCardInformationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DebitCardInformationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DebitCardInformationPreviousValuesPromise>() => T;
}

export interface DebitCardInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DebitCardInformationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DebitCardInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DebitCardInformationPreviousValuesSubscription>() => T;
}

export interface PictureConnection {
  pageInfo: PageInfo;
  edges: PictureEdge[];
}

export interface PictureConnectionPromise
  extends Promise<PictureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PictureEdge>>() => T;
  aggregate: <T = AggregatePicturePromise>() => T;
}

export interface PictureConnectionSubscription
  extends Promise<AsyncIterator<PictureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PictureEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePictureSubscription>() => T;
}

export interface DebitCardInformationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface DebitCardInformationPreviousValuesPromise
  extends Promise<DebitCardInformationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
}

export interface DebitCardInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<DebitCardInformationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cardNumber: () => Promise<AsyncIterator<String>>;
  expiresOnMonth: () => Promise<AsyncIterator<Int>>;
  expiresOnYear: () => Promise<AsyncIterator<Int>>;
  securityCode: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
}

export interface PaytmInformationEdge {
  node: PaytmInformation;
  cursor: String;
}

export interface PaytmInformationEdgePromise
  extends Promise<PaytmInformationEdge>,
    Fragmentable {
  node: <T = PaytmInformationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaytmInformationEdgeSubscription
  extends Promise<AsyncIterator<PaytmInformationEdge>>,
    Fragmentable {
  node: <T = PaytmInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PictureEdge {
  node: Picture;
  cursor: String;
}

export interface PictureEdgePromise extends Promise<PictureEdge>, Fragmentable {
  node: <T = PicturePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PictureEdgeSubscription
  extends Promise<AsyncIterator<PictureEdge>>,
    Fragmentable {
  node: <T = PictureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RestaurantPreviousValues {
  id: ID_Output;
  name: String;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numRatings: Int;
  avgRating?: Float;
  popularity: Int;
  avgPricePerPerson: Int;
  isCurated: Boolean;
}

export interface RestaurantPreviousValuesPromise
  extends Promise<RestaurantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  maxGuests: () => Promise<Int>;
  numRatings: () => Promise<Int>;
  avgRating: () => Promise<Float>;
  popularity: () => Promise<Int>;
  avgPricePerPerson: () => Promise<Int>;
  isCurated: () => Promise<Boolean>;
}

export interface RestaurantPreviousValuesSubscription
  extends Promise<AsyncIterator<RestaurantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  maxGuests: () => Promise<AsyncIterator<Int>>;
  numRatings: () => Promise<AsyncIterator<Int>>;
  avgRating: () => Promise<AsyncIterator<Float>>;
  popularity: () => Promise<AsyncIterator<Int>>;
  avgPricePerPerson: () => Promise<AsyncIterator<Int>>;
  isCurated: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregatePaytmInformation {
  count: Int;
}

export interface AggregatePaytmInformationPromise
  extends Promise<AggregatePaytmInformation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaytmInformationSubscription
  extends Promise<AsyncIterator<AggregatePaytmInformation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaypalInformation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
}

export interface PaypalInformationPromise
  extends Promise<PaypalInformation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface PaypalInformationSubscription
  extends Promise<AsyncIterator<PaypalInformation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface PaypalInformationNullablePromise
  extends Promise<PaypalInformation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface PaytmInformationConnection {
  pageInfo: PageInfo;
  edges: PaytmInformationEdge[];
}

export interface PaytmInformationConnectionPromise
  extends Promise<PaytmInformationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaytmInformationEdge>>() => T;
  aggregate: <T = AggregatePaytmInformationPromise>() => T;
}

export interface PaytmInformationConnectionSubscription
  extends Promise<AsyncIterator<PaytmInformationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaytmInformationEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaytmInformationSubscription>() => T;
}

export interface PaypalInformationConnection {
  pageInfo: PageInfo;
  edges: PaypalInformationEdge[];
}

export interface PaypalInformationConnectionPromise
  extends Promise<PaypalInformationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaypalInformationEdge>>() => T;
  aggregate: <T = AggregatePaypalInformationPromise>() => T;
}

export interface PaypalInformationConnectionSubscription
  extends Promise<AsyncIterator<PaypalInformationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaypalInformationEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaypalInformationSubscription>() => T;
}

export interface AggregatePaypalInformation {
  count: Int;
}

export interface AggregatePaypalInformationPromise
  extends Promise<AggregatePaypalInformation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaypalInformationSubscription
  extends Promise<AsyncIterator<AggregatePaypalInformation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentAccountEdge {
  node: PaymentAccount;
  cursor: String;
}

export interface PaymentAccountEdgePromise
  extends Promise<PaymentAccountEdge>,
    Fragmentable {
  node: <T = PaymentAccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentAccountEdgeSubscription
  extends Promise<AsyncIterator<PaymentAccountEdge>>,
    Fragmentable {
  node: <T = PaymentAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceSubscriptionPayload {
  mutation: MutationType;
  node: Experience;
  updatedFields: String[];
  previousValues: ExperiencePreviousValues;
}

export interface ExperienceSubscriptionPayloadPromise
  extends Promise<ExperienceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExperiencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExperiencePreviousValuesPromise>() => T;
}

export interface ExperienceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExperiencePreviousValuesSubscription>() => T;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperiencePreviousValues {
  id: ID_Output;
  title: String;
  pricePerPerson: Int;
  popularity: Int;
}

export interface ExperiencePreviousValuesPromise
  extends Promise<ExperiencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  pricePerPerson: () => Promise<Int>;
  popularity: () => Promise<Int>;
}

export interface ExperiencePreviousValuesSubscription
  extends Promise<AsyncIterator<ExperiencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  pricePerPerson: () => Promise<AsyncIterator<Int>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface CityEdge {
  node: City;
  cursor: String;
}

export interface CityEdgePromise extends Promise<CityEdge>, Fragmentable {
  node: <T = CityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CityEdgeSubscription
  extends Promise<AsyncIterator<CityEdge>>,
    Fragmentable {
  node: <T = CitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceCategorySubscriptionPayload {
  mutation: MutationType;
  node: ExperienceCategory;
  updatedFields: String[];
  previousValues: ExperienceCategoryPreviousValues;
}

export interface ExperienceCategorySubscriptionPayloadPromise
  extends Promise<ExperienceCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExperienceCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExperienceCategoryPreviousValuesPromise>() => T;
}

export interface ExperienceCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExperienceCategoryPreviousValuesSubscription>() => T;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperienceCategoryPreviousValues {
  id: ID_Output;
  mainColor: String;
  name: String;
}

export interface ExperienceCategoryPreviousValuesPromise
  extends Promise<ExperienceCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  mainColor: () => Promise<String>;
  name: () => Promise<String>;
}

export interface ExperienceCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ExperienceCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  mainColor: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface NotificationConnection {
  pageInfo: PageInfo;
  edges: NotificationEdge[];
}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface PaymentAccount {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: PAYMENT_PROVIDER;
}

export interface PaymentAccountPromise
  extends Promise<PaymentAccount>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
  user: <T = UserPromise>() => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  paypal: <T = PaypalInformationPromise>() => T;
  paytm: <T = PaytmInformationPromise>() => T;
  creditcard: <T = CreditCardInformationPromise>() => T;
  debitcard: <T = DebitCardInformationPromise>() => T;
}

export interface PaymentAccountSubscription
  extends Promise<AsyncIterator<PaymentAccount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PAYMENT_PROVIDER>>;
  user: <T = UserSubscription>() => T;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  paypal: <T = PaypalInformationSubscription>() => T;
  paytm: <T = PaytmInformationSubscription>() => T;
  creditcard: <T = CreditCardInformationSubscription>() => T;
  debitcard: <T = DebitCardInformationSubscription>() => T;
}

export interface PaymentAccountNullablePromise
  extends Promise<PaymentAccount | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
  user: <T = UserPromise>() => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  paypal: <T = PaypalInformationPromise>() => T;
  paytm: <T = PaytmInformationPromise>() => T;
  creditcard: <T = CreditCardInformationPromise>() => T;
  debitcard: <T = DebitCardInformationPromise>() => T;
}

export interface NeighbourhoodEdge {
  node: Neighbourhood;
  cursor: String;
}

export interface NeighbourhoodEdgePromise
  extends Promise<NeighbourhoodEdge>,
    Fragmentable {
  node: <T = NeighbourhoodPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NeighbourhoodEdgeSubscription
  extends Promise<AsyncIterator<NeighbourhoodEdge>>,
    Fragmentable {
  node: <T = NeighbourhoodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationPreviousValues {
  title?: String;
  id: ID_Output;
  lat: Float;
  lng: Float;
  address: String;
  directions: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  title: () => Promise<String>;
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  address: () => Promise<String>;
  directions: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  title: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  address: () => Promise<AsyncIterator<String>>;
  directions: () => Promise<AsyncIterator<String>>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface Payment {
  id: ID_Output;
  createdAt: DateTimeOutput;
  serviceFee: Float;
  restaurantPrice: Float;
  totalPrice: Float;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  restaurantPrice: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
  order: <T = OrderPromise>() => T;
  paymentMethod: <T = PaymentAccountPromise>() => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  serviceFee: () => Promise<AsyncIterator<Float>>;
  restaurantPrice: () => Promise<AsyncIterator<Float>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
  order: <T = OrderSubscription>() => T;
  paymentMethod: <T = PaymentAccountSubscription>() => T;
}

export interface PaymentNullablePromise
  extends Promise<Payment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  restaurantPrice: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
  order: <T = OrderPromise>() => T;
  paymentMethod: <T = PaymentAccountPromise>() => T;
}

export interface MenuItemEdge {
  node: MenuItem;
  cursor: String;
}

export interface MenuItemEdgePromise
  extends Promise<MenuItemEdge>,
    Fragmentable {
  node: <T = MenuItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MenuItemEdgeSubscription
  extends Promise<AsyncIterator<MenuItemEdge>>,
    Fragmentable {
  node: <T = MenuItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MenuItemSubscriptionPayload {
  mutation: MutationType;
  node: MenuItem;
  updatedFields: String[];
  previousValues: MenuItemPreviousValues;
}

export interface MenuItemSubscriptionPayloadPromise
  extends Promise<MenuItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MenuItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MenuItemPreviousValuesPromise>() => T;
}

export interface MenuItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MenuItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MenuItemPreviousValuesSubscription>() => T;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MenuItemPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  shortDescription: String;
  title: String;
  description: String;
}

export interface MenuItemPreviousValuesPromise
  extends Promise<MenuItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  shortDescription: () => Promise<String>;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface MenuItemPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface Order {
  id: ID_Output;
  createdAt: DateTimeOutput;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  bookee: <T = UserPromise>() => T;
  restaurant: <T = RestaurantPromise>() => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  payment: <T = PaymentPromise>() => T;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bookee: <T = UserSubscription>() => T;
  restaurant: <T = RestaurantSubscription>() => T;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  payment: <T = PaymentSubscription>() => T;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  bookee: <T = UserPromise>() => T;
  restaurant: <T = RestaurantPromise>() => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  payment: <T = PaymentPromise>() => T;
}

export interface ExperienceCategoryEdge {
  node: ExperienceCategory;
  cursor: String;
}

export interface ExperienceCategoryEdgePromise
  extends Promise<ExperienceCategoryEdge>,
    Fragmentable {
  node: <T = ExperienceCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceCategoryEdgeSubscription
  extends Promise<AsyncIterator<ExperienceCategoryEdge>>,
    Fragmentable {
  node: <T = ExperienceCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface AggregateExperience {
  count: Int;
}

export interface AggregateExperiencePromise
  extends Promise<AggregateExperience>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExperienceSubscription
  extends Promise<AsyncIterator<AggregateExperience>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessagePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  deliveredAt: DateTimeOutput;
  readAt: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  deliveredAt: () => Promise<DateTimeOutput>;
  readAt: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deliveredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  readAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExperienceConnection {
  pageInfo: PageInfo;
  edges: ExperienceEdge[];
}

export interface ExperienceConnectionPromise
  extends Promise<ExperienceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExperienceEdge>>() => T;
  aggregate: <T = AggregateExperiencePromise>() => T;
}

export interface ExperienceConnectionSubscription
  extends Promise<AsyncIterator<ExperienceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExperienceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExperienceSubscription>() => T;
}

export interface Review {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  stars: () => Promise<Int>;
  accuracy: () => Promise<Int>;
  location: () => Promise<Int>;
  checkIn: () => Promise<Int>;
  value: () => Promise<Int>;
  cleanliness: () => Promise<Int>;
  communication: () => Promise<Int>;
  order: <T = OrderPromise>() => T;
  experience: <T = ExperiencePromise>() => T;
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<Review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  accuracy: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<Int>>;
  checkIn: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<Int>>;
  cleanliness: () => Promise<AsyncIterator<Int>>;
  communication: () => Promise<AsyncIterator<Int>>;
  order: <T = OrderSubscription>() => T;
  experience: <T = ExperienceSubscription>() => T;
}

export interface ReviewNullablePromise
  extends Promise<Review | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  stars: () => Promise<Int>;
  accuracy: () => Promise<Int>;
  location: () => Promise<Int>;
  checkIn: () => Promise<Int>;
  value: () => Promise<Int>;
  cleanliness: () => Promise<Int>;
  communication: () => Promise<Int>;
  order: <T = OrderPromise>() => T;
  experience: <T = ExperiencePromise>() => T;
}

export interface Notification {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeOutput;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NOTIFICATION_TYPE>;
  user: <T = UserPromise>() => T;
  link: () => Promise<String>;
  readDate: () => Promise<DateTimeOutput>;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NOTIFICATION_TYPE>>;
  user: <T = UserSubscription>() => T;
  link: () => Promise<AsyncIterator<String>>;
  readDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NotificationNullablePromise
  extends Promise<Notification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NOTIFICATION_TYPE>;
  user: <T = UserPromise>() => T;
  link: () => Promise<String>;
  readDate: () => Promise<DateTimeOutput>;
}

export interface NeighbourhoodSubscriptionPayload {
  mutation: MutationType;
  node: Neighbourhood;
  updatedFields: String[];
  previousValues: NeighbourhoodPreviousValues;
}

export interface NeighbourhoodSubscriptionPayloadPromise
  extends Promise<NeighbourhoodSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NeighbourhoodPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NeighbourhoodPreviousValuesPromise>() => T;
}

export interface NeighbourhoodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NeighbourhoodSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NeighbourhoodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NeighbourhoodPreviousValuesSubscription>() => T;
}

export interface Message {
  id: ID_Output;
  createdAt: DateTimeOutput;
  deliveredAt: DateTimeOutput;
  readAt: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  from: <T = UserPromise>() => T;
  to: <T = UserPromise>() => T;
  deliveredAt: () => Promise<DateTimeOutput>;
  readAt: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  from: <T = UserSubscription>() => T;
  to: <T = UserSubscription>() => T;
  deliveredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  readAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MessageNullablePromise
  extends Promise<Message | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  from: <T = UserPromise>() => T;
  to: <T = UserPromise>() => T;
  deliveredAt: () => Promise<DateTimeOutput>;
  readAt: () => Promise<DateTimeOutput>;
}

export interface NeighbourhoodPreviousValues {
  id: ID_Output;
  name: String;
  slug: String;
  featured: Boolean;
  popularity: Int;
}

export interface NeighbourhoodPreviousValuesPromise
  extends Promise<NeighbourhoodPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  featured: () => Promise<Boolean>;
  popularity: () => Promise<Int>;
}

export interface NeighbourhoodPreviousValuesSubscription
  extends Promise<AsyncIterator<NeighbourhoodPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface Location {
  title?: String;
  id: ID_Output;
  lat: Float;
  lng: Float;
  address: String;
  directions: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  title: () => Promise<String>;
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  neighbourHood: <T = NeighbourhoodPromise>() => T;
  address: () => Promise<String>;
  directions: () => Promise<String>;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  title: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  neighbourHood: <T = NeighbourhoodSubscription>() => T;
  address: () => Promise<AsyncIterator<String>>;
  directions: () => Promise<AsyncIterator<String>>;
}

export interface LocationNullablePromise
  extends Promise<Location | null>,
    Fragmentable {
  title: () => Promise<String>;
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  neighbourHood: <T = NeighbourhoodPromise>() => T;
  address: () => Promise<String>;
  directions: () => Promise<String>;
}

export interface AggregateCity {
  count: Int;
}

export interface AggregateCityPromise
  extends Promise<AggregateCity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCitySubscription
  extends Promise<AsyncIterator<AggregateCity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
}

export interface ReviewPreviousValuesPromise
  extends Promise<ReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  stars: () => Promise<Int>;
  accuracy: () => Promise<Int>;
  location: () => Promise<Int>;
  checkIn: () => Promise<Int>;
  value: () => Promise<Int>;
  cleanliness: () => Promise<Int>;
  communication: () => Promise<Int>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  accuracy: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<Int>>;
  checkIn: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<Int>>;
  cleanliness: () => Promise<AsyncIterator<Int>>;
  communication: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  node: Notification;
  updatedFields: String[];
  previousValues: NotificationPreviousValues;
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NotificationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeOutput;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NOTIFICATION_TYPE>;
  link: () => Promise<String>;
  readDate: () => Promise<DateTimeOutput>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NOTIFICATION_TYPE>>;
  link: () => Promise<AsyncIterator<String>>;
  readDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewEdge {
  node: Review;
  cursor: String;
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdge>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Restaurant {
  id: ID_Output;
  name: String;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numRatings: Int;
  avgRating?: Float;
  popularity: Int;
  avgPricePerPerson: Int;
  isCurated: Boolean;
}

export interface RestaurantPromise extends Promise<Restaurant>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  maxGuests: () => Promise<Int>;
  numRatings: () => Promise<Int>;
  avgRating: () => Promise<Float>;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  location: <T = LocationPromise>() => T;
  policies: <T = PoliciesPromise>() => T;
  menu: <T = FragmentableArray<MenuItem>>(args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pictures: <T = FragmentableArray<Picture>>(args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  popularity: () => Promise<Int>;
  avgPricePerPerson: () => Promise<Int>;
  isCurated: () => Promise<Boolean>;
}

export interface RestaurantSubscription
  extends Promise<AsyncIterator<Restaurant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  maxGuests: () => Promise<AsyncIterator<Int>>;
  numRatings: () => Promise<AsyncIterator<Int>>;
  avgRating: () => Promise<AsyncIterator<Float>>;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  location: <T = LocationSubscription>() => T;
  policies: <T = PoliciesSubscription>() => T;
  menu: <T = Promise<AsyncIterator<MenuItemSubscription>>>(args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pictures: <T = Promise<AsyncIterator<PictureSubscription>>>(args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  popularity: () => Promise<AsyncIterator<Int>>;
  avgPricePerPerson: () => Promise<AsyncIterator<Int>>;
  isCurated: () => Promise<AsyncIterator<Boolean>>;
}

export interface RestaurantNullablePromise
  extends Promise<Restaurant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  maxGuests: () => Promise<Int>;
  numRatings: () => Promise<Int>;
  avgRating: () => Promise<Float>;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  location: <T = LocationPromise>() => T;
  policies: <T = PoliciesPromise>() => T;
  menu: <T = FragmentableArray<MenuItem>>(args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pictures: <T = FragmentableArray<Picture>>(args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  popularity: () => Promise<Int>;
  avgPricePerPerson: () => Promise<Int>;
  isCurated: () => Promise<Boolean>;
}

export interface RestaurantConnection {
  pageInfo: PageInfo;
  edges: RestaurantEdge[];
}

export interface RestaurantConnectionPromise
  extends Promise<RestaurantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RestaurantEdge>>() => T;
  aggregate: <T = AggregateRestaurantPromise>() => T;
}

export interface RestaurantConnectionSubscription
  extends Promise<AsyncIterator<RestaurantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RestaurantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRestaurantSubscription>() => T;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface AggregatePolicies {
  count: Int;
}

export interface AggregatePoliciesPromise
  extends Promise<AggregatePolicies>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePoliciesSubscription
  extends Promise<AsyncIterator<AggregatePolicies>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PaypalInformationEdge {
  node: PaypalInformation;
  cursor: String;
}

export interface PaypalInformationEdgePromise
  extends Promise<PaypalInformationEdge>,
    Fragmentable {
  node: <T = PaypalInformationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaypalInformationEdgeSubscription
  extends Promise<AsyncIterator<PaypalInformationEdge>>,
    Fragmentable {
  node: <T = PaypalInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CreditCardInformation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface CreditCardInformationPromise
  extends Promise<CreditCardInformation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
}

export interface CreditCardInformationSubscription
  extends Promise<AsyncIterator<CreditCardInformation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cardNumber: () => Promise<AsyncIterator<String>>;
  expiresOnMonth: () => Promise<AsyncIterator<Int>>;
  expiresOnYear: () => Promise<AsyncIterator<Int>>;
  securityCode: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
}

export interface CreditCardInformationNullablePromise
  extends Promise<CreditCardInformation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
}

export interface PaymentAccountConnection {
  pageInfo: PageInfo;
  edges: PaymentAccountEdge[];
}

export interface PaymentAccountConnectionPromise
  extends Promise<PaymentAccountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentAccountEdge>>() => T;
  aggregate: <T = AggregatePaymentAccountPromise>() => T;
}

export interface PaymentAccountConnectionSubscription
  extends Promise<AsyncIterator<PaymentAccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentAccountSubscription>() => T;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  serviceFee: Float;
  restaurantPrice: Float;
  totalPrice: Float;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  restaurantPrice: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  serviceFee: () => Promise<AsyncIterator<Float>>;
  restaurantPrice: () => Promise<AsyncIterator<Float>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
}

export interface NotificationEdge {
  node: Notification;
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CreditCardInformationConnection {
  pageInfo: PageInfo;
  edges: CreditCardInformationEdge[];
}

export interface CreditCardInformationConnectionPromise
  extends Promise<CreditCardInformationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CreditCardInformationEdge>>() => T;
  aggregate: <T = AggregateCreditCardInformationPromise>() => T;
}

export interface CreditCardInformationConnectionSubscription
  extends Promise<AsyncIterator<CreditCardInformationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CreditCardInformationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCreditCardInformationSubscription>() => T;
}

export interface NeighbourhoodConnection {
  pageInfo: PageInfo;
  edges: NeighbourhoodEdge[];
}

export interface NeighbourhoodConnectionPromise
  extends Promise<NeighbourhoodConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NeighbourhoodEdge>>() => T;
  aggregate: <T = AggregateNeighbourhoodPromise>() => T;
}

export interface NeighbourhoodConnectionSubscription
  extends Promise<AsyncIterator<NeighbourhoodConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NeighbourhoodEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNeighbourhoodSubscription>() => T;
}

export interface PaymentAccountSubscriptionPayload {
  mutation: MutationType;
  node: PaymentAccount;
  updatedFields: String[];
  previousValues: PaymentAccountPreviousValues;
}

export interface PaymentAccountSubscriptionPayloadPromise
  extends Promise<PaymentAccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentAccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentAccountPreviousValuesPromise>() => T;
}

export interface PaymentAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentAccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentAccountPreviousValuesSubscription>() => T;
}

export interface AggregateMenuItem {
  count: Int;
}

export interface AggregateMenuItemPromise
  extends Promise<AggregateMenuItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMenuItemSubscription
  extends Promise<AsyncIterator<AggregateMenuItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentAccountPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: PAYMENT_PROVIDER;
}

export interface PaymentAccountPreviousValuesPromise
  extends Promise<PaymentAccountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
}

export interface PaymentAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentAccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PAYMENT_PROVIDER>>;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  displayName: String;
  phoneNumber: String;
  responseRate?: Float;
  responseTime?: Int;
  accountType?: UserType;
  uid: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  displayName: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  responseRate: () => Promise<Float>;
  responseTime: () => Promise<Int>;
  ownedRestaurant: <T = FragmentableArray<Restaurant>>(args?: {
    where?: RestaurantWhereInput;
    orderBy?: RestaurantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  location: <T = FragmentableArray<Location>>(args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  paymentAccount: <T = FragmentableArray<PaymentAccount>>(args?: {
    where?: PaymentAccountWhereInput;
    orderBy?: PaymentAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sentMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  profilePicture: <T = PicturePromise>() => T;
  experiences: <T = FragmentableArray<Experience>>(args?: {
    where?: ExperienceWhereInput;
    orderBy?: ExperienceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accountType: () => Promise<UserType>;
  uid: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  displayName: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  responseRate: () => Promise<AsyncIterator<Float>>;
  responseTime: () => Promise<AsyncIterator<Int>>;
  ownedRestaurant: <T = Promise<AsyncIterator<RestaurantSubscription>>>(args?: {
    where?: RestaurantWhereInput;
    orderBy?: RestaurantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  location: <T = Promise<AsyncIterator<LocationSubscription>>>(args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  paymentAccount: <
    T = Promise<AsyncIterator<PaymentAccountSubscription>>
  >(args?: {
    where?: PaymentAccountWhereInput;
    orderBy?: PaymentAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sentMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notifications: <T = Promise<AsyncIterator<NotificationSubscription>>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  profilePicture: <T = PictureSubscription>() => T;
  experiences: <T = Promise<AsyncIterator<ExperienceSubscription>>>(args?: {
    where?: ExperienceWhereInput;
    orderBy?: ExperienceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accountType: () => Promise<AsyncIterator<UserType>>;
  uid: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  displayName: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  responseRate: () => Promise<Float>;
  responseTime: () => Promise<Int>;
  ownedRestaurant: <T = FragmentableArray<Restaurant>>(args?: {
    where?: RestaurantWhereInput;
    orderBy?: RestaurantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  location: <T = FragmentableArray<Location>>(args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  paymentAccount: <T = FragmentableArray<PaymentAccount>>(args?: {
    where?: PaymentAccountWhereInput;
    orderBy?: PaymentAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sentMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  receivedMessages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  profilePicture: <T = PicturePromise>() => T;
  experiences: <T = FragmentableArray<Experience>>(args?: {
    where?: ExperienceWhereInput;
    orderBy?: ExperienceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accountType: () => Promise<UserType>;
  uid: () => Promise<String>;
}

export interface ExperienceCategoryConnection {
  pageInfo: PageInfo;
  edges: ExperienceCategoryEdge[];
}

export interface ExperienceCategoryConnectionPromise
  extends Promise<ExperienceCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExperienceCategoryEdge>>() => T;
  aggregate: <T = AggregateExperienceCategoryPromise>() => T;
}

export interface ExperienceCategoryConnectionSubscription
  extends Promise<AsyncIterator<ExperienceCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExperienceCategoryEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExperienceCategorySubscription>() => T;
}

export interface PaypalInformationSubscriptionPayload {
  mutation: MutationType;
  node: PaypalInformation;
  updatedFields: String[];
  previousValues: PaypalInformationPreviousValues;
}

export interface PaypalInformationSubscriptionPayloadPromise
  extends Promise<PaypalInformationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaypalInformationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaypalInformationPreviousValuesPromise>() => T;
}

export interface PaypalInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaypalInformationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaypalInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaypalInformationPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PaypalInformationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
}

export interface PaypalInformationPreviousValuesPromise
  extends Promise<PaypalInformationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface PaypalInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<PaypalInformationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface Neighbourhood {
  id: ID_Output;
  name: String;
  slug: String;
  featured: Boolean;
  popularity: Int;
}

export interface NeighbourhoodPromise
  extends Promise<Neighbourhood>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  locations: <T = FragmentableArray<Location>>(args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  homePreview: <T = PicturePromise>() => T;
  city: <T = CityPromise>() => T;
  featured: () => Promise<Boolean>;
  popularity: () => Promise<Int>;
}

export interface NeighbourhoodSubscription
  extends Promise<AsyncIterator<Neighbourhood>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  locations: <T = Promise<AsyncIterator<LocationSubscription>>>(args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  homePreview: <T = PictureSubscription>() => T;
  city: <T = CitySubscription>() => T;
  featured: () => Promise<AsyncIterator<Boolean>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface NeighbourhoodNullablePromise
  extends Promise<Neighbourhood | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  locations: <T = FragmentableArray<Location>>(args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  homePreview: <T = PicturePromise>() => T;
  city: <T = CityPromise>() => T;
  featured: () => Promise<Boolean>;
  popularity: () => Promise<Int>;
}

export interface ExperienceCategory {
  id: ID_Output;
  mainColor: String;
  name: String;
}

export interface ExperienceCategoryPromise
  extends Promise<ExperienceCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  mainColor: () => Promise<String>;
  name: () => Promise<String>;
}

export interface ExperienceCategorySubscription
  extends Promise<AsyncIterator<ExperienceCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  mainColor: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceCategoryNullablePromise
  extends Promise<ExperienceCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  mainColor: () => Promise<String>;
  name: () => Promise<String>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PaytmInformationSubscriptionPayload {
  mutation: MutationType;
  node: PaytmInformation;
  updatedFields: String[];
  previousValues: PaytmInformationPreviousValues;
}

export interface PaytmInformationSubscriptionPayloadPromise
  extends Promise<PaytmInformationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaytmInformationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaytmInformationPreviousValuesPromise>() => T;
}

export interface PaytmInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaytmInformationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaytmInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaytmInformationPreviousValuesSubscription>() => T;
}

export interface AggregateRestaurant {
  count: Int;
}

export interface AggregateRestaurantPromise
  extends Promise<AggregateRestaurant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRestaurantSubscription
  extends Promise<AsyncIterator<AggregateRestaurant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaytmInformationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  phone: String;
}

export interface PaytmInformationPreviousValuesPromise
  extends Promise<PaytmInformationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  phone: () => Promise<String>;
}

export interface PaytmInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<PaytmInformationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface PoliciesConnection {
  pageInfo: PageInfo;
  edges: PoliciesEdge[];
}

export interface PoliciesConnectionPromise
  extends Promise<PoliciesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PoliciesEdge>>() => T;
  aggregate: <T = AggregatePoliciesPromise>() => T;
}

export interface PoliciesConnectionSubscription
  extends Promise<AsyncIterator<PoliciesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PoliciesEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePoliciesSubscription>() => T;
}

export interface Experience {
  id: ID_Output;
  title: String;
  pricePerPerson: Int;
  popularity: Int;
}

export interface ExperiencePromise extends Promise<Experience>, Fragmentable {
  id: () => Promise<ID_Output>;
  category: <T = ExperienceCategoryPromise>() => T;
  title: () => Promise<String>;
  host: <T = UserPromise>() => T;
  location: <T = LocationPromise>() => T;
  pricePerPerson: () => Promise<Int>;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preview: <T = PicturePromise>() => T;
  popularity: () => Promise<Int>;
}

export interface ExperienceSubscription
  extends Promise<AsyncIterator<Experience>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: <T = ExperienceCategorySubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  host: <T = UserSubscription>() => T;
  location: <T = LocationSubscription>() => T;
  pricePerPerson: () => Promise<AsyncIterator<Int>>;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preview: <T = PictureSubscription>() => T;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface ExperienceNullablePromise
  extends Promise<Experience | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: <T = ExperienceCategoryPromise>() => T;
  title: () => Promise<String>;
  host: <T = UserPromise>() => T;
  location: <T = LocationPromise>() => T;
  pricePerPerson: () => Promise<Int>;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preview: <T = PicturePromise>() => T;
  popularity: () => Promise<Int>;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PictureSubscriptionPayload {
  mutation: MutationType;
  node: Picture;
  updatedFields: String[];
  previousValues: PicturePreviousValues;
}

export interface PictureSubscriptionPayloadPromise
  extends Promise<PictureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PicturePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PicturePreviousValuesPromise>() => T;
}

export interface PictureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PictureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PictureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PicturePreviousValuesSubscription>() => T;
}

export interface AggregateNeighbourhood {
  count: Int;
}

export interface AggregateNeighbourhoodPromise
  extends Promise<AggregateNeighbourhood>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNeighbourhoodSubscription
  extends Promise<AsyncIterator<AggregateNeighbourhood>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PicturePreviousValues {
  id: ID_Output;
  altText?: String;
  url: String;
}

export interface PicturePreviousValuesPromise
  extends Promise<PicturePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  altText: () => Promise<String>;
  url: () => Promise<String>;
}

export interface PicturePreviousValuesSubscription
  extends Promise<AsyncIterator<PicturePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  altText: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface MenuItemConnection {
  pageInfo: PageInfo;
  edges: MenuItemEdge[];
}

export interface MenuItemConnectionPromise
  extends Promise<MenuItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MenuItemEdge>>() => T;
  aggregate: <T = AggregateMenuItemPromise>() => T;
}

export interface MenuItemConnectionSubscription
  extends Promise<AsyncIterator<MenuItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MenuItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMenuItemSubscription>() => T;
}

export interface AggregateDebitCardInformation {
  count: Int;
}

export interface AggregateDebitCardInformationPromise
  extends Promise<AggregateDebitCardInformation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDebitCardInformationSubscription
  extends Promise<AsyncIterator<AggregateDebitCardInformation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperienceEdge {
  node: Experience;
  cursor: String;
}

export interface ExperienceEdgePromise
  extends Promise<ExperienceEdge>,
    Fragmentable {
  node: <T = ExperiencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceEdgeSubscription
  extends Promise<AsyncIterator<ExperienceEdge>>,
    Fragmentable {
  node: <T = ExperienceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PoliciesSubscriptionPayload {
  mutation: MutationType;
  node: Policies;
  updatedFields: String[];
  previousValues: PoliciesPreviousValues;
}

export interface PoliciesSubscriptionPayloadPromise
  extends Promise<PoliciesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PoliciesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PoliciesPreviousValuesPromise>() => T;
}

export interface PoliciesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PoliciesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PoliciesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PoliciesPreviousValuesSubscription>() => T;
}

export interface Picture {
  id: ID_Output;
  altText?: String;
  url: String;
}

export interface PicturePromise extends Promise<Picture>, Fragmentable {
  id: () => Promise<ID_Output>;
  altText: () => Promise<String>;
  url: () => Promise<String>;
}

export interface PictureSubscription
  extends Promise<AsyncIterator<Picture>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  altText: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface PictureNullablePromise
  extends Promise<Picture | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  altText: () => Promise<String>;
  url: () => Promise<String>;
}

export interface PoliciesPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  openingTime: Float;
  closingTime: Float;
}

export interface PoliciesPreviousValuesPromise
  extends Promise<PoliciesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  openingTime: () => Promise<Float>;
  closingTime: () => Promise<Float>;
}

export interface PoliciesPreviousValuesSubscription
  extends Promise<AsyncIterator<PoliciesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  openingTime: () => Promise<AsyncIterator<Float>>;
  closingTime: () => Promise<AsyncIterator<Float>>;
}

export interface PricingEdge {
  node: Pricing;
  cursor: String;
}

export interface PricingEdgePromise extends Promise<PricingEdge>, Fragmentable {
  node: <T = PricingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PricingEdgeSubscription
  extends Promise<AsyncIterator<PricingEdge>>,
    Fragmentable {
  node: <T = PricingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DebitCardInformationEdge {
  node: DebitCardInformation;
  cursor: String;
}

export interface DebitCardInformationEdgePromise
  extends Promise<DebitCardInformationEdge>,
    Fragmentable {
  node: <T = DebitCardInformationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DebitCardInformationEdgeSubscription
  extends Promise<AsyncIterator<DebitCardInformationEdge>>,
    Fragmentable {
  node: <T = DebitCardInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface AggregateExperienceCategory {
  count: Int;
}

export interface AggregateExperienceCategoryPromise
  extends Promise<AggregateExperienceCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExperienceCategorySubscription
  extends Promise<AsyncIterator<AggregateExperienceCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RestaurantSubscriptionPayload {
  mutation: MutationType;
  node: Restaurant;
  updatedFields: String[];
  previousValues: RestaurantPreviousValues;
}

export interface RestaurantSubscriptionPayloadPromise
  extends Promise<RestaurantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RestaurantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RestaurantPreviousValuesPromise>() => T;
}

export interface RestaurantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RestaurantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RestaurantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RestaurantPreviousValuesSubscription>() => T;
}

export interface DebitCardInformationConnection {
  pageInfo: PageInfo;
  edges: DebitCardInformationEdge[];
}

export interface DebitCardInformationConnectionPromise
  extends Promise<DebitCardInformationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DebitCardInformationEdge>>() => T;
  aggregate: <T = AggregateDebitCardInformationPromise>() => T;
}

export interface DebitCardInformationConnectionSubscription
  extends Promise<AsyncIterator<DebitCardInformationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<DebitCardInformationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateDebitCardInformationSubscription>() => T;
}

export interface PricingPreviousValues {
  id: ID_Output;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  price: Int;
  smartPricing: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  weekendPricing?: Int;
}

export interface PricingPreviousValuesPromise
  extends Promise<PricingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  monthlyDiscount: () => Promise<Int>;
  weeklyDiscount: () => Promise<Int>;
  price: () => Promise<Int>;
  smartPricing: () => Promise<Boolean>;
  basePrice: () => Promise<Int>;
  averageWeekly: () => Promise<Int>;
  averageMonthly: () => Promise<Int>;
  weekendPricing: () => Promise<Int>;
}

export interface PricingPreviousValuesSubscription
  extends Promise<AsyncIterator<PricingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  monthlyDiscount: () => Promise<AsyncIterator<Int>>;
  weeklyDiscount: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Int>>;
  smartPricing: () => Promise<AsyncIterator<Boolean>>;
  basePrice: () => Promise<AsyncIterator<Int>>;
  averageWeekly: () => Promise<AsyncIterator<Int>>;
  averageMonthly: () => Promise<AsyncIterator<Int>>;
  weekendPricing: () => Promise<AsyncIterator<Int>>;
}

export interface PricingSubscriptionPayload {
  mutation: MutationType;
  node: Pricing;
  updatedFields: String[];
  previousValues: PricingPreviousValues;
}

export interface PricingSubscriptionPayloadPromise
  extends Promise<PricingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PricingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PricingPreviousValuesPromise>() => T;
}

export interface PricingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PricingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PricingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PricingPreviousValuesSubscription>() => T;
}

export interface DebitCardInformation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface DebitCardInformationPromise
  extends Promise<DebitCardInformation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
}

export interface DebitCardInformationSubscription
  extends Promise<AsyncIterator<DebitCardInformation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cardNumber: () => Promise<AsyncIterator<String>>;
  expiresOnMonth: () => Promise<AsyncIterator<Int>>;
  expiresOnYear: () => Promise<AsyncIterator<Int>>;
  securityCode: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
}

export interface DebitCardInformationNullablePromise
  extends Promise<DebitCardInformation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePaymentAccount {
  count: Int;
}

export interface AggregatePaymentAccountPromise
  extends Promise<AggregatePaymentAccount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentAccountSubscription
  extends Promise<AsyncIterator<AggregatePaymentAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType;
  node: Review;
  updatedFields: String[];
  previousValues: ReviewPreviousValues;
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValuesPromise>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export type Long = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Restaurant",
    embedded: false
  },
  {
    name: "Pricing",
    embedded: false
  },
  {
    name: "Policies",
    embedded: false
  },
  {
    name: "MenuItem",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Neighbourhood",
    embedded: false
  },
  {
    name: "City",
    embedded: false
  },
  {
    name: "Picture",
    embedded: false
  },
  {
    name: "Experience",
    embedded: false
  },
  {
    name: "ExperienceCategory",
    embedded: false
  },
  {
    name: "Review",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "PaymentAccount",
    embedded: false
  },
  {
    name: "PaypalInformation",
    embedded: false
  },
  {
    name: "PaytmInformation",
    embedded: false
  },
  {
    name: "CreditCardInformation",
    embedded: false
  },
  {
    name: "DebitCardInformation",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "UserType",
    embedded: false
  },
  {
    name: "PAYMENT_PROVIDER",
    embedded: false
  },
  {
    name: "NOTIFICATION_TYPE",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
