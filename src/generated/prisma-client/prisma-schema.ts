// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateCity {
  count: Int!
}

type AggregateCreditCardInformation {
  count: Int!
}

type AggregateDebitCardInformation {
  count: Int!
}

type AggregateExperience {
  count: Int!
}

type AggregateExperienceCategory {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMenuItem {
  count: Int!
}

type AggregateMessage {
  count: Int!
}

type AggregateNeighbourhood {
  count: Int!
}

type AggregateNotification {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregatePaymentAccount {
  count: Int!
}

type AggregatePaypalInformation {
  count: Int!
}

type AggregatePaytmInformation {
  count: Int!
}

type AggregatePicture {
  count: Int!
}

type AggregatePolicies {
  count: Int!
}

type AggregatePricing {
  count: Int!
}

type AggregateRestaurant {
  count: Int!
}

type AggregateReview {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type City {
  id: ID!
  name: String!
  neighbourhoods(where: NeighbourhoodWhereInput, orderBy: NeighbourhoodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Neighbourhood!]
}

type CityConnection {
  pageInfo: PageInfo!
  edges: [CityEdge]!
  aggregate: AggregateCity!
}

input CityCreateInput {
  id: ID
  name: String!
  neighbourhoods: NeighbourhoodCreateManyWithoutCityInput
}

input CityCreateOneWithoutNeighbourhoodsInput {
  create: CityCreateWithoutNeighbourhoodsInput
  connect: CityWhereUniqueInput
}

input CityCreateWithoutNeighbourhoodsInput {
  id: ID
  name: String!
}

type CityEdge {
  node: City!
  cursor: String!
}

enum CityOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type CityPreviousValues {
  id: ID!
  name: String!
}

type CitySubscriptionPayload {
  mutation: MutationType!
  node: City
  updatedFields: [String!]
  previousValues: CityPreviousValues
}

input CitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CityWhereInput
  AND: [CitySubscriptionWhereInput!]
  OR: [CitySubscriptionWhereInput!]
  NOT: [CitySubscriptionWhereInput!]
}

input CityUpdateInput {
  name: String
  neighbourhoods: NeighbourhoodUpdateManyWithoutCityInput
}

input CityUpdateManyMutationInput {
  name: String
}

input CityUpdateOneRequiredWithoutNeighbourhoodsInput {
  create: CityCreateWithoutNeighbourhoodsInput
  update: CityUpdateWithoutNeighbourhoodsDataInput
  upsert: CityUpsertWithoutNeighbourhoodsInput
  connect: CityWhereUniqueInput
}

input CityUpdateWithoutNeighbourhoodsDataInput {
  name: String
}

input CityUpsertWithoutNeighbourhoodsInput {
  update: CityUpdateWithoutNeighbourhoodsDataInput!
  create: CityCreateWithoutNeighbourhoodsInput!
}

input CityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  neighbourhoods_every: NeighbourhoodWhereInput
  neighbourhoods_some: NeighbourhoodWhereInput
  neighbourhoods_none: NeighbourhoodWhereInput
  AND: [CityWhereInput!]
  OR: [CityWhereInput!]
  NOT: [CityWhereInput!]
}

input CityWhereUniqueInput {
  id: ID
}

type CreditCardInformation {
  id: ID!
  createdAt: DateTime!
  cardNumber: String!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  securityCode: String!
  firstName: String!
  lastName: String!
  postalCode: String!
  country: String!
}

type CreditCardInformationConnection {
  pageInfo: PageInfo!
  edges: [CreditCardInformationEdge]!
  aggregate: AggregateCreditCardInformation!
}

input CreditCardInformationCreateInput {
  id: ID
  cardNumber: String!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  securityCode: String!
  firstName: String!
  lastName: String!
  postalCode: String!
  country: String!
}

input CreditCardInformationCreateOneInput {
  create: CreditCardInformationCreateInput
  connect: CreditCardInformationWhereUniqueInput
}

type CreditCardInformationEdge {
  node: CreditCardInformation!
  cursor: String!
}

enum CreditCardInformationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  cardNumber_ASC
  cardNumber_DESC
  expiresOnMonth_ASC
  expiresOnMonth_DESC
  expiresOnYear_ASC
  expiresOnYear_DESC
  securityCode_ASC
  securityCode_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  postalCode_ASC
  postalCode_DESC
  country_ASC
  country_DESC
}

type CreditCardInformationPreviousValues {
  id: ID!
  createdAt: DateTime!
  cardNumber: String!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  securityCode: String!
  firstName: String!
  lastName: String!
  postalCode: String!
  country: String!
}

type CreditCardInformationSubscriptionPayload {
  mutation: MutationType!
  node: CreditCardInformation
  updatedFields: [String!]
  previousValues: CreditCardInformationPreviousValues
}

input CreditCardInformationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CreditCardInformationWhereInput
  AND: [CreditCardInformationSubscriptionWhereInput!]
  OR: [CreditCardInformationSubscriptionWhereInput!]
  NOT: [CreditCardInformationSubscriptionWhereInput!]
}

input CreditCardInformationUpdateDataInput {
  cardNumber: String
  expiresOnMonth: Int
  expiresOnYear: Int
  securityCode: String
  firstName: String
  lastName: String
  postalCode: String
  country: String
}

input CreditCardInformationUpdateInput {
  cardNumber: String
  expiresOnMonth: Int
  expiresOnYear: Int
  securityCode: String
  firstName: String
  lastName: String
  postalCode: String
  country: String
}

input CreditCardInformationUpdateManyMutationInput {
  cardNumber: String
  expiresOnMonth: Int
  expiresOnYear: Int
  securityCode: String
  firstName: String
  lastName: String
  postalCode: String
  country: String
}

input CreditCardInformationUpdateOneInput {
  create: CreditCardInformationCreateInput
  update: CreditCardInformationUpdateDataInput
  upsert: CreditCardInformationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CreditCardInformationWhereUniqueInput
}

input CreditCardInformationUpsertNestedInput {
  update: CreditCardInformationUpdateDataInput!
  create: CreditCardInformationCreateInput!
}

input CreditCardInformationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  cardNumber: String
  cardNumber_not: String
  cardNumber_in: [String!]
  cardNumber_not_in: [String!]
  cardNumber_lt: String
  cardNumber_lte: String
  cardNumber_gt: String
  cardNumber_gte: String
  cardNumber_contains: String
  cardNumber_not_contains: String
  cardNumber_starts_with: String
  cardNumber_not_starts_with: String
  cardNumber_ends_with: String
  cardNumber_not_ends_with: String
  expiresOnMonth: Int
  expiresOnMonth_not: Int
  expiresOnMonth_in: [Int!]
  expiresOnMonth_not_in: [Int!]
  expiresOnMonth_lt: Int
  expiresOnMonth_lte: Int
  expiresOnMonth_gt: Int
  expiresOnMonth_gte: Int
  expiresOnYear: Int
  expiresOnYear_not: Int
  expiresOnYear_in: [Int!]
  expiresOnYear_not_in: [Int!]
  expiresOnYear_lt: Int
  expiresOnYear_lte: Int
  expiresOnYear_gt: Int
  expiresOnYear_gte: Int
  securityCode: String
  securityCode_not: String
  securityCode_in: [String!]
  securityCode_not_in: [String!]
  securityCode_lt: String
  securityCode_lte: String
  securityCode_gt: String
  securityCode_gte: String
  securityCode_contains: String
  securityCode_not_contains: String
  securityCode_starts_with: String
  securityCode_not_starts_with: String
  securityCode_ends_with: String
  securityCode_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  postalCode: String
  postalCode_not: String
  postalCode_in: [String!]
  postalCode_not_in: [String!]
  postalCode_lt: String
  postalCode_lte: String
  postalCode_gt: String
  postalCode_gte: String
  postalCode_contains: String
  postalCode_not_contains: String
  postalCode_starts_with: String
  postalCode_not_starts_with: String
  postalCode_ends_with: String
  postalCode_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  AND: [CreditCardInformationWhereInput!]
  OR: [CreditCardInformationWhereInput!]
  NOT: [CreditCardInformationWhereInput!]
}

input CreditCardInformationWhereUniqueInput {
  id: ID
}

scalar DateTime

type DebitCardInformation {
  id: ID!
  createdAt: DateTime!
  cardNumber: String!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  securityCode: String!
  firstName: String!
  lastName: String!
  postalCode: String!
  country: String!
}

type DebitCardInformationConnection {
  pageInfo: PageInfo!
  edges: [DebitCardInformationEdge]!
  aggregate: AggregateDebitCardInformation!
}

input DebitCardInformationCreateInput {
  id: ID
  cardNumber: String!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  securityCode: String!
  firstName: String!
  lastName: String!
  postalCode: String!
  country: String!
}

input DebitCardInformationCreateOneInput {
  create: DebitCardInformationCreateInput
  connect: DebitCardInformationWhereUniqueInput
}

type DebitCardInformationEdge {
  node: DebitCardInformation!
  cursor: String!
}

enum DebitCardInformationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  cardNumber_ASC
  cardNumber_DESC
  expiresOnMonth_ASC
  expiresOnMonth_DESC
  expiresOnYear_ASC
  expiresOnYear_DESC
  securityCode_ASC
  securityCode_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  postalCode_ASC
  postalCode_DESC
  country_ASC
  country_DESC
}

type DebitCardInformationPreviousValues {
  id: ID!
  createdAt: DateTime!
  cardNumber: String!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  securityCode: String!
  firstName: String!
  lastName: String!
  postalCode: String!
  country: String!
}

type DebitCardInformationSubscriptionPayload {
  mutation: MutationType!
  node: DebitCardInformation
  updatedFields: [String!]
  previousValues: DebitCardInformationPreviousValues
}

input DebitCardInformationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DebitCardInformationWhereInput
  AND: [DebitCardInformationSubscriptionWhereInput!]
  OR: [DebitCardInformationSubscriptionWhereInput!]
  NOT: [DebitCardInformationSubscriptionWhereInput!]
}

input DebitCardInformationUpdateDataInput {
  cardNumber: String
  expiresOnMonth: Int
  expiresOnYear: Int
  securityCode: String
  firstName: String
  lastName: String
  postalCode: String
  country: String
}

input DebitCardInformationUpdateInput {
  cardNumber: String
  expiresOnMonth: Int
  expiresOnYear: Int
  securityCode: String
  firstName: String
  lastName: String
  postalCode: String
  country: String
}

input DebitCardInformationUpdateManyMutationInput {
  cardNumber: String
  expiresOnMonth: Int
  expiresOnYear: Int
  securityCode: String
  firstName: String
  lastName: String
  postalCode: String
  country: String
}

input DebitCardInformationUpdateOneInput {
  create: DebitCardInformationCreateInput
  update: DebitCardInformationUpdateDataInput
  upsert: DebitCardInformationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: DebitCardInformationWhereUniqueInput
}

input DebitCardInformationUpsertNestedInput {
  update: DebitCardInformationUpdateDataInput!
  create: DebitCardInformationCreateInput!
}

input DebitCardInformationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  cardNumber: String
  cardNumber_not: String
  cardNumber_in: [String!]
  cardNumber_not_in: [String!]
  cardNumber_lt: String
  cardNumber_lte: String
  cardNumber_gt: String
  cardNumber_gte: String
  cardNumber_contains: String
  cardNumber_not_contains: String
  cardNumber_starts_with: String
  cardNumber_not_starts_with: String
  cardNumber_ends_with: String
  cardNumber_not_ends_with: String
  expiresOnMonth: Int
  expiresOnMonth_not: Int
  expiresOnMonth_in: [Int!]
  expiresOnMonth_not_in: [Int!]
  expiresOnMonth_lt: Int
  expiresOnMonth_lte: Int
  expiresOnMonth_gt: Int
  expiresOnMonth_gte: Int
  expiresOnYear: Int
  expiresOnYear_not: Int
  expiresOnYear_in: [Int!]
  expiresOnYear_not_in: [Int!]
  expiresOnYear_lt: Int
  expiresOnYear_lte: Int
  expiresOnYear_gt: Int
  expiresOnYear_gte: Int
  securityCode: String
  securityCode_not: String
  securityCode_in: [String!]
  securityCode_not_in: [String!]
  securityCode_lt: String
  securityCode_lte: String
  securityCode_gt: String
  securityCode_gte: String
  securityCode_contains: String
  securityCode_not_contains: String
  securityCode_starts_with: String
  securityCode_not_starts_with: String
  securityCode_ends_with: String
  securityCode_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  postalCode: String
  postalCode_not: String
  postalCode_in: [String!]
  postalCode_not_in: [String!]
  postalCode_lt: String
  postalCode_lte: String
  postalCode_gt: String
  postalCode_gte: String
  postalCode_contains: String
  postalCode_not_contains: String
  postalCode_starts_with: String
  postalCode_not_starts_with: String
  postalCode_ends_with: String
  postalCode_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  AND: [DebitCardInformationWhereInput!]
  OR: [DebitCardInformationWhereInput!]
  NOT: [DebitCardInformationWhereInput!]
}

input DebitCardInformationWhereUniqueInput {
  id: ID
}

type Experience {
  id: ID!
  category: ExperienceCategory
  title: String!
  host: User!
  location: Location!
  pricePerPerson: Int!
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  preview: Picture!
  popularity: Int!
}

type ExperienceCategory {
  id: ID!
  mainColor: String!
  name: String!
}

type ExperienceCategoryConnection {
  pageInfo: PageInfo!
  edges: [ExperienceCategoryEdge]!
  aggregate: AggregateExperienceCategory!
}

input ExperienceCategoryCreateInput {
  id: ID
  mainColor: String
  name: String!
}

input ExperienceCategoryCreateOneInput {
  create: ExperienceCategoryCreateInput
  connect: ExperienceCategoryWhereUniqueInput
}

type ExperienceCategoryEdge {
  node: ExperienceCategory!
  cursor: String!
}

enum ExperienceCategoryOrderByInput {
  id_ASC
  id_DESC
  mainColor_ASC
  mainColor_DESC
  name_ASC
  name_DESC
}

type ExperienceCategoryPreviousValues {
  id: ID!
  mainColor: String!
  name: String!
}

type ExperienceCategorySubscriptionPayload {
  mutation: MutationType!
  node: ExperienceCategory
  updatedFields: [String!]
  previousValues: ExperienceCategoryPreviousValues
}

input ExperienceCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExperienceCategoryWhereInput
  AND: [ExperienceCategorySubscriptionWhereInput!]
  OR: [ExperienceCategorySubscriptionWhereInput!]
  NOT: [ExperienceCategorySubscriptionWhereInput!]
}

input ExperienceCategoryUpdateDataInput {
  mainColor: String
  name: String
}

input ExperienceCategoryUpdateInput {
  mainColor: String
  name: String
}

input ExperienceCategoryUpdateManyMutationInput {
  mainColor: String
  name: String
}

input ExperienceCategoryUpdateOneInput {
  create: ExperienceCategoryCreateInput
  update: ExperienceCategoryUpdateDataInput
  upsert: ExperienceCategoryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ExperienceCategoryWhereUniqueInput
}

input ExperienceCategoryUpsertNestedInput {
  update: ExperienceCategoryUpdateDataInput!
  create: ExperienceCategoryCreateInput!
}

input ExperienceCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  mainColor: String
  mainColor_not: String
  mainColor_in: [String!]
  mainColor_not_in: [String!]
  mainColor_lt: String
  mainColor_lte: String
  mainColor_gt: String
  mainColor_gte: String
  mainColor_contains: String
  mainColor_not_contains: String
  mainColor_starts_with: String
  mainColor_not_starts_with: String
  mainColor_ends_with: String
  mainColor_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ExperienceCategoryWhereInput!]
  OR: [ExperienceCategoryWhereInput!]
  NOT: [ExperienceCategoryWhereInput!]
}

input ExperienceCategoryWhereUniqueInput {
  id: ID
}

type ExperienceConnection {
  pageInfo: PageInfo!
  edges: [ExperienceEdge]!
  aggregate: AggregateExperience!
}

input ExperienceCreateInput {
  id: ID
  category: ExperienceCategoryCreateOneInput
  title: String!
  host: UserCreateOneWithoutExperiencesInput!
  location: LocationCreateOneInput!
  pricePerPerson: Int!
  reviews: ReviewCreateManyWithoutExperienceInput
  preview: PictureCreateOneInput!
  popularity: Int!
}

input ExperienceCreateManyWithoutHostInput {
  create: [ExperienceCreateWithoutHostInput!]
  connect: [ExperienceWhereUniqueInput!]
}

input ExperienceCreateOneWithoutReviewsInput {
  create: ExperienceCreateWithoutReviewsInput
  connect: ExperienceWhereUniqueInput
}

input ExperienceCreateWithoutHostInput {
  id: ID
  category: ExperienceCategoryCreateOneInput
  title: String!
  location: LocationCreateOneInput!
  pricePerPerson: Int!
  reviews: ReviewCreateManyWithoutExperienceInput
  preview: PictureCreateOneInput!
  popularity: Int!
}

input ExperienceCreateWithoutReviewsInput {
  id: ID
  category: ExperienceCategoryCreateOneInput
  title: String!
  host: UserCreateOneWithoutExperiencesInput!
  location: LocationCreateOneInput!
  pricePerPerson: Int!
  preview: PictureCreateOneInput!
  popularity: Int!
}

type ExperienceEdge {
  node: Experience!
  cursor: String!
}

enum ExperienceOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  pricePerPerson_ASC
  pricePerPerson_DESC
  popularity_ASC
  popularity_DESC
}

type ExperiencePreviousValues {
  id: ID!
  title: String!
  pricePerPerson: Int!
  popularity: Int!
}

input ExperienceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  pricePerPerson: Int
  pricePerPerson_not: Int
  pricePerPerson_in: [Int!]
  pricePerPerson_not_in: [Int!]
  pricePerPerson_lt: Int
  pricePerPerson_lte: Int
  pricePerPerson_gt: Int
  pricePerPerson_gte: Int
  popularity: Int
  popularity_not: Int
  popularity_in: [Int!]
  popularity_not_in: [Int!]
  popularity_lt: Int
  popularity_lte: Int
  popularity_gt: Int
  popularity_gte: Int
  AND: [ExperienceScalarWhereInput!]
  OR: [ExperienceScalarWhereInput!]
  NOT: [ExperienceScalarWhereInput!]
}

type ExperienceSubscriptionPayload {
  mutation: MutationType!
  node: Experience
  updatedFields: [String!]
  previousValues: ExperiencePreviousValues
}

input ExperienceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExperienceWhereInput
  AND: [ExperienceSubscriptionWhereInput!]
  OR: [ExperienceSubscriptionWhereInput!]
  NOT: [ExperienceSubscriptionWhereInput!]
}

input ExperienceUpdateInput {
  category: ExperienceCategoryUpdateOneInput
  title: String
  host: UserUpdateOneRequiredWithoutExperiencesInput
  location: LocationUpdateOneRequiredInput
  pricePerPerson: Int
  reviews: ReviewUpdateManyWithoutExperienceInput
  preview: PictureUpdateOneRequiredInput
  popularity: Int
}

input ExperienceUpdateManyDataInput {
  title: String
  pricePerPerson: Int
  popularity: Int
}

input ExperienceUpdateManyMutationInput {
  title: String
  pricePerPerson: Int
  popularity: Int
}

input ExperienceUpdateManyWithoutHostInput {
  create: [ExperienceCreateWithoutHostInput!]
  delete: [ExperienceWhereUniqueInput!]
  connect: [ExperienceWhereUniqueInput!]
  set: [ExperienceWhereUniqueInput!]
  disconnect: [ExperienceWhereUniqueInput!]
  update: [ExperienceUpdateWithWhereUniqueWithoutHostInput!]
  upsert: [ExperienceUpsertWithWhereUniqueWithoutHostInput!]
  deleteMany: [ExperienceScalarWhereInput!]
  updateMany: [ExperienceUpdateManyWithWhereNestedInput!]
}

input ExperienceUpdateManyWithWhereNestedInput {
  where: ExperienceScalarWhereInput!
  data: ExperienceUpdateManyDataInput!
}

input ExperienceUpdateOneWithoutReviewsInput {
  create: ExperienceCreateWithoutReviewsInput
  update: ExperienceUpdateWithoutReviewsDataInput
  upsert: ExperienceUpsertWithoutReviewsInput
  delete: Boolean
  disconnect: Boolean
  connect: ExperienceWhereUniqueInput
}

input ExperienceUpdateWithoutHostDataInput {
  category: ExperienceCategoryUpdateOneInput
  title: String
  location: LocationUpdateOneRequiredInput
  pricePerPerson: Int
  reviews: ReviewUpdateManyWithoutExperienceInput
  preview: PictureUpdateOneRequiredInput
  popularity: Int
}

input ExperienceUpdateWithoutReviewsDataInput {
  category: ExperienceCategoryUpdateOneInput
  title: String
  host: UserUpdateOneRequiredWithoutExperiencesInput
  location: LocationUpdateOneRequiredInput
  pricePerPerson: Int
  preview: PictureUpdateOneRequiredInput
  popularity: Int
}

input ExperienceUpdateWithWhereUniqueWithoutHostInput {
  where: ExperienceWhereUniqueInput!
  data: ExperienceUpdateWithoutHostDataInput!
}

input ExperienceUpsertWithoutReviewsInput {
  update: ExperienceUpdateWithoutReviewsDataInput!
  create: ExperienceCreateWithoutReviewsInput!
}

input ExperienceUpsertWithWhereUniqueWithoutHostInput {
  where: ExperienceWhereUniqueInput!
  update: ExperienceUpdateWithoutHostDataInput!
  create: ExperienceCreateWithoutHostInput!
}

input ExperienceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  category: ExperienceCategoryWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  host: UserWhereInput
  location: LocationWhereInput
  pricePerPerson: Int
  pricePerPerson_not: Int
  pricePerPerson_in: [Int!]
  pricePerPerson_not_in: [Int!]
  pricePerPerson_lt: Int
  pricePerPerson_lte: Int
  pricePerPerson_gt: Int
  pricePerPerson_gte: Int
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  preview: PictureWhereInput
  popularity: Int
  popularity_not: Int
  popularity_in: [Int!]
  popularity_not_in: [Int!]
  popularity_lt: Int
  popularity_lte: Int
  popularity_gt: Int
  popularity_gte: Int
  AND: [ExperienceWhereInput!]
  OR: [ExperienceWhereInput!]
  NOT: [ExperienceWhereInput!]
}

input ExperienceWhereUniqueInput {
  id: ID
}

type Location {
  title: String
  id: ID!
  lat: Float!
  lng: Float!
  neighbourHood: Neighbourhood
  address: String!
  directions: String!
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  title: String
  id: ID
  lat: Float!
  lng: Float!
  neighbourHood: NeighbourhoodCreateOneWithoutLocationsInput
  address: String!
  directions: String!
}

input LocationCreateManyInput {
  create: [LocationCreateInput!]
  connect: [LocationWhereUniqueInput!]
}

input LocationCreateManyWithoutNeighbourHoodInput {
  create: [LocationCreateWithoutNeighbourHoodInput!]
  connect: [LocationWhereUniqueInput!]
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

input LocationCreateWithoutNeighbourHoodInput {
  title: String
  id: ID
  lat: Float!
  lng: Float!
  address: String!
  directions: String!
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  title_ASC
  title_DESC
  id_ASC
  id_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  address_ASC
  address_DESC
  directions_ASC
  directions_DESC
}

type LocationPreviousValues {
  title: String
  id: ID!
  lat: Float!
  lng: Float!
  address: String!
  directions: String!
}

input LocationScalarWhereInput {
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  directions: String
  directions_not: String
  directions_in: [String!]
  directions_not_in: [String!]
  directions_lt: String
  directions_lte: String
  directions_gt: String
  directions_gte: String
  directions_contains: String
  directions_not_contains: String
  directions_starts_with: String
  directions_not_starts_with: String
  directions_ends_with: String
  directions_not_ends_with: String
  AND: [LocationScalarWhereInput!]
  OR: [LocationScalarWhereInput!]
  NOT: [LocationScalarWhereInput!]
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateDataInput {
  title: String
  lat: Float
  lng: Float
  neighbourHood: NeighbourhoodUpdateOneWithoutLocationsInput
  address: String
  directions: String
}

input LocationUpdateInput {
  title: String
  lat: Float
  lng: Float
  neighbourHood: NeighbourhoodUpdateOneWithoutLocationsInput
  address: String
  directions: String
}

input LocationUpdateManyDataInput {
  title: String
  lat: Float
  lng: Float
  address: String
  directions: String
}

input LocationUpdateManyInput {
  create: [LocationCreateInput!]
  update: [LocationUpdateWithWhereUniqueNestedInput!]
  upsert: [LocationUpsertWithWhereUniqueNestedInput!]
  delete: [LocationWhereUniqueInput!]
  connect: [LocationWhereUniqueInput!]
  set: [LocationWhereUniqueInput!]
  disconnect: [LocationWhereUniqueInput!]
  deleteMany: [LocationScalarWhereInput!]
  updateMany: [LocationUpdateManyWithWhereNestedInput!]
}

input LocationUpdateManyMutationInput {
  title: String
  lat: Float
  lng: Float
  address: String
  directions: String
}

input LocationUpdateManyWithoutNeighbourHoodInput {
  create: [LocationCreateWithoutNeighbourHoodInput!]
  delete: [LocationWhereUniqueInput!]
  connect: [LocationWhereUniqueInput!]
  set: [LocationWhereUniqueInput!]
  disconnect: [LocationWhereUniqueInput!]
  update: [LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput!]
  upsert: [LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput!]
  deleteMany: [LocationScalarWhereInput!]
  updateMany: [LocationUpdateManyWithWhereNestedInput!]
}

input LocationUpdateManyWithWhereNestedInput {
  where: LocationScalarWhereInput!
  data: LocationUpdateManyDataInput!
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateOneRequiredInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  connect: LocationWhereUniqueInput
}

input LocationUpdateWithoutNeighbourHoodDataInput {
  title: String
  lat: Float
  lng: Float
  address: String
  directions: String
}

input LocationUpdateWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput!
  data: LocationUpdateDataInput!
}

input LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput {
  where: LocationWhereUniqueInput!
  data: LocationUpdateWithoutNeighbourHoodDataInput!
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationUpsertWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput!
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput {
  where: LocationWhereUniqueInput!
  update: LocationUpdateWithoutNeighbourHoodDataInput!
  create: LocationCreateWithoutNeighbourHoodInput!
}

input LocationWhereInput {
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  neighbourHood: NeighbourhoodWhereInput
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  directions: String
  directions_not: String
  directions_in: [String!]
  directions_not_in: [String!]
  directions_lt: String
  directions_lte: String
  directions_gt: String
  directions_gte: String
  directions_contains: String
  directions_not_contains: String
  directions_starts_with: String
  directions_not_starts_with: String
  directions_ends_with: String
  directions_not_ends_with: String
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type MenuItem {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  shortDescription: String!
  title: String!
  description: String!
  pricing: Pricing!
  pictures(where: PictureWhereInput, orderBy: PictureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Picture!]
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
}

type MenuItemConnection {
  pageInfo: PageInfo!
  edges: [MenuItemEdge]!
  aggregate: AggregateMenuItem!
}

input MenuItemCreateInput {
  id: ID
  shortDescription: String!
  title: String!
  description: String!
  pricing: PricingCreateOneInput!
  pictures: PictureCreateManyInput
  reviews: ReviewCreateManyInput
}

input MenuItemCreateManyInput {
  create: [MenuItemCreateInput!]
  connect: [MenuItemWhereUniqueInput!]
}

type MenuItemEdge {
  node: MenuItem!
  cursor: String!
}

enum MenuItemOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  shortDescription_ASC
  shortDescription_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
}

type MenuItemPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  shortDescription: String!
  title: String!
  description: String!
}

input MenuItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  shortDescription: String
  shortDescription_not: String
  shortDescription_in: [String!]
  shortDescription_not_in: [String!]
  shortDescription_lt: String
  shortDescription_lte: String
  shortDescription_gt: String
  shortDescription_gte: String
  shortDescription_contains: String
  shortDescription_not_contains: String
  shortDescription_starts_with: String
  shortDescription_not_starts_with: String
  shortDescription_ends_with: String
  shortDescription_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [MenuItemScalarWhereInput!]
  OR: [MenuItemScalarWhereInput!]
  NOT: [MenuItemScalarWhereInput!]
}

type MenuItemSubscriptionPayload {
  mutation: MutationType!
  node: MenuItem
  updatedFields: [String!]
  previousValues: MenuItemPreviousValues
}

input MenuItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuItemWhereInput
  AND: [MenuItemSubscriptionWhereInput!]
  OR: [MenuItemSubscriptionWhereInput!]
  NOT: [MenuItemSubscriptionWhereInput!]
}

input MenuItemUpdateDataInput {
  shortDescription: String
  title: String
  description: String
  pricing: PricingUpdateOneRequiredInput
  pictures: PictureUpdateManyInput
  reviews: ReviewUpdateManyInput
}

input MenuItemUpdateInput {
  shortDescription: String
  title: String
  description: String
  pricing: PricingUpdateOneRequiredInput
  pictures: PictureUpdateManyInput
  reviews: ReviewUpdateManyInput
}

input MenuItemUpdateManyDataInput {
  shortDescription: String
  title: String
  description: String
}

input MenuItemUpdateManyInput {
  create: [MenuItemCreateInput!]
  update: [MenuItemUpdateWithWhereUniqueNestedInput!]
  upsert: [MenuItemUpsertWithWhereUniqueNestedInput!]
  delete: [MenuItemWhereUniqueInput!]
  connect: [MenuItemWhereUniqueInput!]
  set: [MenuItemWhereUniqueInput!]
  disconnect: [MenuItemWhereUniqueInput!]
  deleteMany: [MenuItemScalarWhereInput!]
  updateMany: [MenuItemUpdateManyWithWhereNestedInput!]
}

input MenuItemUpdateManyMutationInput {
  shortDescription: String
  title: String
  description: String
}

input MenuItemUpdateManyWithWhereNestedInput {
  where: MenuItemScalarWhereInput!
  data: MenuItemUpdateManyDataInput!
}

input MenuItemUpdateWithWhereUniqueNestedInput {
  where: MenuItemWhereUniqueInput!
  data: MenuItemUpdateDataInput!
}

input MenuItemUpsertWithWhereUniqueNestedInput {
  where: MenuItemWhereUniqueInput!
  update: MenuItemUpdateDataInput!
  create: MenuItemCreateInput!
}

input MenuItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  shortDescription: String
  shortDescription_not: String
  shortDescription_in: [String!]
  shortDescription_not_in: [String!]
  shortDescription_lt: String
  shortDescription_lte: String
  shortDescription_gt: String
  shortDescription_gte: String
  shortDescription_contains: String
  shortDescription_not_contains: String
  shortDescription_starts_with: String
  shortDescription_not_starts_with: String
  shortDescription_ends_with: String
  shortDescription_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  pricing: PricingWhereInput
  pictures_every: PictureWhereInput
  pictures_some: PictureWhereInput
  pictures_none: PictureWhereInput
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  AND: [MenuItemWhereInput!]
  OR: [MenuItemWhereInput!]
  NOT: [MenuItemWhereInput!]
}

input MenuItemWhereUniqueInput {
  id: ID
}

type Message {
  id: ID!
  createdAt: DateTime!
  from: User!
  to: User!
  deliveredAt: DateTime!
  readAt: DateTime!
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]!
  aggregate: AggregateMessage!
}

input MessageCreateInput {
  id: ID
  from: UserCreateOneWithoutSentMessagesInput!
  to: UserCreateOneWithoutReceivedMessagesInput!
  deliveredAt: DateTime!
  readAt: DateTime!
}

input MessageCreateManyWithoutFromInput {
  create: [MessageCreateWithoutFromInput!]
  connect: [MessageWhereUniqueInput!]
}

input MessageCreateManyWithoutToInput {
  create: [MessageCreateWithoutToInput!]
  connect: [MessageWhereUniqueInput!]
}

input MessageCreateWithoutFromInput {
  id: ID
  to: UserCreateOneWithoutReceivedMessagesInput!
  deliveredAt: DateTime!
  readAt: DateTime!
}

input MessageCreateWithoutToInput {
  id: ID
  from: UserCreateOneWithoutSentMessagesInput!
  deliveredAt: DateTime!
  readAt: DateTime!
}

type MessageEdge {
  node: Message!
  cursor: String!
}

enum MessageOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  deliveredAt_ASC
  deliveredAt_DESC
  readAt_ASC
  readAt_DESC
}

type MessagePreviousValues {
  id: ID!
  createdAt: DateTime!
  deliveredAt: DateTime!
  readAt: DateTime!
}

input MessageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  deliveredAt: DateTime
  deliveredAt_not: DateTime
  deliveredAt_in: [DateTime!]
  deliveredAt_not_in: [DateTime!]
  deliveredAt_lt: DateTime
  deliveredAt_lte: DateTime
  deliveredAt_gt: DateTime
  deliveredAt_gte: DateTime
  readAt: DateTime
  readAt_not: DateTime
  readAt_in: [DateTime!]
  readAt_not_in: [DateTime!]
  readAt_lt: DateTime
  readAt_lte: DateTime
  readAt_gt: DateTime
  readAt_gte: DateTime
  AND: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
}

type MessageSubscriptionPayload {
  mutation: MutationType!
  node: Message
  updatedFields: [String!]
  previousValues: MessagePreviousValues
}

input MessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MessageWhereInput
  AND: [MessageSubscriptionWhereInput!]
  OR: [MessageSubscriptionWhereInput!]
  NOT: [MessageSubscriptionWhereInput!]
}

input MessageUpdateInput {
  from: UserUpdateOneRequiredWithoutSentMessagesInput
  to: UserUpdateOneRequiredWithoutReceivedMessagesInput
  deliveredAt: DateTime
  readAt: DateTime
}

input MessageUpdateManyDataInput {
  deliveredAt: DateTime
  readAt: DateTime
}

input MessageUpdateManyMutationInput {
  deliveredAt: DateTime
  readAt: DateTime
}

input MessageUpdateManyWithoutFromInput {
  create: [MessageCreateWithoutFromInput!]
  delete: [MessageWhereUniqueInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutFromInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutFromInput!]
  deleteMany: [MessageScalarWhereInput!]
  updateMany: [MessageUpdateManyWithWhereNestedInput!]
}

input MessageUpdateManyWithoutToInput {
  create: [MessageCreateWithoutToInput!]
  delete: [MessageWhereUniqueInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutToInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutToInput!]
  deleteMany: [MessageScalarWhereInput!]
  updateMany: [MessageUpdateManyWithWhereNestedInput!]
}

input MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput!
  data: MessageUpdateManyDataInput!
}

input MessageUpdateWithoutFromDataInput {
  to: UserUpdateOneRequiredWithoutReceivedMessagesInput
  deliveredAt: DateTime
  readAt: DateTime
}

input MessageUpdateWithoutToDataInput {
  from: UserUpdateOneRequiredWithoutSentMessagesInput
  deliveredAt: DateTime
  readAt: DateTime
}

input MessageUpdateWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateWithoutFromDataInput!
}

input MessageUpdateWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateWithoutToDataInput!
}

input MessageUpsertWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateWithoutFromDataInput!
  create: MessageCreateWithoutFromInput!
}

input MessageUpsertWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateWithoutToDataInput!
  create: MessageCreateWithoutToInput!
}

input MessageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  from: UserWhereInput
  to: UserWhereInput
  deliveredAt: DateTime
  deliveredAt_not: DateTime
  deliveredAt_in: [DateTime!]
  deliveredAt_not_in: [DateTime!]
  deliveredAt_lt: DateTime
  deliveredAt_lte: DateTime
  deliveredAt_gt: DateTime
  deliveredAt_gte: DateTime
  readAt: DateTime
  readAt_not: DateTime
  readAt_in: [DateTime!]
  readAt_not_in: [DateTime!]
  readAt_lt: DateTime
  readAt_lte: DateTime
  readAt_gt: DateTime
  readAt_gte: DateTime
  AND: [MessageWhereInput!]
  OR: [MessageWhereInput!]
  NOT: [MessageWhereInput!]
}

input MessageWhereUniqueInput {
  id: ID
}

type Mutation {
  createCity(data: CityCreateInput!): City!
  updateCity(data: CityUpdateInput!, where: CityWhereUniqueInput!): City
  updateManyCities(data: CityUpdateManyMutationInput!, where: CityWhereInput): BatchPayload!
  upsertCity(where: CityWhereUniqueInput!, create: CityCreateInput!, update: CityUpdateInput!): City!
  deleteCity(where: CityWhereUniqueInput!): City
  deleteManyCities(where: CityWhereInput): BatchPayload!
  createCreditCardInformation(data: CreditCardInformationCreateInput!): CreditCardInformation!
  updateCreditCardInformation(data: CreditCardInformationUpdateInput!, where: CreditCardInformationWhereUniqueInput!): CreditCardInformation
  updateManyCreditCardInformations(data: CreditCardInformationUpdateManyMutationInput!, where: CreditCardInformationWhereInput): BatchPayload!
  upsertCreditCardInformation(where: CreditCardInformationWhereUniqueInput!, create: CreditCardInformationCreateInput!, update: CreditCardInformationUpdateInput!): CreditCardInformation!
  deleteCreditCardInformation(where: CreditCardInformationWhereUniqueInput!): CreditCardInformation
  deleteManyCreditCardInformations(where: CreditCardInformationWhereInput): BatchPayload!
  createDebitCardInformation(data: DebitCardInformationCreateInput!): DebitCardInformation!
  updateDebitCardInformation(data: DebitCardInformationUpdateInput!, where: DebitCardInformationWhereUniqueInput!): DebitCardInformation
  updateManyDebitCardInformations(data: DebitCardInformationUpdateManyMutationInput!, where: DebitCardInformationWhereInput): BatchPayload!
  upsertDebitCardInformation(where: DebitCardInformationWhereUniqueInput!, create: DebitCardInformationCreateInput!, update: DebitCardInformationUpdateInput!): DebitCardInformation!
  deleteDebitCardInformation(where: DebitCardInformationWhereUniqueInput!): DebitCardInformation
  deleteManyDebitCardInformations(where: DebitCardInformationWhereInput): BatchPayload!
  createExperience(data: ExperienceCreateInput!): Experience!
  updateExperience(data: ExperienceUpdateInput!, where: ExperienceWhereUniqueInput!): Experience
  updateManyExperiences(data: ExperienceUpdateManyMutationInput!, where: ExperienceWhereInput): BatchPayload!
  upsertExperience(where: ExperienceWhereUniqueInput!, create: ExperienceCreateInput!, update: ExperienceUpdateInput!): Experience!
  deleteExperience(where: ExperienceWhereUniqueInput!): Experience
  deleteManyExperiences(where: ExperienceWhereInput): BatchPayload!
  createExperienceCategory(data: ExperienceCategoryCreateInput!): ExperienceCategory!
  updateExperienceCategory(data: ExperienceCategoryUpdateInput!, where: ExperienceCategoryWhereUniqueInput!): ExperienceCategory
  updateManyExperienceCategories(data: ExperienceCategoryUpdateManyMutationInput!, where: ExperienceCategoryWhereInput): BatchPayload!
  upsertExperienceCategory(where: ExperienceCategoryWhereUniqueInput!, create: ExperienceCategoryCreateInput!, update: ExperienceCategoryUpdateInput!): ExperienceCategory!
  deleteExperienceCategory(where: ExperienceCategoryWhereUniqueInput!): ExperienceCategory
  deleteManyExperienceCategories(where: ExperienceCategoryWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createMenuItem(data: MenuItemCreateInput!): MenuItem!
  updateMenuItem(data: MenuItemUpdateInput!, where: MenuItemWhereUniqueInput!): MenuItem
  updateManyMenuItems(data: MenuItemUpdateManyMutationInput!, where: MenuItemWhereInput): BatchPayload!
  upsertMenuItem(where: MenuItemWhereUniqueInput!, create: MenuItemCreateInput!, update: MenuItemUpdateInput!): MenuItem!
  deleteMenuItem(where: MenuItemWhereUniqueInput!): MenuItem
  deleteManyMenuItems(where: MenuItemWhereInput): BatchPayload!
  createMessage(data: MessageCreateInput!): Message!
  updateMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
  updateManyMessages(data: MessageUpdateManyMutationInput!, where: MessageWhereInput): BatchPayload!
  upsertMessage(where: MessageWhereUniqueInput!, create: MessageCreateInput!, update: MessageUpdateInput!): Message!
  deleteMessage(where: MessageWhereUniqueInput!): Message
  deleteManyMessages(where: MessageWhereInput): BatchPayload!
  createNeighbourhood(data: NeighbourhoodCreateInput!): Neighbourhood!
  updateNeighbourhood(data: NeighbourhoodUpdateInput!, where: NeighbourhoodWhereUniqueInput!): Neighbourhood
  updateManyNeighbourhoods(data: NeighbourhoodUpdateManyMutationInput!, where: NeighbourhoodWhereInput): BatchPayload!
  upsertNeighbourhood(where: NeighbourhoodWhereUniqueInput!, create: NeighbourhoodCreateInput!, update: NeighbourhoodUpdateInput!): Neighbourhood!
  deleteNeighbourhood(where: NeighbourhoodWhereUniqueInput!): Neighbourhood
  deleteManyNeighbourhoods(where: NeighbourhoodWhereInput): BatchPayload!
  createNotification(data: NotificationCreateInput!): Notification!
  updateNotification(data: NotificationUpdateInput!, where: NotificationWhereUniqueInput!): Notification
  updateManyNotifications(data: NotificationUpdateManyMutationInput!, where: NotificationWhereInput): BatchPayload!
  upsertNotification(where: NotificationWhereUniqueInput!, create: NotificationCreateInput!, update: NotificationUpdateInput!): Notification!
  deleteNotification(where: NotificationWhereUniqueInput!): Notification
  deleteManyNotifications(where: NotificationWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createPaymentAccount(data: PaymentAccountCreateInput!): PaymentAccount!
  updatePaymentAccount(data: PaymentAccountUpdateInput!, where: PaymentAccountWhereUniqueInput!): PaymentAccount
  updateManyPaymentAccounts(data: PaymentAccountUpdateManyMutationInput!, where: PaymentAccountWhereInput): BatchPayload!
  upsertPaymentAccount(where: PaymentAccountWhereUniqueInput!, create: PaymentAccountCreateInput!, update: PaymentAccountUpdateInput!): PaymentAccount!
  deletePaymentAccount(where: PaymentAccountWhereUniqueInput!): PaymentAccount
  deleteManyPaymentAccounts(where: PaymentAccountWhereInput): BatchPayload!
  createPaypalInformation(data: PaypalInformationCreateInput!): PaypalInformation!
  updatePaypalInformation(data: PaypalInformationUpdateInput!, where: PaypalInformationWhereUniqueInput!): PaypalInformation
  updateManyPaypalInformations(data: PaypalInformationUpdateManyMutationInput!, where: PaypalInformationWhereInput): BatchPayload!
  upsertPaypalInformation(where: PaypalInformationWhereUniqueInput!, create: PaypalInformationCreateInput!, update: PaypalInformationUpdateInput!): PaypalInformation!
  deletePaypalInformation(where: PaypalInformationWhereUniqueInput!): PaypalInformation
  deleteManyPaypalInformations(where: PaypalInformationWhereInput): BatchPayload!
  createPaytmInformation(data: PaytmInformationCreateInput!): PaytmInformation!
  updatePaytmInformation(data: PaytmInformationUpdateInput!, where: PaytmInformationWhereUniqueInput!): PaytmInformation
  updateManyPaytmInformations(data: PaytmInformationUpdateManyMutationInput!, where: PaytmInformationWhereInput): BatchPayload!
  upsertPaytmInformation(where: PaytmInformationWhereUniqueInput!, create: PaytmInformationCreateInput!, update: PaytmInformationUpdateInput!): PaytmInformation!
  deletePaytmInformation(where: PaytmInformationWhereUniqueInput!): PaytmInformation
  deleteManyPaytmInformations(where: PaytmInformationWhereInput): BatchPayload!
  createPicture(data: PictureCreateInput!): Picture!
  updatePicture(data: PictureUpdateInput!, where: PictureWhereUniqueInput!): Picture
  updateManyPictures(data: PictureUpdateManyMutationInput!, where: PictureWhereInput): BatchPayload!
  upsertPicture(where: PictureWhereUniqueInput!, create: PictureCreateInput!, update: PictureUpdateInput!): Picture!
  deletePicture(where: PictureWhereUniqueInput!): Picture
  deleteManyPictures(where: PictureWhereInput): BatchPayload!
  createPolicies(data: PoliciesCreateInput!): Policies!
  updatePolicies(data: PoliciesUpdateInput!, where: PoliciesWhereUniqueInput!): Policies
  updateManyPolicieses(data: PoliciesUpdateManyMutationInput!, where: PoliciesWhereInput): BatchPayload!
  upsertPolicies(where: PoliciesWhereUniqueInput!, create: PoliciesCreateInput!, update: PoliciesUpdateInput!): Policies!
  deletePolicies(where: PoliciesWhereUniqueInput!): Policies
  deleteManyPolicieses(where: PoliciesWhereInput): BatchPayload!
  createPricing(data: PricingCreateInput!): Pricing!
  updatePricing(data: PricingUpdateInput!, where: PricingWhereUniqueInput!): Pricing
  updateManyPricings(data: PricingUpdateManyMutationInput!, where: PricingWhereInput): BatchPayload!
  upsertPricing(where: PricingWhereUniqueInput!, create: PricingCreateInput!, update: PricingUpdateInput!): Pricing!
  deletePricing(where: PricingWhereUniqueInput!): Pricing
  deleteManyPricings(where: PricingWhereInput): BatchPayload!
  createRestaurant(data: RestaurantCreateInput!): Restaurant!
  updateRestaurant(data: RestaurantUpdateInput!, where: RestaurantWhereUniqueInput!): Restaurant
  updateManyRestaurants(data: RestaurantUpdateManyMutationInput!, where: RestaurantWhereInput): BatchPayload!
  upsertRestaurant(where: RestaurantWhereUniqueInput!, create: RestaurantCreateInput!, update: RestaurantUpdateInput!): Restaurant!
  deleteRestaurant(where: RestaurantWhereUniqueInput!): Restaurant
  deleteManyRestaurants(where: RestaurantWhereInput): BatchPayload!
  createReview(data: ReviewCreateInput!): Review!
  updateReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateManyReviews(data: ReviewUpdateManyMutationInput!, where: ReviewWhereInput): BatchPayload!
  upsertReview(where: ReviewWhereUniqueInput!, create: ReviewCreateInput!, update: ReviewUpdateInput!): Review!
  deleteReview(where: ReviewWhereUniqueInput!): Review
  deleteManyReviews(where: ReviewWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Neighbourhood {
  id: ID!
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location!]
  name: String!
  slug: String!
  homePreview: Picture
  city: City!
  featured: Boolean!
  popularity: Int!
}

type NeighbourhoodConnection {
  pageInfo: PageInfo!
  edges: [NeighbourhoodEdge]!
  aggregate: AggregateNeighbourhood!
}

input NeighbourhoodCreateInput {
  id: ID
  locations: LocationCreateManyWithoutNeighbourHoodInput
  name: String!
  slug: String!
  homePreview: PictureCreateOneInput
  city: CityCreateOneWithoutNeighbourhoodsInput!
  featured: Boolean!
  popularity: Int!
}

input NeighbourhoodCreateManyWithoutCityInput {
  create: [NeighbourhoodCreateWithoutCityInput!]
  connect: [NeighbourhoodWhereUniqueInput!]
}

input NeighbourhoodCreateOneWithoutLocationsInput {
  create: NeighbourhoodCreateWithoutLocationsInput
  connect: NeighbourhoodWhereUniqueInput
}

input NeighbourhoodCreateWithoutCityInput {
  id: ID
  locations: LocationCreateManyWithoutNeighbourHoodInput
  name: String!
  slug: String!
  homePreview: PictureCreateOneInput
  featured: Boolean!
  popularity: Int!
}

input NeighbourhoodCreateWithoutLocationsInput {
  id: ID
  name: String!
  slug: String!
  homePreview: PictureCreateOneInput
  city: CityCreateOneWithoutNeighbourhoodsInput!
  featured: Boolean!
  popularity: Int!
}

type NeighbourhoodEdge {
  node: Neighbourhood!
  cursor: String!
}

enum NeighbourhoodOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  slug_ASC
  slug_DESC
  featured_ASC
  featured_DESC
  popularity_ASC
  popularity_DESC
}

type NeighbourhoodPreviousValues {
  id: ID!
  name: String!
  slug: String!
  featured: Boolean!
  popularity: Int!
}

input NeighbourhoodScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  featured: Boolean
  featured_not: Boolean
  popularity: Int
  popularity_not: Int
  popularity_in: [Int!]
  popularity_not_in: [Int!]
  popularity_lt: Int
  popularity_lte: Int
  popularity_gt: Int
  popularity_gte: Int
  AND: [NeighbourhoodScalarWhereInput!]
  OR: [NeighbourhoodScalarWhereInput!]
  NOT: [NeighbourhoodScalarWhereInput!]
}

type NeighbourhoodSubscriptionPayload {
  mutation: MutationType!
  node: Neighbourhood
  updatedFields: [String!]
  previousValues: NeighbourhoodPreviousValues
}

input NeighbourhoodSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NeighbourhoodWhereInput
  AND: [NeighbourhoodSubscriptionWhereInput!]
  OR: [NeighbourhoodSubscriptionWhereInput!]
  NOT: [NeighbourhoodSubscriptionWhereInput!]
}

input NeighbourhoodUpdateInput {
  locations: LocationUpdateManyWithoutNeighbourHoodInput
  name: String
  slug: String
  homePreview: PictureUpdateOneInput
  city: CityUpdateOneRequiredWithoutNeighbourhoodsInput
  featured: Boolean
  popularity: Int
}

input NeighbourhoodUpdateManyDataInput {
  name: String
  slug: String
  featured: Boolean
  popularity: Int
}

input NeighbourhoodUpdateManyMutationInput {
  name: String
  slug: String
  featured: Boolean
  popularity: Int
}

input NeighbourhoodUpdateManyWithoutCityInput {
  create: [NeighbourhoodCreateWithoutCityInput!]
  delete: [NeighbourhoodWhereUniqueInput!]
  connect: [NeighbourhoodWhereUniqueInput!]
  set: [NeighbourhoodWhereUniqueInput!]
  disconnect: [NeighbourhoodWhereUniqueInput!]
  update: [NeighbourhoodUpdateWithWhereUniqueWithoutCityInput!]
  upsert: [NeighbourhoodUpsertWithWhereUniqueWithoutCityInput!]
  deleteMany: [NeighbourhoodScalarWhereInput!]
  updateMany: [NeighbourhoodUpdateManyWithWhereNestedInput!]
}

input NeighbourhoodUpdateManyWithWhereNestedInput {
  where: NeighbourhoodScalarWhereInput!
  data: NeighbourhoodUpdateManyDataInput!
}

input NeighbourhoodUpdateOneWithoutLocationsInput {
  create: NeighbourhoodCreateWithoutLocationsInput
  update: NeighbourhoodUpdateWithoutLocationsDataInput
  upsert: NeighbourhoodUpsertWithoutLocationsInput
  delete: Boolean
  disconnect: Boolean
  connect: NeighbourhoodWhereUniqueInput
}

input NeighbourhoodUpdateWithoutCityDataInput {
  locations: LocationUpdateManyWithoutNeighbourHoodInput
  name: String
  slug: String
  homePreview: PictureUpdateOneInput
  featured: Boolean
  popularity: Int
}

input NeighbourhoodUpdateWithoutLocationsDataInput {
  name: String
  slug: String
  homePreview: PictureUpdateOneInput
  city: CityUpdateOneRequiredWithoutNeighbourhoodsInput
  featured: Boolean
  popularity: Int
}

input NeighbourhoodUpdateWithWhereUniqueWithoutCityInput {
  where: NeighbourhoodWhereUniqueInput!
  data: NeighbourhoodUpdateWithoutCityDataInput!
}

input NeighbourhoodUpsertWithoutLocationsInput {
  update: NeighbourhoodUpdateWithoutLocationsDataInput!
  create: NeighbourhoodCreateWithoutLocationsInput!
}

input NeighbourhoodUpsertWithWhereUniqueWithoutCityInput {
  where: NeighbourhoodWhereUniqueInput!
  update: NeighbourhoodUpdateWithoutCityDataInput!
  create: NeighbourhoodCreateWithoutCityInput!
}

input NeighbourhoodWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  locations_every: LocationWhereInput
  locations_some: LocationWhereInput
  locations_none: LocationWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  homePreview: PictureWhereInput
  city: CityWhereInput
  featured: Boolean
  featured_not: Boolean
  popularity: Int
  popularity_not: Int
  popularity_in: [Int!]
  popularity_not_in: [Int!]
  popularity_lt: Int
  popularity_lte: Int
  popularity_gt: Int
  popularity_gte: Int
  AND: [NeighbourhoodWhereInput!]
  OR: [NeighbourhoodWhereInput!]
  NOT: [NeighbourhoodWhereInput!]
}

input NeighbourhoodWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type Notification {
  id: ID!
  createdAt: DateTime!
  type: NOTIFICATION_TYPE
  user: User!
  link: String!
  readDate: DateTime!
}

enum NOTIFICATION_TYPE {
  OFFER
  INSTANT_BOOK
  RESPONSIVENESS
  NEW_AMENITIES
  HOUSE_RULES
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]!
  aggregate: AggregateNotification!
}

input NotificationCreateInput {
  id: ID
  type: NOTIFICATION_TYPE
  user: UserCreateOneWithoutNotificationsInput!
  link: String!
  readDate: DateTime!
}

input NotificationCreateManyWithoutUserInput {
  create: [NotificationCreateWithoutUserInput!]
  connect: [NotificationWhereUniqueInput!]
}

input NotificationCreateWithoutUserInput {
  id: ID
  type: NOTIFICATION_TYPE
  link: String!
  readDate: DateTime!
}

type NotificationEdge {
  node: Notification!
  cursor: String!
}

enum NotificationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  type_ASC
  type_DESC
  link_ASC
  link_DESC
  readDate_ASC
  readDate_DESC
}

type NotificationPreviousValues {
  id: ID!
  createdAt: DateTime!
  type: NOTIFICATION_TYPE
  link: String!
  readDate: DateTime!
}

input NotificationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  type: NOTIFICATION_TYPE
  type_not: NOTIFICATION_TYPE
  type_in: [NOTIFICATION_TYPE!]
  type_not_in: [NOTIFICATION_TYPE!]
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  readDate: DateTime
  readDate_not: DateTime
  readDate_in: [DateTime!]
  readDate_not_in: [DateTime!]
  readDate_lt: DateTime
  readDate_lte: DateTime
  readDate_gt: DateTime
  readDate_gte: DateTime
  AND: [NotificationScalarWhereInput!]
  OR: [NotificationScalarWhereInput!]
  NOT: [NotificationScalarWhereInput!]
}

type NotificationSubscriptionPayload {
  mutation: MutationType!
  node: Notification
  updatedFields: [String!]
  previousValues: NotificationPreviousValues
}

input NotificationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NotificationWhereInput
  AND: [NotificationSubscriptionWhereInput!]
  OR: [NotificationSubscriptionWhereInput!]
  NOT: [NotificationSubscriptionWhereInput!]
}

input NotificationUpdateInput {
  type: NOTIFICATION_TYPE
  user: UserUpdateOneRequiredWithoutNotificationsInput
  link: String
  readDate: DateTime
}

input NotificationUpdateManyDataInput {
  type: NOTIFICATION_TYPE
  link: String
  readDate: DateTime
}

input NotificationUpdateManyMutationInput {
  type: NOTIFICATION_TYPE
  link: String
  readDate: DateTime
}

input NotificationUpdateManyWithoutUserInput {
  create: [NotificationCreateWithoutUserInput!]
  delete: [NotificationWhereUniqueInput!]
  connect: [NotificationWhereUniqueInput!]
  set: [NotificationWhereUniqueInput!]
  disconnect: [NotificationWhereUniqueInput!]
  update: [NotificationUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [NotificationUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [NotificationScalarWhereInput!]
  updateMany: [NotificationUpdateManyWithWhereNestedInput!]
}

input NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput!
  data: NotificationUpdateManyDataInput!
}

input NotificationUpdateWithoutUserDataInput {
  type: NOTIFICATION_TYPE
  link: String
  readDate: DateTime
}

input NotificationUpdateWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput!
  data: NotificationUpdateWithoutUserDataInput!
}

input NotificationUpsertWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput!
  update: NotificationUpdateWithoutUserDataInput!
  create: NotificationCreateWithoutUserInput!
}

input NotificationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  type: NOTIFICATION_TYPE
  type_not: NOTIFICATION_TYPE
  type_in: [NOTIFICATION_TYPE!]
  type_not_in: [NOTIFICATION_TYPE!]
  user: UserWhereInput
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  readDate: DateTime
  readDate_not: DateTime
  readDate_in: [DateTime!]
  readDate_not_in: [DateTime!]
  readDate_lt: DateTime
  readDate_lte: DateTime
  readDate_gt: DateTime
  readDate_gte: DateTime
  AND: [NotificationWhereInput!]
  OR: [NotificationWhereInput!]
  NOT: [NotificationWhereInput!]
}

input NotificationWhereUniqueInput {
  id: ID
}

type Order {
  id: ID!
  createdAt: DateTime!
  bookee: User!
  restaurant: Restaurant!
  startDate: DateTime!
  endDate: DateTime!
  payment: Payment!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  bookee: UserCreateOneWithoutOrdersInput!
  restaurant: RestaurantCreateOneWithoutOrdersInput!
  startDate: DateTime!
  endDate: DateTime!
  payment: PaymentCreateOneWithoutOrderInput!
}

input OrderCreateManyWithoutBookeeInput {
  create: [OrderCreateWithoutBookeeInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateManyWithoutRestaurantInput {
  create: [OrderCreateWithoutRestaurantInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateOneInput {
  create: OrderCreateInput
  connect: OrderWhereUniqueInput
}

input OrderCreateOneWithoutPaymentInput {
  create: OrderCreateWithoutPaymentInput
  connect: OrderWhereUniqueInput
}

input OrderCreateWithoutBookeeInput {
  id: ID
  restaurant: RestaurantCreateOneWithoutOrdersInput!
  startDate: DateTime!
  endDate: DateTime!
  payment: PaymentCreateOneWithoutOrderInput!
}

input OrderCreateWithoutPaymentInput {
  id: ID
  bookee: UserCreateOneWithoutOrdersInput!
  restaurant: RestaurantCreateOneWithoutOrdersInput!
  startDate: DateTime!
  endDate: DateTime!
}

input OrderCreateWithoutRestaurantInput {
  id: ID
  bookee: UserCreateOneWithoutOrdersInput!
  startDate: DateTime!
  endDate: DateTime!
  payment: PaymentCreateOneWithoutOrderInput!
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
}

type OrderPreviousValues {
  id: ID!
  createdAt: DateTime!
  startDate: DateTime!
  endDate: DateTime!
}

input OrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  AND: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateDataInput {
  bookee: UserUpdateOneRequiredWithoutOrdersInput
  restaurant: RestaurantUpdateOneRequiredWithoutOrdersInput
  startDate: DateTime
  endDate: DateTime
  payment: PaymentUpdateOneRequiredWithoutOrderInput
}

input OrderUpdateInput {
  bookee: UserUpdateOneRequiredWithoutOrdersInput
  restaurant: RestaurantUpdateOneRequiredWithoutOrdersInput
  startDate: DateTime
  endDate: DateTime
  payment: PaymentUpdateOneRequiredWithoutOrderInput
}

input OrderUpdateManyDataInput {
  startDate: DateTime
  endDate: DateTime
}

input OrderUpdateManyMutationInput {
  startDate: DateTime
  endDate: DateTime
}

input OrderUpdateManyWithoutBookeeInput {
  create: [OrderCreateWithoutBookeeInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutBookeeInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutBookeeInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithoutRestaurantInput {
  create: [OrderCreateWithoutRestaurantInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutRestaurantInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutRestaurantInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateOneRequiredInput {
  create: OrderCreateInput
  update: OrderUpdateDataInput
  upsert: OrderUpsertNestedInput
  connect: OrderWhereUniqueInput
}

input OrderUpdateOneRequiredWithoutPaymentInput {
  create: OrderCreateWithoutPaymentInput
  update: OrderUpdateWithoutPaymentDataInput
  upsert: OrderUpsertWithoutPaymentInput
  connect: OrderWhereUniqueInput
}

input OrderUpdateWithoutBookeeDataInput {
  restaurant: RestaurantUpdateOneRequiredWithoutOrdersInput
  startDate: DateTime
  endDate: DateTime
  payment: PaymentUpdateOneRequiredWithoutOrderInput
}

input OrderUpdateWithoutPaymentDataInput {
  bookee: UserUpdateOneRequiredWithoutOrdersInput
  restaurant: RestaurantUpdateOneRequiredWithoutOrdersInput
  startDate: DateTime
  endDate: DateTime
}

input OrderUpdateWithoutRestaurantDataInput {
  bookee: UserUpdateOneRequiredWithoutOrdersInput
  startDate: DateTime
  endDate: DateTime
  payment: PaymentUpdateOneRequiredWithoutOrderInput
}

input OrderUpdateWithWhereUniqueWithoutBookeeInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutBookeeDataInput!
}

input OrderUpdateWithWhereUniqueWithoutRestaurantInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutRestaurantDataInput!
}

input OrderUpsertNestedInput {
  update: OrderUpdateDataInput!
  create: OrderCreateInput!
}

input OrderUpsertWithoutPaymentInput {
  update: OrderUpdateWithoutPaymentDataInput!
  create: OrderCreateWithoutPaymentInput!
}

input OrderUpsertWithWhereUniqueWithoutBookeeInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutBookeeDataInput!
  create: OrderCreateWithoutBookeeInput!
}

input OrderUpsertWithWhereUniqueWithoutRestaurantInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutRestaurantDataInput!
  create: OrderCreateWithoutRestaurantInput!
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  bookee: UserWhereInput
  restaurant: RestaurantWhereInput
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  payment: PaymentWhereInput
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  createdAt: DateTime!
  serviceFee: Float!
  restaurantPrice: Float!
  totalPrice: Float!
  order: Order!
  paymentMethod: PaymentAccount!
}

enum PAYMENT_PROVIDER {
  PAYPAL
  PAYTM
  CREDIT_CARD
  DEBIT_CARD
}

type PaymentAccount {
  id: ID!
  createdAt: DateTime!
  type: PAYMENT_PROVIDER
  user: User!
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
  paypal: PaypalInformation
  paytm: PaytmInformation
  creditcard: CreditCardInformation
  debitcard: DebitCardInformation
}

type PaymentAccountConnection {
  pageInfo: PageInfo!
  edges: [PaymentAccountEdge]!
  aggregate: AggregatePaymentAccount!
}

input PaymentAccountCreateInput {
  id: ID
  type: PAYMENT_PROVIDER
  user: UserCreateOneWithoutPaymentAccountInput!
  payments: PaymentCreateManyWithoutPaymentMethodInput
  paypal: PaypalInformationCreateOneInput
  paytm: PaytmInformationCreateOneInput
  creditcard: CreditCardInformationCreateOneInput
  debitcard: DebitCardInformationCreateOneInput
}

input PaymentAccountCreateManyWithoutUserInput {
  create: [PaymentAccountCreateWithoutUserInput!]
  connect: [PaymentAccountWhereUniqueInput!]
}

input PaymentAccountCreateOneWithoutPaymentsInput {
  create: PaymentAccountCreateWithoutPaymentsInput
  connect: PaymentAccountWhereUniqueInput
}

input PaymentAccountCreateWithoutPaymentsInput {
  id: ID
  type: PAYMENT_PROVIDER
  user: UserCreateOneWithoutPaymentAccountInput!
  paypal: PaypalInformationCreateOneInput
  paytm: PaytmInformationCreateOneInput
  creditcard: CreditCardInformationCreateOneInput
  debitcard: DebitCardInformationCreateOneInput
}

input PaymentAccountCreateWithoutUserInput {
  id: ID
  type: PAYMENT_PROVIDER
  payments: PaymentCreateManyWithoutPaymentMethodInput
  paypal: PaypalInformationCreateOneInput
  paytm: PaytmInformationCreateOneInput
  creditcard: CreditCardInformationCreateOneInput
  debitcard: DebitCardInformationCreateOneInput
}

type PaymentAccountEdge {
  node: PaymentAccount!
  cursor: String!
}

enum PaymentAccountOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  type_ASC
  type_DESC
}

type PaymentAccountPreviousValues {
  id: ID!
  createdAt: DateTime!
  type: PAYMENT_PROVIDER
}

input PaymentAccountScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  type: PAYMENT_PROVIDER
  type_not: PAYMENT_PROVIDER
  type_in: [PAYMENT_PROVIDER!]
  type_not_in: [PAYMENT_PROVIDER!]
  AND: [PaymentAccountScalarWhereInput!]
  OR: [PaymentAccountScalarWhereInput!]
  NOT: [PaymentAccountScalarWhereInput!]
}

type PaymentAccountSubscriptionPayload {
  mutation: MutationType!
  node: PaymentAccount
  updatedFields: [String!]
  previousValues: PaymentAccountPreviousValues
}

input PaymentAccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentAccountWhereInput
  AND: [PaymentAccountSubscriptionWhereInput!]
  OR: [PaymentAccountSubscriptionWhereInput!]
  NOT: [PaymentAccountSubscriptionWhereInput!]
}

input PaymentAccountUpdateInput {
  type: PAYMENT_PROVIDER
  user: UserUpdateOneRequiredWithoutPaymentAccountInput
  payments: PaymentUpdateManyWithoutPaymentMethodInput
  paypal: PaypalInformationUpdateOneInput
  paytm: PaytmInformationUpdateOneInput
  creditcard: CreditCardInformationUpdateOneInput
  debitcard: DebitCardInformationUpdateOneInput
}

input PaymentAccountUpdateManyDataInput {
  type: PAYMENT_PROVIDER
}

input PaymentAccountUpdateManyMutationInput {
  type: PAYMENT_PROVIDER
}

input PaymentAccountUpdateManyWithoutUserInput {
  create: [PaymentAccountCreateWithoutUserInput!]
  delete: [PaymentAccountWhereUniqueInput!]
  connect: [PaymentAccountWhereUniqueInput!]
  set: [PaymentAccountWhereUniqueInput!]
  disconnect: [PaymentAccountWhereUniqueInput!]
  update: [PaymentAccountUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [PaymentAccountUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [PaymentAccountScalarWhereInput!]
  updateMany: [PaymentAccountUpdateManyWithWhereNestedInput!]
}

input PaymentAccountUpdateManyWithWhereNestedInput {
  where: PaymentAccountScalarWhereInput!
  data: PaymentAccountUpdateManyDataInput!
}

input PaymentAccountUpdateOneRequiredWithoutPaymentsInput {
  create: PaymentAccountCreateWithoutPaymentsInput
  update: PaymentAccountUpdateWithoutPaymentsDataInput
  upsert: PaymentAccountUpsertWithoutPaymentsInput
  connect: PaymentAccountWhereUniqueInput
}

input PaymentAccountUpdateWithoutPaymentsDataInput {
  type: PAYMENT_PROVIDER
  user: UserUpdateOneRequiredWithoutPaymentAccountInput
  paypal: PaypalInformationUpdateOneInput
  paytm: PaytmInformationUpdateOneInput
  creditcard: CreditCardInformationUpdateOneInput
  debitcard: DebitCardInformationUpdateOneInput
}

input PaymentAccountUpdateWithoutUserDataInput {
  type: PAYMENT_PROVIDER
  payments: PaymentUpdateManyWithoutPaymentMethodInput
  paypal: PaypalInformationUpdateOneInput
  paytm: PaytmInformationUpdateOneInput
  creditcard: CreditCardInformationUpdateOneInput
  debitcard: DebitCardInformationUpdateOneInput
}

input PaymentAccountUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentAccountWhereUniqueInput!
  data: PaymentAccountUpdateWithoutUserDataInput!
}

input PaymentAccountUpsertWithoutPaymentsInput {
  update: PaymentAccountUpdateWithoutPaymentsDataInput!
  create: PaymentAccountCreateWithoutPaymentsInput!
}

input PaymentAccountUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentAccountWhereUniqueInput!
  update: PaymentAccountUpdateWithoutUserDataInput!
  create: PaymentAccountCreateWithoutUserInput!
}

input PaymentAccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  type: PAYMENT_PROVIDER
  type_not: PAYMENT_PROVIDER
  type_in: [PAYMENT_PROVIDER!]
  type_not_in: [PAYMENT_PROVIDER!]
  user: UserWhereInput
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  paypal: PaypalInformationWhereInput
  paytm: PaytmInformationWhereInput
  creditcard: CreditCardInformationWhereInput
  debitcard: DebitCardInformationWhereInput
  AND: [PaymentAccountWhereInput!]
  OR: [PaymentAccountWhereInput!]
  NOT: [PaymentAccountWhereInput!]
}

input PaymentAccountWhereUniqueInput {
  id: ID
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  serviceFee: Float!
  restaurantPrice: Float!
  totalPrice: Float!
  order: OrderCreateOneWithoutPaymentInput!
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput!
}

input PaymentCreateManyWithoutPaymentMethodInput {
  create: [PaymentCreateWithoutPaymentMethodInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateOneWithoutOrderInput {
  create: PaymentCreateWithoutOrderInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutOrderInput {
  id: ID
  serviceFee: Float!
  restaurantPrice: Float!
  totalPrice: Float!
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput!
}

input PaymentCreateWithoutPaymentMethodInput {
  id: ID
  serviceFee: Float!
  restaurantPrice: Float!
  totalPrice: Float!
  order: OrderCreateOneWithoutPaymentInput!
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  serviceFee_ASC
  serviceFee_DESC
  restaurantPrice_ASC
  restaurantPrice_DESC
  totalPrice_ASC
  totalPrice_DESC
}

type PaymentPreviousValues {
  id: ID!
  createdAt: DateTime!
  serviceFee: Float!
  restaurantPrice: Float!
  totalPrice: Float!
}

input PaymentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  serviceFee: Float
  serviceFee_not: Float
  serviceFee_in: [Float!]
  serviceFee_not_in: [Float!]
  serviceFee_lt: Float
  serviceFee_lte: Float
  serviceFee_gt: Float
  serviceFee_gte: Float
  restaurantPrice: Float
  restaurantPrice_not: Float
  restaurantPrice_in: [Float!]
  restaurantPrice_not_in: [Float!]
  restaurantPrice_lt: Float
  restaurantPrice_lte: Float
  restaurantPrice_gt: Float
  restaurantPrice_gte: Float
  totalPrice: Float
  totalPrice_not: Float
  totalPrice_in: [Float!]
  totalPrice_not_in: [Float!]
  totalPrice_lt: Float
  totalPrice_lte: Float
  totalPrice_gt: Float
  totalPrice_gte: Float
  AND: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  serviceFee: Float
  restaurantPrice: Float
  totalPrice: Float
  order: OrderUpdateOneRequiredWithoutPaymentInput
  paymentMethod: PaymentAccountUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateManyDataInput {
  serviceFee: Float
  restaurantPrice: Float
  totalPrice: Float
}

input PaymentUpdateManyMutationInput {
  serviceFee: Float
  restaurantPrice: Float
  totalPrice: Float
}

input PaymentUpdateManyWithoutPaymentMethodInput {
  create: [PaymentCreateWithoutPaymentMethodInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput!
  data: PaymentUpdateManyDataInput!
}

input PaymentUpdateOneRequiredWithoutOrderInput {
  create: PaymentCreateWithoutOrderInput
  update: PaymentUpdateWithoutOrderDataInput
  upsert: PaymentUpsertWithoutOrderInput
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutOrderDataInput {
  serviceFee: Float
  restaurantPrice: Float
  totalPrice: Float
  paymentMethod: PaymentAccountUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateWithoutPaymentMethodDataInput {
  serviceFee: Float
  restaurantPrice: Float
  totalPrice: Float
  order: OrderUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutPaymentMethodDataInput!
}

input PaymentUpsertWithoutOrderInput {
  update: PaymentUpdateWithoutOrderDataInput!
  create: PaymentCreateWithoutOrderInput!
}

input PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutPaymentMethodDataInput!
  create: PaymentCreateWithoutPaymentMethodInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  serviceFee: Float
  serviceFee_not: Float
  serviceFee_in: [Float!]
  serviceFee_not_in: [Float!]
  serviceFee_lt: Float
  serviceFee_lte: Float
  serviceFee_gt: Float
  serviceFee_gte: Float
  restaurantPrice: Float
  restaurantPrice_not: Float
  restaurantPrice_in: [Float!]
  restaurantPrice_not_in: [Float!]
  restaurantPrice_lt: Float
  restaurantPrice_lte: Float
  restaurantPrice_gt: Float
  restaurantPrice_gte: Float
  totalPrice: Float
  totalPrice_not: Float
  totalPrice_in: [Float!]
  totalPrice_not_in: [Float!]
  totalPrice_lt: Float
  totalPrice_lte: Float
  totalPrice_gt: Float
  totalPrice_gte: Float
  order: OrderWhereInput
  paymentMethod: PaymentAccountWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type PaypalInformation {
  id: ID!
  createdAt: DateTime!
  email: String!
}

type PaypalInformationConnection {
  pageInfo: PageInfo!
  edges: [PaypalInformationEdge]!
  aggregate: AggregatePaypalInformation!
}

input PaypalInformationCreateInput {
  id: ID
  email: String!
}

input PaypalInformationCreateOneInput {
  create: PaypalInformationCreateInput
  connect: PaypalInformationWhereUniqueInput
}

type PaypalInformationEdge {
  node: PaypalInformation!
  cursor: String!
}

enum PaypalInformationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
}

type PaypalInformationPreviousValues {
  id: ID!
  createdAt: DateTime!
  email: String!
}

type PaypalInformationSubscriptionPayload {
  mutation: MutationType!
  node: PaypalInformation
  updatedFields: [String!]
  previousValues: PaypalInformationPreviousValues
}

input PaypalInformationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaypalInformationWhereInput
  AND: [PaypalInformationSubscriptionWhereInput!]
  OR: [PaypalInformationSubscriptionWhereInput!]
  NOT: [PaypalInformationSubscriptionWhereInput!]
}

input PaypalInformationUpdateDataInput {
  email: String
}

input PaypalInformationUpdateInput {
  email: String
}

input PaypalInformationUpdateManyMutationInput {
  email: String
}

input PaypalInformationUpdateOneInput {
  create: PaypalInformationCreateInput
  update: PaypalInformationUpdateDataInput
  upsert: PaypalInformationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PaypalInformationWhereUniqueInput
}

input PaypalInformationUpsertNestedInput {
  update: PaypalInformationUpdateDataInput!
  create: PaypalInformationCreateInput!
}

input PaypalInformationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  AND: [PaypalInformationWhereInput!]
  OR: [PaypalInformationWhereInput!]
  NOT: [PaypalInformationWhereInput!]
}

input PaypalInformationWhereUniqueInput {
  id: ID
}

type PaytmInformation {
  id: ID!
  createdAt: DateTime!
  phone: String!
}

type PaytmInformationConnection {
  pageInfo: PageInfo!
  edges: [PaytmInformationEdge]!
  aggregate: AggregatePaytmInformation!
}

input PaytmInformationCreateInput {
  id: ID
  phone: String!
}

input PaytmInformationCreateOneInput {
  create: PaytmInformationCreateInput
  connect: PaytmInformationWhereUniqueInput
}

type PaytmInformationEdge {
  node: PaytmInformation!
  cursor: String!
}

enum PaytmInformationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  phone_ASC
  phone_DESC
}

type PaytmInformationPreviousValues {
  id: ID!
  createdAt: DateTime!
  phone: String!
}

type PaytmInformationSubscriptionPayload {
  mutation: MutationType!
  node: PaytmInformation
  updatedFields: [String!]
  previousValues: PaytmInformationPreviousValues
}

input PaytmInformationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaytmInformationWhereInput
  AND: [PaytmInformationSubscriptionWhereInput!]
  OR: [PaytmInformationSubscriptionWhereInput!]
  NOT: [PaytmInformationSubscriptionWhereInput!]
}

input PaytmInformationUpdateDataInput {
  phone: String
}

input PaytmInformationUpdateInput {
  phone: String
}

input PaytmInformationUpdateManyMutationInput {
  phone: String
}

input PaytmInformationUpdateOneInput {
  create: PaytmInformationCreateInput
  update: PaytmInformationUpdateDataInput
  upsert: PaytmInformationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PaytmInformationWhereUniqueInput
}

input PaytmInformationUpsertNestedInput {
  update: PaytmInformationUpdateDataInput!
  create: PaytmInformationCreateInput!
}

input PaytmInformationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  AND: [PaytmInformationWhereInput!]
  OR: [PaytmInformationWhereInput!]
  NOT: [PaytmInformationWhereInput!]
}

input PaytmInformationWhereUniqueInput {
  id: ID
}

type Picture {
  id: ID!
  url: String!
}

type PictureConnection {
  pageInfo: PageInfo!
  edges: [PictureEdge]!
  aggregate: AggregatePicture!
}

input PictureCreateInput {
  id: ID
  url: String!
}

input PictureCreateManyInput {
  create: [PictureCreateInput!]
  connect: [PictureWhereUniqueInput!]
}

input PictureCreateOneInput {
  create: PictureCreateInput
  connect: PictureWhereUniqueInput
}

type PictureEdge {
  node: Picture!
  cursor: String!
}

enum PictureOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
}

type PicturePreviousValues {
  id: ID!
  url: String!
}

input PictureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [PictureScalarWhereInput!]
  OR: [PictureScalarWhereInput!]
  NOT: [PictureScalarWhereInput!]
}

type PictureSubscriptionPayload {
  mutation: MutationType!
  node: Picture
  updatedFields: [String!]
  previousValues: PicturePreviousValues
}

input PictureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PictureWhereInput
  AND: [PictureSubscriptionWhereInput!]
  OR: [PictureSubscriptionWhereInput!]
  NOT: [PictureSubscriptionWhereInput!]
}

input PictureUpdateDataInput {
  url: String
}

input PictureUpdateInput {
  url: String
}

input PictureUpdateManyDataInput {
  url: String
}

input PictureUpdateManyInput {
  create: [PictureCreateInput!]
  update: [PictureUpdateWithWhereUniqueNestedInput!]
  upsert: [PictureUpsertWithWhereUniqueNestedInput!]
  delete: [PictureWhereUniqueInput!]
  connect: [PictureWhereUniqueInput!]
  set: [PictureWhereUniqueInput!]
  disconnect: [PictureWhereUniqueInput!]
  deleteMany: [PictureScalarWhereInput!]
  updateMany: [PictureUpdateManyWithWhereNestedInput!]
}

input PictureUpdateManyMutationInput {
  url: String
}

input PictureUpdateManyWithWhereNestedInput {
  where: PictureScalarWhereInput!
  data: PictureUpdateManyDataInput!
}

input PictureUpdateOneInput {
  create: PictureCreateInput
  update: PictureUpdateDataInput
  upsert: PictureUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PictureWhereUniqueInput
}

input PictureUpdateOneRequiredInput {
  create: PictureCreateInput
  update: PictureUpdateDataInput
  upsert: PictureUpsertNestedInput
  connect: PictureWhereUniqueInput
}

input PictureUpdateWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput!
  data: PictureUpdateDataInput!
}

input PictureUpsertNestedInput {
  update: PictureUpdateDataInput!
  create: PictureCreateInput!
}

input PictureUpsertWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput!
  update: PictureUpdateDataInput!
  create: PictureCreateInput!
}

input PictureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [PictureWhereInput!]
  OR: [PictureWhereInput!]
  NOT: [PictureWhereInput!]
}

input PictureWhereUniqueInput {
  id: ID
}

type Policies {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  openingTime: Float!
  closingTime: Float!
}

type PoliciesConnection {
  pageInfo: PageInfo!
  edges: [PoliciesEdge]!
  aggregate: AggregatePolicies!
}

input PoliciesCreateInput {
  id: ID
  openingTime: Float!
  closingTime: Float!
}

input PoliciesCreateOneInput {
  create: PoliciesCreateInput
  connect: PoliciesWhereUniqueInput
}

type PoliciesEdge {
  node: Policies!
  cursor: String!
}

enum PoliciesOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  openingTime_ASC
  openingTime_DESC
  closingTime_ASC
  closingTime_DESC
}

type PoliciesPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  openingTime: Float!
  closingTime: Float!
}

type PoliciesSubscriptionPayload {
  mutation: MutationType!
  node: Policies
  updatedFields: [String!]
  previousValues: PoliciesPreviousValues
}

input PoliciesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PoliciesWhereInput
  AND: [PoliciesSubscriptionWhereInput!]
  OR: [PoliciesSubscriptionWhereInput!]
  NOT: [PoliciesSubscriptionWhereInput!]
}

input PoliciesUpdateDataInput {
  openingTime: Float
  closingTime: Float
}

input PoliciesUpdateInput {
  openingTime: Float
  closingTime: Float
}

input PoliciesUpdateManyMutationInput {
  openingTime: Float
  closingTime: Float
}

input PoliciesUpdateOneInput {
  create: PoliciesCreateInput
  update: PoliciesUpdateDataInput
  upsert: PoliciesUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PoliciesWhereUniqueInput
}

input PoliciesUpsertNestedInput {
  update: PoliciesUpdateDataInput!
  create: PoliciesCreateInput!
}

input PoliciesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  openingTime: Float
  openingTime_not: Float
  openingTime_in: [Float!]
  openingTime_not_in: [Float!]
  openingTime_lt: Float
  openingTime_lte: Float
  openingTime_gt: Float
  openingTime_gte: Float
  closingTime: Float
  closingTime_not: Float
  closingTime_in: [Float!]
  closingTime_not_in: [Float!]
  closingTime_lt: Float
  closingTime_lte: Float
  closingTime_gt: Float
  closingTime_gte: Float
  AND: [PoliciesWhereInput!]
  OR: [PoliciesWhereInput!]
  NOT: [PoliciesWhereInput!]
}

input PoliciesWhereUniqueInput {
  id: ID
}

type Pricing {
  id: ID!
  monthlyDiscount: Int
  weeklyDiscount: Int
  price: Int!
  smartPricing: Boolean!
  basePrice: Int!
  averageWeekly: Int!
  averageMonthly: Int!
  weekendPricing: Int
}

type PricingConnection {
  pageInfo: PageInfo!
  edges: [PricingEdge]!
  aggregate: AggregatePricing!
}

input PricingCreateInput {
  id: ID
  monthlyDiscount: Int
  weeklyDiscount: Int
  price: Int!
  smartPricing: Boolean
  basePrice: Int!
  averageWeekly: Int!
  averageMonthly: Int!
  weekendPricing: Int
}

input PricingCreateOneInput {
  create: PricingCreateInput
  connect: PricingWhereUniqueInput
}

type PricingEdge {
  node: Pricing!
  cursor: String!
}

enum PricingOrderByInput {
  id_ASC
  id_DESC
  monthlyDiscount_ASC
  monthlyDiscount_DESC
  weeklyDiscount_ASC
  weeklyDiscount_DESC
  price_ASC
  price_DESC
  smartPricing_ASC
  smartPricing_DESC
  basePrice_ASC
  basePrice_DESC
  averageWeekly_ASC
  averageWeekly_DESC
  averageMonthly_ASC
  averageMonthly_DESC
  weekendPricing_ASC
  weekendPricing_DESC
}

type PricingPreviousValues {
  id: ID!
  monthlyDiscount: Int
  weeklyDiscount: Int
  price: Int!
  smartPricing: Boolean!
  basePrice: Int!
  averageWeekly: Int!
  averageMonthly: Int!
  weekendPricing: Int
}

type PricingSubscriptionPayload {
  mutation: MutationType!
  node: Pricing
  updatedFields: [String!]
  previousValues: PricingPreviousValues
}

input PricingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PricingWhereInput
  AND: [PricingSubscriptionWhereInput!]
  OR: [PricingSubscriptionWhereInput!]
  NOT: [PricingSubscriptionWhereInput!]
}

input PricingUpdateDataInput {
  monthlyDiscount: Int
  weeklyDiscount: Int
  price: Int
  smartPricing: Boolean
  basePrice: Int
  averageWeekly: Int
  averageMonthly: Int
  weekendPricing: Int
}

input PricingUpdateInput {
  monthlyDiscount: Int
  weeklyDiscount: Int
  price: Int
  smartPricing: Boolean
  basePrice: Int
  averageWeekly: Int
  averageMonthly: Int
  weekendPricing: Int
}

input PricingUpdateManyMutationInput {
  monthlyDiscount: Int
  weeklyDiscount: Int
  price: Int
  smartPricing: Boolean
  basePrice: Int
  averageWeekly: Int
  averageMonthly: Int
  weekendPricing: Int
}

input PricingUpdateOneRequiredInput {
  create: PricingCreateInput
  update: PricingUpdateDataInput
  upsert: PricingUpsertNestedInput
  connect: PricingWhereUniqueInput
}

input PricingUpsertNestedInput {
  update: PricingUpdateDataInput!
  create: PricingCreateInput!
}

input PricingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  monthlyDiscount: Int
  monthlyDiscount_not: Int
  monthlyDiscount_in: [Int!]
  monthlyDiscount_not_in: [Int!]
  monthlyDiscount_lt: Int
  monthlyDiscount_lte: Int
  monthlyDiscount_gt: Int
  monthlyDiscount_gte: Int
  weeklyDiscount: Int
  weeklyDiscount_not: Int
  weeklyDiscount_in: [Int!]
  weeklyDiscount_not_in: [Int!]
  weeklyDiscount_lt: Int
  weeklyDiscount_lte: Int
  weeklyDiscount_gt: Int
  weeklyDiscount_gte: Int
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  smartPricing: Boolean
  smartPricing_not: Boolean
  basePrice: Int
  basePrice_not: Int
  basePrice_in: [Int!]
  basePrice_not_in: [Int!]
  basePrice_lt: Int
  basePrice_lte: Int
  basePrice_gt: Int
  basePrice_gte: Int
  averageWeekly: Int
  averageWeekly_not: Int
  averageWeekly_in: [Int!]
  averageWeekly_not_in: [Int!]
  averageWeekly_lt: Int
  averageWeekly_lte: Int
  averageWeekly_gt: Int
  averageWeekly_gte: Int
  averageMonthly: Int
  averageMonthly_not: Int
  averageMonthly_in: [Int!]
  averageMonthly_not_in: [Int!]
  averageMonthly_lt: Int
  averageMonthly_lte: Int
  averageMonthly_gt: Int
  averageMonthly_gte: Int
  weekendPricing: Int
  weekendPricing_not: Int
  weekendPricing_in: [Int!]
  weekendPricing_not_in: [Int!]
  weekendPricing_lt: Int
  weekendPricing_lte: Int
  weekendPricing_gt: Int
  weekendPricing_gte: Int
  AND: [PricingWhereInput!]
  OR: [PricingWhereInput!]
  NOT: [PricingWhereInput!]
}

input PricingWhereUniqueInput {
  id: ID
}

type Query {
  city(where: CityWhereUniqueInput!): City
  cities(where: CityWhereInput, orderBy: CityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [City]!
  citiesConnection(where: CityWhereInput, orderBy: CityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CityConnection!
  creditCardInformation(where: CreditCardInformationWhereUniqueInput!): CreditCardInformation
  creditCardInformations(where: CreditCardInformationWhereInput, orderBy: CreditCardInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CreditCardInformation]!
  creditCardInformationsConnection(where: CreditCardInformationWhereInput, orderBy: CreditCardInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CreditCardInformationConnection!
  debitCardInformation(where: DebitCardInformationWhereUniqueInput!): DebitCardInformation
  debitCardInformations(where: DebitCardInformationWhereInput, orderBy: DebitCardInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DebitCardInformation]!
  debitCardInformationsConnection(where: DebitCardInformationWhereInput, orderBy: DebitCardInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DebitCardInformationConnection!
  experience(where: ExperienceWhereUniqueInput!): Experience
  experiences(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Experience]!
  experiencesConnection(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExperienceConnection!
  experienceCategory(where: ExperienceCategoryWhereUniqueInput!): ExperienceCategory
  experienceCategories(where: ExperienceCategoryWhereInput, orderBy: ExperienceCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExperienceCategory]!
  experienceCategoriesConnection(where: ExperienceCategoryWhereInput, orderBy: ExperienceCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExperienceCategoryConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  menuItem(where: MenuItemWhereUniqueInput!): MenuItem
  menuItems(where: MenuItemWhereInput, orderBy: MenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuItem]!
  menuItemsConnection(where: MenuItemWhereInput, orderBy: MenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuItemConnection!
  message(where: MessageWhereUniqueInput!): Message
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message]!
  messagesConnection(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MessageConnection!
  neighbourhood(where: NeighbourhoodWhereUniqueInput!): Neighbourhood
  neighbourhoods(where: NeighbourhoodWhereInput, orderBy: NeighbourhoodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Neighbourhood]!
  neighbourhoodsConnection(where: NeighbourhoodWhereInput, orderBy: NeighbourhoodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NeighbourhoodConnection!
  notification(where: NotificationWhereUniqueInput!): Notification
  notifications(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notification]!
  notificationsConnection(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NotificationConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  paymentAccount(where: PaymentAccountWhereUniqueInput!): PaymentAccount
  paymentAccounts(where: PaymentAccountWhereInput, orderBy: PaymentAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentAccount]!
  paymentAccountsConnection(where: PaymentAccountWhereInput, orderBy: PaymentAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentAccountConnection!
  paypalInformation(where: PaypalInformationWhereUniqueInput!): PaypalInformation
  paypalInformations(where: PaypalInformationWhereInput, orderBy: PaypalInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaypalInformation]!
  paypalInformationsConnection(where: PaypalInformationWhereInput, orderBy: PaypalInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaypalInformationConnection!
  paytmInformation(where: PaytmInformationWhereUniqueInput!): PaytmInformation
  paytmInformations(where: PaytmInformationWhereInput, orderBy: PaytmInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaytmInformation]!
  paytmInformationsConnection(where: PaytmInformationWhereInput, orderBy: PaytmInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaytmInformationConnection!
  picture(where: PictureWhereUniqueInput!): Picture
  pictures(where: PictureWhereInput, orderBy: PictureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Picture]!
  picturesConnection(where: PictureWhereInput, orderBy: PictureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PictureConnection!
  policies(where: PoliciesWhereUniqueInput!): Policies
  policieses(where: PoliciesWhereInput, orderBy: PoliciesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Policies]!
  policiesesConnection(where: PoliciesWhereInput, orderBy: PoliciesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PoliciesConnection!
  pricing(where: PricingWhereUniqueInput!): Pricing
  pricings(where: PricingWhereInput, orderBy: PricingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pricing]!
  pricingsConnection(where: PricingWhereInput, orderBy: PricingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PricingConnection!
  restaurant(where: RestaurantWhereUniqueInput!): Restaurant
  restaurants(where: RestaurantWhereInput, orderBy: RestaurantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Restaurant]!
  restaurantsConnection(where: RestaurantWhereInput, orderBy: RestaurantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RestaurantConnection!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review]!
  reviewsConnection(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReviewConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Restaurant {
  id: ID!
  name: String!
  shortDescription: String!
  description: String!
  slug: String!
  maxGuests: Int!
  numRatings: Int!
  avgRating: Float
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  location: Location
  policies: Policies
  menu(where: MenuItemWhereInput, orderBy: MenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuItem!]
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  pictures(where: PictureWhereInput, orderBy: PictureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Picture!]
  popularity: Int!
  avgPricePerPerson: Int!
  isCurated: Boolean!
}

type RestaurantConnection {
  pageInfo: PageInfo!
  edges: [RestaurantEdge]!
  aggregate: AggregateRestaurant!
}

input RestaurantCreateInput {
  id: ID
  name: String!
  shortDescription: String!
  description: String!
  slug: String!
  maxGuests: Int!
  numRatings: Int!
  avgRating: Float
  reviews: ReviewCreateManyInput
  location: LocationCreateOneInput
  policies: PoliciesCreateOneInput
  menu: MenuItemCreateManyInput
  orders: OrderCreateManyWithoutRestaurantInput
  pictures: PictureCreateManyInput
  popularity: Int!
  avgPricePerPerson: Int!
  isCurated: Boolean
}

input RestaurantCreateManyInput {
  create: [RestaurantCreateInput!]
  connect: [RestaurantWhereUniqueInput!]
}

input RestaurantCreateOneWithoutOrdersInput {
  create: RestaurantCreateWithoutOrdersInput
  connect: RestaurantWhereUniqueInput
}

input RestaurantCreateWithoutOrdersInput {
  id: ID
  name: String!
  shortDescription: String!
  description: String!
  slug: String!
  maxGuests: Int!
  numRatings: Int!
  avgRating: Float
  reviews: ReviewCreateManyInput
  location: LocationCreateOneInput
  policies: PoliciesCreateOneInput
  menu: MenuItemCreateManyInput
  pictures: PictureCreateManyInput
  popularity: Int!
  avgPricePerPerson: Int!
  isCurated: Boolean
}

type RestaurantEdge {
  node: Restaurant!
  cursor: String!
}

enum RestaurantOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  shortDescription_ASC
  shortDescription_DESC
  description_ASC
  description_DESC
  slug_ASC
  slug_DESC
  maxGuests_ASC
  maxGuests_DESC
  numRatings_ASC
  numRatings_DESC
  avgRating_ASC
  avgRating_DESC
  popularity_ASC
  popularity_DESC
  avgPricePerPerson_ASC
  avgPricePerPerson_DESC
  isCurated_ASC
  isCurated_DESC
}

type RestaurantPreviousValues {
  id: ID!
  name: String!
  shortDescription: String!
  description: String!
  slug: String!
  maxGuests: Int!
  numRatings: Int!
  avgRating: Float
  popularity: Int!
  avgPricePerPerson: Int!
  isCurated: Boolean!
}

input RestaurantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  shortDescription: String
  shortDescription_not: String
  shortDescription_in: [String!]
  shortDescription_not_in: [String!]
  shortDescription_lt: String
  shortDescription_lte: String
  shortDescription_gt: String
  shortDescription_gte: String
  shortDescription_contains: String
  shortDescription_not_contains: String
  shortDescription_starts_with: String
  shortDescription_not_starts_with: String
  shortDescription_ends_with: String
  shortDescription_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  maxGuests: Int
  maxGuests_not: Int
  maxGuests_in: [Int!]
  maxGuests_not_in: [Int!]
  maxGuests_lt: Int
  maxGuests_lte: Int
  maxGuests_gt: Int
  maxGuests_gte: Int
  numRatings: Int
  numRatings_not: Int
  numRatings_in: [Int!]
  numRatings_not_in: [Int!]
  numRatings_lt: Int
  numRatings_lte: Int
  numRatings_gt: Int
  numRatings_gte: Int
  avgRating: Float
  avgRating_not: Float
  avgRating_in: [Float!]
  avgRating_not_in: [Float!]
  avgRating_lt: Float
  avgRating_lte: Float
  avgRating_gt: Float
  avgRating_gte: Float
  popularity: Int
  popularity_not: Int
  popularity_in: [Int!]
  popularity_not_in: [Int!]
  popularity_lt: Int
  popularity_lte: Int
  popularity_gt: Int
  popularity_gte: Int
  avgPricePerPerson: Int
  avgPricePerPerson_not: Int
  avgPricePerPerson_in: [Int!]
  avgPricePerPerson_not_in: [Int!]
  avgPricePerPerson_lt: Int
  avgPricePerPerson_lte: Int
  avgPricePerPerson_gt: Int
  avgPricePerPerson_gte: Int
  isCurated: Boolean
  isCurated_not: Boolean
  AND: [RestaurantScalarWhereInput!]
  OR: [RestaurantScalarWhereInput!]
  NOT: [RestaurantScalarWhereInput!]
}

type RestaurantSubscriptionPayload {
  mutation: MutationType!
  node: Restaurant
  updatedFields: [String!]
  previousValues: RestaurantPreviousValues
}

input RestaurantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RestaurantWhereInput
  AND: [RestaurantSubscriptionWhereInput!]
  OR: [RestaurantSubscriptionWhereInput!]
  NOT: [RestaurantSubscriptionWhereInput!]
}

input RestaurantUpdateDataInput {
  name: String
  shortDescription: String
  description: String
  slug: String
  maxGuests: Int
  numRatings: Int
  avgRating: Float
  reviews: ReviewUpdateManyInput
  location: LocationUpdateOneInput
  policies: PoliciesUpdateOneInput
  menu: MenuItemUpdateManyInput
  orders: OrderUpdateManyWithoutRestaurantInput
  pictures: PictureUpdateManyInput
  popularity: Int
  avgPricePerPerson: Int
  isCurated: Boolean
}

input RestaurantUpdateInput {
  name: String
  shortDescription: String
  description: String
  slug: String
  maxGuests: Int
  numRatings: Int
  avgRating: Float
  reviews: ReviewUpdateManyInput
  location: LocationUpdateOneInput
  policies: PoliciesUpdateOneInput
  menu: MenuItemUpdateManyInput
  orders: OrderUpdateManyWithoutRestaurantInput
  pictures: PictureUpdateManyInput
  popularity: Int
  avgPricePerPerson: Int
  isCurated: Boolean
}

input RestaurantUpdateManyDataInput {
  name: String
  shortDescription: String
  description: String
  slug: String
  maxGuests: Int
  numRatings: Int
  avgRating: Float
  popularity: Int
  avgPricePerPerson: Int
  isCurated: Boolean
}

input RestaurantUpdateManyInput {
  create: [RestaurantCreateInput!]
  update: [RestaurantUpdateWithWhereUniqueNestedInput!]
  upsert: [RestaurantUpsertWithWhereUniqueNestedInput!]
  delete: [RestaurantWhereUniqueInput!]
  connect: [RestaurantWhereUniqueInput!]
  set: [RestaurantWhereUniqueInput!]
  disconnect: [RestaurantWhereUniqueInput!]
  deleteMany: [RestaurantScalarWhereInput!]
  updateMany: [RestaurantUpdateManyWithWhereNestedInput!]
}

input RestaurantUpdateManyMutationInput {
  name: String
  shortDescription: String
  description: String
  slug: String
  maxGuests: Int
  numRatings: Int
  avgRating: Float
  popularity: Int
  avgPricePerPerson: Int
  isCurated: Boolean
}

input RestaurantUpdateManyWithWhereNestedInput {
  where: RestaurantScalarWhereInput!
  data: RestaurantUpdateManyDataInput!
}

input RestaurantUpdateOneRequiredWithoutOrdersInput {
  create: RestaurantCreateWithoutOrdersInput
  update: RestaurantUpdateWithoutOrdersDataInput
  upsert: RestaurantUpsertWithoutOrdersInput
  connect: RestaurantWhereUniqueInput
}

input RestaurantUpdateWithoutOrdersDataInput {
  name: String
  shortDescription: String
  description: String
  slug: String
  maxGuests: Int
  numRatings: Int
  avgRating: Float
  reviews: ReviewUpdateManyInput
  location: LocationUpdateOneInput
  policies: PoliciesUpdateOneInput
  menu: MenuItemUpdateManyInput
  pictures: PictureUpdateManyInput
  popularity: Int
  avgPricePerPerson: Int
  isCurated: Boolean
}

input RestaurantUpdateWithWhereUniqueNestedInput {
  where: RestaurantWhereUniqueInput!
  data: RestaurantUpdateDataInput!
}

input RestaurantUpsertWithoutOrdersInput {
  update: RestaurantUpdateWithoutOrdersDataInput!
  create: RestaurantCreateWithoutOrdersInput!
}

input RestaurantUpsertWithWhereUniqueNestedInput {
  where: RestaurantWhereUniqueInput!
  update: RestaurantUpdateDataInput!
  create: RestaurantCreateInput!
}

input RestaurantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  shortDescription: String
  shortDescription_not: String
  shortDescription_in: [String!]
  shortDescription_not_in: [String!]
  shortDescription_lt: String
  shortDescription_lte: String
  shortDescription_gt: String
  shortDescription_gte: String
  shortDescription_contains: String
  shortDescription_not_contains: String
  shortDescription_starts_with: String
  shortDescription_not_starts_with: String
  shortDescription_ends_with: String
  shortDescription_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  maxGuests: Int
  maxGuests_not: Int
  maxGuests_in: [Int!]
  maxGuests_not_in: [Int!]
  maxGuests_lt: Int
  maxGuests_lte: Int
  maxGuests_gt: Int
  maxGuests_gte: Int
  numRatings: Int
  numRatings_not: Int
  numRatings_in: [Int!]
  numRatings_not_in: [Int!]
  numRatings_lt: Int
  numRatings_lte: Int
  numRatings_gt: Int
  numRatings_gte: Int
  avgRating: Float
  avgRating_not: Float
  avgRating_in: [Float!]
  avgRating_not_in: [Float!]
  avgRating_lt: Float
  avgRating_lte: Float
  avgRating_gt: Float
  avgRating_gte: Float
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  location: LocationWhereInput
  policies: PoliciesWhereInput
  menu_every: MenuItemWhereInput
  menu_some: MenuItemWhereInput
  menu_none: MenuItemWhereInput
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  pictures_every: PictureWhereInput
  pictures_some: PictureWhereInput
  pictures_none: PictureWhereInput
  popularity: Int
  popularity_not: Int
  popularity_in: [Int!]
  popularity_not_in: [Int!]
  popularity_lt: Int
  popularity_lte: Int
  popularity_gt: Int
  popularity_gte: Int
  avgPricePerPerson: Int
  avgPricePerPerson_not: Int
  avgPricePerPerson_in: [Int!]
  avgPricePerPerson_not_in: [Int!]
  avgPricePerPerson_lt: Int
  avgPricePerPerson_lte: Int
  avgPricePerPerson_gt: Int
  avgPricePerPerson_gte: Int
  isCurated: Boolean
  isCurated_not: Boolean
  AND: [RestaurantWhereInput!]
  OR: [RestaurantWhereInput!]
  NOT: [RestaurantWhereInput!]
}

input RestaurantWhereUniqueInput {
  id: ID
}

type Review {
  id: ID!
  createdAt: DateTime!
  text: String!
  stars: Int!
  accuracy: Int!
  location: Int!
  checkIn: Int!
  value: Int!
  cleanliness: Int!
  communication: Int!
  order: Order!
  experience: Experience
}

type ReviewConnection {
  pageInfo: PageInfo!
  edges: [ReviewEdge]!
  aggregate: AggregateReview!
}

input ReviewCreateInput {
  id: ID
  text: String!
  stars: Int!
  accuracy: Int!
  location: Int!
  checkIn: Int!
  value: Int!
  cleanliness: Int!
  communication: Int!
  order: OrderCreateOneInput!
  experience: ExperienceCreateOneWithoutReviewsInput
}

input ReviewCreateManyInput {
  create: [ReviewCreateInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateManyWithoutExperienceInput {
  create: [ReviewCreateWithoutExperienceInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateWithoutExperienceInput {
  id: ID
  text: String!
  stars: Int!
  accuracy: Int!
  location: Int!
  checkIn: Int!
  value: Int!
  cleanliness: Int!
  communication: Int!
  order: OrderCreateOneInput!
}

type ReviewEdge {
  node: Review!
  cursor: String!
}

enum ReviewOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  text_ASC
  text_DESC
  stars_ASC
  stars_DESC
  accuracy_ASC
  accuracy_DESC
  location_ASC
  location_DESC
  checkIn_ASC
  checkIn_DESC
  value_ASC
  value_DESC
  cleanliness_ASC
  cleanliness_DESC
  communication_ASC
  communication_DESC
}

type ReviewPreviousValues {
  id: ID!
  createdAt: DateTime!
  text: String!
  stars: Int!
  accuracy: Int!
  location: Int!
  checkIn: Int!
  value: Int!
  cleanliness: Int!
  communication: Int!
}

input ReviewScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  stars: Int
  stars_not: Int
  stars_in: [Int!]
  stars_not_in: [Int!]
  stars_lt: Int
  stars_lte: Int
  stars_gt: Int
  stars_gte: Int
  accuracy: Int
  accuracy_not: Int
  accuracy_in: [Int!]
  accuracy_not_in: [Int!]
  accuracy_lt: Int
  accuracy_lte: Int
  accuracy_gt: Int
  accuracy_gte: Int
  location: Int
  location_not: Int
  location_in: [Int!]
  location_not_in: [Int!]
  location_lt: Int
  location_lte: Int
  location_gt: Int
  location_gte: Int
  checkIn: Int
  checkIn_not: Int
  checkIn_in: [Int!]
  checkIn_not_in: [Int!]
  checkIn_lt: Int
  checkIn_lte: Int
  checkIn_gt: Int
  checkIn_gte: Int
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  cleanliness: Int
  cleanliness_not: Int
  cleanliness_in: [Int!]
  cleanliness_not_in: [Int!]
  cleanliness_lt: Int
  cleanliness_lte: Int
  cleanliness_gt: Int
  cleanliness_gte: Int
  communication: Int
  communication_not: Int
  communication_in: [Int!]
  communication_not_in: [Int!]
  communication_lt: Int
  communication_lte: Int
  communication_gt: Int
  communication_gte: Int
  AND: [ReviewScalarWhereInput!]
  OR: [ReviewScalarWhereInput!]
  NOT: [ReviewScalarWhereInput!]
}

type ReviewSubscriptionPayload {
  mutation: MutationType!
  node: Review
  updatedFields: [String!]
  previousValues: ReviewPreviousValues
}

input ReviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReviewWhereInput
  AND: [ReviewSubscriptionWhereInput!]
  OR: [ReviewSubscriptionWhereInput!]
  NOT: [ReviewSubscriptionWhereInput!]
}

input ReviewUpdateDataInput {
  text: String
  stars: Int
  accuracy: Int
  location: Int
  checkIn: Int
  value: Int
  cleanliness: Int
  communication: Int
  order: OrderUpdateOneRequiredInput
  experience: ExperienceUpdateOneWithoutReviewsInput
}

input ReviewUpdateInput {
  text: String
  stars: Int
  accuracy: Int
  location: Int
  checkIn: Int
  value: Int
  cleanliness: Int
  communication: Int
  order: OrderUpdateOneRequiredInput
  experience: ExperienceUpdateOneWithoutReviewsInput
}

input ReviewUpdateManyDataInput {
  text: String
  stars: Int
  accuracy: Int
  location: Int
  checkIn: Int
  value: Int
  cleanliness: Int
  communication: Int
}

input ReviewUpdateManyInput {
  create: [ReviewCreateInput!]
  update: [ReviewUpdateWithWhereUniqueNestedInput!]
  upsert: [ReviewUpsertWithWhereUniqueNestedInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyMutationInput {
  text: String
  stars: Int
  accuracy: Int
  location: Int
  checkIn: Int
  value: Int
  cleanliness: Int
  communication: Int
}

input ReviewUpdateManyWithoutExperienceInput {
  create: [ReviewCreateWithoutExperienceInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutExperienceInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutExperienceInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput!
  data: ReviewUpdateManyDataInput!
}

input ReviewUpdateWithoutExperienceDataInput {
  text: String
  stars: Int
  accuracy: Int
  location: Int
  checkIn: Int
  value: Int
  cleanliness: Int
  communication: Int
  order: OrderUpdateOneRequiredInput
}

input ReviewUpdateWithWhereUniqueNestedInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateDataInput!
}

input ReviewUpdateWithWhereUniqueWithoutExperienceInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutExperienceDataInput!
}

input ReviewUpsertWithWhereUniqueNestedInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateDataInput!
  create: ReviewCreateInput!
}

input ReviewUpsertWithWhereUniqueWithoutExperienceInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutExperienceDataInput!
  create: ReviewCreateWithoutExperienceInput!
}

input ReviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  stars: Int
  stars_not: Int
  stars_in: [Int!]
  stars_not_in: [Int!]
  stars_lt: Int
  stars_lte: Int
  stars_gt: Int
  stars_gte: Int
  accuracy: Int
  accuracy_not: Int
  accuracy_in: [Int!]
  accuracy_not_in: [Int!]
  accuracy_lt: Int
  accuracy_lte: Int
  accuracy_gt: Int
  accuracy_gte: Int
  location: Int
  location_not: Int
  location_in: [Int!]
  location_not_in: [Int!]
  location_lt: Int
  location_lte: Int
  location_gt: Int
  location_gte: Int
  checkIn: Int
  checkIn_not: Int
  checkIn_in: [Int!]
  checkIn_not_in: [Int!]
  checkIn_lt: Int
  checkIn_lte: Int
  checkIn_gt: Int
  checkIn_gte: Int
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  cleanliness: Int
  cleanliness_not: Int
  cleanliness_in: [Int!]
  cleanliness_not_in: [Int!]
  cleanliness_lt: Int
  cleanliness_lte: Int
  cleanliness_gt: Int
  cleanliness_gte: Int
  communication: Int
  communication_not: Int
  communication_in: [Int!]
  communication_not_in: [Int!]
  communication_lt: Int
  communication_lte: Int
  communication_gt: Int
  communication_gte: Int
  order: OrderWhereInput
  experience: ExperienceWhereInput
  AND: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
}

input ReviewWhereUniqueInput {
  id: ID
}

type Subscription {
  city(where: CitySubscriptionWhereInput): CitySubscriptionPayload
  creditCardInformation(where: CreditCardInformationSubscriptionWhereInput): CreditCardInformationSubscriptionPayload
  debitCardInformation(where: DebitCardInformationSubscriptionWhereInput): DebitCardInformationSubscriptionPayload
  experience(where: ExperienceSubscriptionWhereInput): ExperienceSubscriptionPayload
  experienceCategory(where: ExperienceCategorySubscriptionWhereInput): ExperienceCategorySubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  menuItem(where: MenuItemSubscriptionWhereInput): MenuItemSubscriptionPayload
  message(where: MessageSubscriptionWhereInput): MessageSubscriptionPayload
  neighbourhood(where: NeighbourhoodSubscriptionWhereInput): NeighbourhoodSubscriptionPayload
  notification(where: NotificationSubscriptionWhereInput): NotificationSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  paymentAccount(where: PaymentAccountSubscriptionWhereInput): PaymentAccountSubscriptionPayload
  paypalInformation(where: PaypalInformationSubscriptionWhereInput): PaypalInformationSubscriptionPayload
  paytmInformation(where: PaytmInformationSubscriptionWhereInput): PaytmInformationSubscriptionPayload
  picture(where: PictureSubscriptionWhereInput): PictureSubscriptionPayload
  policies(where: PoliciesSubscriptionWhereInput): PoliciesSubscriptionPayload
  pricing(where: PricingSubscriptionWhereInput): PricingSubscriptionPayload
  restaurant(where: RestaurantSubscriptionWhereInput): RestaurantSubscriptionPayload
  review(where: ReviewSubscriptionWhereInput): ReviewSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  displayName: String!
  phoneNumber: String!
  responseRate: Float
  responseTime: Int
  ownedRestaurant(where: RestaurantWhereInput, orderBy: RestaurantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Restaurant!]
  location(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location!]
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  paymentAccount(where: PaymentAccountWhereInput, orderBy: PaymentAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentAccount!]
  sentMessages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message!]
  receivedMessages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message!]
  notifications(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notification!]
  profilePicture: Picture
  experiences(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Experience!]
  accountType: UserType
  uid: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  displayName: String!
  phoneNumber: String!
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantCreateManyInput
  location: LocationCreateManyInput
  orders: OrderCreateManyWithoutBookeeInput
  paymentAccount: PaymentAccountCreateManyWithoutUserInput
  sentMessages: MessageCreateManyWithoutFromInput
  receivedMessages: MessageCreateManyWithoutToInput
  notifications: NotificationCreateManyWithoutUserInput
  profilePicture: PictureCreateOneInput
  experiences: ExperienceCreateManyWithoutHostInput
  accountType: UserType
  uid: String!
}

input UserCreateOneWithoutExperiencesInput {
  create: UserCreateWithoutExperiencesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutNotificationsInput {
  create: UserCreateWithoutNotificationsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPaymentAccountInput {
  create: UserCreateWithoutPaymentAccountInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutReceivedMessagesInput {
  create: UserCreateWithoutReceivedMessagesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutSentMessagesInput {
  create: UserCreateWithoutSentMessagesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutExperiencesInput {
  id: ID
  displayName: String!
  phoneNumber: String!
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantCreateManyInput
  location: LocationCreateManyInput
  orders: OrderCreateManyWithoutBookeeInput
  paymentAccount: PaymentAccountCreateManyWithoutUserInput
  sentMessages: MessageCreateManyWithoutFromInput
  receivedMessages: MessageCreateManyWithoutToInput
  notifications: NotificationCreateManyWithoutUserInput
  profilePicture: PictureCreateOneInput
  accountType: UserType
  uid: String!
}

input UserCreateWithoutNotificationsInput {
  id: ID
  displayName: String!
  phoneNumber: String!
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantCreateManyInput
  location: LocationCreateManyInput
  orders: OrderCreateManyWithoutBookeeInput
  paymentAccount: PaymentAccountCreateManyWithoutUserInput
  sentMessages: MessageCreateManyWithoutFromInput
  receivedMessages: MessageCreateManyWithoutToInput
  profilePicture: PictureCreateOneInput
  experiences: ExperienceCreateManyWithoutHostInput
  accountType: UserType
  uid: String!
}

input UserCreateWithoutOrdersInput {
  id: ID
  displayName: String!
  phoneNumber: String!
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantCreateManyInput
  location: LocationCreateManyInput
  paymentAccount: PaymentAccountCreateManyWithoutUserInput
  sentMessages: MessageCreateManyWithoutFromInput
  receivedMessages: MessageCreateManyWithoutToInput
  notifications: NotificationCreateManyWithoutUserInput
  profilePicture: PictureCreateOneInput
  experiences: ExperienceCreateManyWithoutHostInput
  accountType: UserType
  uid: String!
}

input UserCreateWithoutPaymentAccountInput {
  id: ID
  displayName: String!
  phoneNumber: String!
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantCreateManyInput
  location: LocationCreateManyInput
  orders: OrderCreateManyWithoutBookeeInput
  sentMessages: MessageCreateManyWithoutFromInput
  receivedMessages: MessageCreateManyWithoutToInput
  notifications: NotificationCreateManyWithoutUserInput
  profilePicture: PictureCreateOneInput
  experiences: ExperienceCreateManyWithoutHostInput
  accountType: UserType
  uid: String!
}

input UserCreateWithoutReceivedMessagesInput {
  id: ID
  displayName: String!
  phoneNumber: String!
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantCreateManyInput
  location: LocationCreateManyInput
  orders: OrderCreateManyWithoutBookeeInput
  paymentAccount: PaymentAccountCreateManyWithoutUserInput
  sentMessages: MessageCreateManyWithoutFromInput
  notifications: NotificationCreateManyWithoutUserInput
  profilePicture: PictureCreateOneInput
  experiences: ExperienceCreateManyWithoutHostInput
  accountType: UserType
  uid: String!
}

input UserCreateWithoutSentMessagesInput {
  id: ID
  displayName: String!
  phoneNumber: String!
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantCreateManyInput
  location: LocationCreateManyInput
  orders: OrderCreateManyWithoutBookeeInput
  paymentAccount: PaymentAccountCreateManyWithoutUserInput
  receivedMessages: MessageCreateManyWithoutToInput
  notifications: NotificationCreateManyWithoutUserInput
  profilePicture: PictureCreateOneInput
  experiences: ExperienceCreateManyWithoutHostInput
  accountType: UserType
  uid: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  displayName_ASC
  displayName_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  responseRate_ASC
  responseRate_DESC
  responseTime_ASC
  responseTime_DESC
  accountType_ASC
  accountType_DESC
  uid_ASC
  uid_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  displayName: String!
  phoneNumber: String!
  responseRate: Float
  responseTime: Int
  accountType: UserType
  uid: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

enum UserType {
  ADMIN
  SELLER
  CONSUMER
}

input UserUpdateInput {
  displayName: String
  phoneNumber: String
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantUpdateManyInput
  location: LocationUpdateManyInput
  orders: OrderUpdateManyWithoutBookeeInput
  paymentAccount: PaymentAccountUpdateManyWithoutUserInput
  sentMessages: MessageUpdateManyWithoutFromInput
  receivedMessages: MessageUpdateManyWithoutToInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  experiences: ExperienceUpdateManyWithoutHostInput
  accountType: UserType
  uid: String
}

input UserUpdateManyMutationInput {
  displayName: String
  phoneNumber: String
  responseRate: Float
  responseTime: Int
  accountType: UserType
  uid: String
}

input UserUpdateOneRequiredWithoutExperiencesInput {
  create: UserCreateWithoutExperiencesInput
  update: UserUpdateWithoutExperiencesDataInput
  upsert: UserUpsertWithoutExperiencesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutNotificationsInput {
  create: UserCreateWithoutNotificationsInput
  update: UserUpdateWithoutNotificationsDataInput
  upsert: UserUpsertWithoutNotificationsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  update: UserUpdateWithoutOrdersDataInput
  upsert: UserUpsertWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPaymentAccountInput {
  create: UserCreateWithoutPaymentAccountInput
  update: UserUpdateWithoutPaymentAccountDataInput
  upsert: UserUpsertWithoutPaymentAccountInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutReceivedMessagesInput {
  create: UserCreateWithoutReceivedMessagesInput
  update: UserUpdateWithoutReceivedMessagesDataInput
  upsert: UserUpsertWithoutReceivedMessagesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutSentMessagesInput {
  create: UserCreateWithoutSentMessagesInput
  update: UserUpdateWithoutSentMessagesDataInput
  upsert: UserUpsertWithoutSentMessagesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutExperiencesDataInput {
  displayName: String
  phoneNumber: String
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantUpdateManyInput
  location: LocationUpdateManyInput
  orders: OrderUpdateManyWithoutBookeeInput
  paymentAccount: PaymentAccountUpdateManyWithoutUserInput
  sentMessages: MessageUpdateManyWithoutFromInput
  receivedMessages: MessageUpdateManyWithoutToInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  accountType: UserType
  uid: String
}

input UserUpdateWithoutNotificationsDataInput {
  displayName: String
  phoneNumber: String
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantUpdateManyInput
  location: LocationUpdateManyInput
  orders: OrderUpdateManyWithoutBookeeInput
  paymentAccount: PaymentAccountUpdateManyWithoutUserInput
  sentMessages: MessageUpdateManyWithoutFromInput
  receivedMessages: MessageUpdateManyWithoutToInput
  profilePicture: PictureUpdateOneInput
  experiences: ExperienceUpdateManyWithoutHostInput
  accountType: UserType
  uid: String
}

input UserUpdateWithoutOrdersDataInput {
  displayName: String
  phoneNumber: String
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantUpdateManyInput
  location: LocationUpdateManyInput
  paymentAccount: PaymentAccountUpdateManyWithoutUserInput
  sentMessages: MessageUpdateManyWithoutFromInput
  receivedMessages: MessageUpdateManyWithoutToInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  experiences: ExperienceUpdateManyWithoutHostInput
  accountType: UserType
  uid: String
}

input UserUpdateWithoutPaymentAccountDataInput {
  displayName: String
  phoneNumber: String
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantUpdateManyInput
  location: LocationUpdateManyInput
  orders: OrderUpdateManyWithoutBookeeInput
  sentMessages: MessageUpdateManyWithoutFromInput
  receivedMessages: MessageUpdateManyWithoutToInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  experiences: ExperienceUpdateManyWithoutHostInput
  accountType: UserType
  uid: String
}

input UserUpdateWithoutReceivedMessagesDataInput {
  displayName: String
  phoneNumber: String
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantUpdateManyInput
  location: LocationUpdateManyInput
  orders: OrderUpdateManyWithoutBookeeInput
  paymentAccount: PaymentAccountUpdateManyWithoutUserInput
  sentMessages: MessageUpdateManyWithoutFromInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  experiences: ExperienceUpdateManyWithoutHostInput
  accountType: UserType
  uid: String
}

input UserUpdateWithoutSentMessagesDataInput {
  displayName: String
  phoneNumber: String
  responseRate: Float
  responseTime: Int
  ownedRestaurant: RestaurantUpdateManyInput
  location: LocationUpdateManyInput
  orders: OrderUpdateManyWithoutBookeeInput
  paymentAccount: PaymentAccountUpdateManyWithoutUserInput
  receivedMessages: MessageUpdateManyWithoutToInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  experiences: ExperienceUpdateManyWithoutHostInput
  accountType: UserType
  uid: String
}

input UserUpsertWithoutExperiencesInput {
  update: UserUpdateWithoutExperiencesDataInput!
  create: UserCreateWithoutExperiencesInput!
}

input UserUpsertWithoutNotificationsInput {
  update: UserUpdateWithoutNotificationsDataInput!
  create: UserCreateWithoutNotificationsInput!
}

input UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput!
  create: UserCreateWithoutOrdersInput!
}

input UserUpsertWithoutPaymentAccountInput {
  update: UserUpdateWithoutPaymentAccountDataInput!
  create: UserCreateWithoutPaymentAccountInput!
}

input UserUpsertWithoutReceivedMessagesInput {
  update: UserUpdateWithoutReceivedMessagesDataInput!
  create: UserCreateWithoutReceivedMessagesInput!
}

input UserUpsertWithoutSentMessagesInput {
  update: UserUpdateWithoutSentMessagesDataInput!
  create: UserCreateWithoutSentMessagesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  displayName: String
  displayName_not: String
  displayName_in: [String!]
  displayName_not_in: [String!]
  displayName_lt: String
  displayName_lte: String
  displayName_gt: String
  displayName_gte: String
  displayName_contains: String
  displayName_not_contains: String
  displayName_starts_with: String
  displayName_not_starts_with: String
  displayName_ends_with: String
  displayName_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  responseRate: Float
  responseRate_not: Float
  responseRate_in: [Float!]
  responseRate_not_in: [Float!]
  responseRate_lt: Float
  responseRate_lte: Float
  responseRate_gt: Float
  responseRate_gte: Float
  responseTime: Int
  responseTime_not: Int
  responseTime_in: [Int!]
  responseTime_not_in: [Int!]
  responseTime_lt: Int
  responseTime_lte: Int
  responseTime_gt: Int
  responseTime_gte: Int
  ownedRestaurant_every: RestaurantWhereInput
  ownedRestaurant_some: RestaurantWhereInput
  ownedRestaurant_none: RestaurantWhereInput
  location_every: LocationWhereInput
  location_some: LocationWhereInput
  location_none: LocationWhereInput
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  paymentAccount_every: PaymentAccountWhereInput
  paymentAccount_some: PaymentAccountWhereInput
  paymentAccount_none: PaymentAccountWhereInput
  sentMessages_every: MessageWhereInput
  sentMessages_some: MessageWhereInput
  sentMessages_none: MessageWhereInput
  receivedMessages_every: MessageWhereInput
  receivedMessages_some: MessageWhereInput
  receivedMessages_none: MessageWhereInput
  notifications_every: NotificationWhereInput
  notifications_some: NotificationWhereInput
  notifications_none: NotificationWhereInput
  profilePicture: PictureWhereInput
  experiences_every: ExperienceWhereInput
  experiences_some: ExperienceWhereInput
  experiences_none: ExperienceWhereInput
  accountType: UserType
  accountType_not: UserType
  accountType_in: [UserType!]
  accountType_not_in: [UserType!]
  uid: String
  uid_not: String
  uid_in: [String!]
  uid_not_in: [String!]
  uid_lt: String
  uid_lte: String
  uid_gt: String
  uid_gte: String
  uid_contains: String
  uid_not_contains: String
  uid_starts_with: String
  uid_not_starts_with: String
  uid_ends_with: String
  uid_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  uid: String
}
`